// Copyright (C) 2019-2025, Lux Industries Inc. All rights reserved.
// See the file LICENSE for licensing terms.

package beam

import (
	"context"
	"crypto/rand"
	"fmt"
	"sync"
	"sync/atomic"
	"testing"
	"time"
	
	"github.com/luxfi/ids"
	"github.com/luxfi/crypto/bls"
	"github.com/stretchr/testify/require"
)

// NetworkSimulator simulates a network of validators
type NetworkSimulator struct {
	validators   []*ValidatorNode
	network      *SimulatedNetwork
	attackers    map[int]bool
	partitioned  map[int]int // node index -> partition
}

// ValidatorNode represents a validator in the simulation
type ValidatorNode struct {
	id       int
	nodeID   ids.NodeID
	engine   *Engine
	inbox    chan Message
	outbox   chan Message
	ctx      context.Context
	cancel   context.CancelFunc
	
	// Metrics
	blocksProposed   int32
	blocksFinalized  int32
	slashingDetected int32
}

// Message represents a network message
type Message struct {
	From   int
	To     int
	Type   string
	Height uint64
	Data   []byte
}

// SimulatedNetwork handles message routing
type SimulatedNetwork struct {
	latency    time.Duration
	packetLoss float64
	nodes      []*ValidatorNode
	messages   chan Message
}

// TestNetworkPartitionRecovery tests consensus during network partitions
func TestNetworkPartitionRecovery(t *testing.T) {
	require := require.New(t)
	
	// Create 21-node network
	sim := createNetworkSimulation(t, 21, 15)
	defer sim.Stop()
	
	// Run normally for 10 blocks
	sim.Run(10 * time.Second)
	
	initialBlocks := sim.GetFinalizedBlocks()
	require.Greater(initialBlocks, int32(5), "Should finalize at least 5 blocks")
	
	// Create partition (7 nodes isolated)
	sim.CreatePartition([]int{0, 1, 2, 3, 4, 5, 6}, []int{7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20})
	
	// Run with partition
	sim.Run(5 * time.Second)
	
	// No new blocks should be finalized (no quorum)
	partitionBlocks := sim.GetFinalizedBlocks()
	require.Equal(initialBlocks, partitionBlocks, "No blocks during partition")
	
	// Heal partition
	sim.HealPartition()
	
	// Run after healing
	sim.Run(10 * time.Second)
	
	// Should resume finalizing blocks
	finalBlocks := sim.GetFinalizedBlocks()
	require.Greater(finalBlocks, partitionBlocks, "Should resume after partition heals")
}

// TestByzantineValidatorDetection tests detection of Byzantine validators
func TestByzantineValidatorDetection(t *testing.T) {
	require := require.New(t)
	
	// Create network with Byzantine validators
	sim := createNetworkSimulation(t, 21, 15)
	defer sim.Stop()
	
	// Make nodes 0-5 Byzantine (less than 1/3)
	for i := 0; i < 6; i++ {
		sim.MakeByzantine(i)
	}
	
	// Run simulation
	sim.Run(20 * time.Second)
	
	// Should still finalize blocks (honest majority)
	finalizedBlocks := sim.GetFinalizedBlocks()
	require.Greater(finalizedBlocks, int32(10), "Should finalize with Byzantine minority")
	
	// Check for slashing events
	slashEvents := sim.GetSlashingEvents()
	require.Greater(slashEvents, int32(0), "Should detect Byzantine behavior")
}

// TestQuantumAttackSimulation tests behavior under quantum attack
func TestQuantumAttackSimulation(t *testing.T) {
	require := require.New(t)
	
	// Create network
	sim := createNetworkSimulation(t, 21, 15)
	defer sim.Stop()
	
	// Simulate quantum attacker on node 0
	sim.SimulateQuantumAttack(0)
	
	// Run simulation
	sim.Run(10 * time.Second)
	
	// Attacker should be slashed
	slashEvents := sim.validators[0].slashingDetected
	require.Greater(slashEvents, int32(0), "Quantum attacker should be slashed")
	
	// Network should continue
	finalizedBlocks := sim.GetFinalizedBlocks()
	require.Greater(finalizedBlocks, int32(5), "Network should continue despite attack")
}

// TestHighLoadScenario tests consensus under high transaction load
func TestHighLoadScenario(t *testing.T) {
	require := require.New(t)
	
	// Create network
	sim := createNetworkSimulation(t, 21, 15)
	defer sim.Stop()
	
	// Generate high load
	go func() {
		for i := 0; i < 100; i++ {
			sim.InjectTransactions(1000) // 1000 txs per block
			time.Sleep(500 * time.Millisecond)
		}
	}()
	
	// Run simulation
	start := time.Now()
	sim.Run(30 * time.Second)
	duration := time.Since(start)
	
	// Check performance
	finalizedBlocks := sim.GetFinalizedBlocks()
	blocksPerSecond := float64(finalizedBlocks) / duration.Seconds()
	
	require.Greater(blocksPerSecond, 1.0, "Should maintain >1 block/sec under load")
	
	// Check finality time
	avgFinality := sim.GetAverageFinalityTime()
	require.Less(avgFinality, 1*time.Second, "Should maintain sub-second finality")
}

// TestValidatorChurn tests consensus with validators joining/leaving
func TestValidatorChurn(t *testing.T) {
	require := require.New(t)
	
	// Start with 15 validators
	sim := createNetworkSimulation(t, 15, 11)
	defer sim.Stop()
	
	// Run initially
	sim.Run(5 * time.Second)
	initialBlocks := sim.GetFinalizedBlocks()
	
	// Add 6 new validators
	for i := 0; i < 6; i++ {
		sim.AddValidator()
	}
	
	// Run with new validators
	sim.Run(5 * time.Second)
	
	// Remove 3 validators
	for i := 0; i < 3; i++ {
		sim.RemoveValidator(i)
	}
	
	// Run after removal
	sim.Run(5 * time.Second)
	
	// Should continue finalizing throughout
	finalBlocks := sim.GetFinalizedBlocks()
	require.Greater(finalBlocks, initialBlocks+int32(5), "Should handle validator churn")
}

// TestNetworkLatencyVariation tests with varying network conditions
func TestNetworkLatencyVariation(t *testing.T) {
	require := require.New(t)
	
	// Create network
	sim := createNetworkSimulation(t, 21, 15)
	defer sim.Stop()
	
	// Test different latency scenarios
	scenarios := []struct {
		name       string
		latency    time.Duration
		packetLoss float64
		minBlocks  int32
	}{
		{"Low latency", 10 * time.Millisecond, 0.0, 20},
		{"Medium latency", 50 * time.Millisecond, 0.01, 15},
		{"High latency", 200 * time.Millisecond, 0.05, 10},
		{"Extreme conditions", 500 * time.Millisecond, 0.1, 5},
	}
	
	for _, scenario := range scenarios {
		t.Run(scenario.name, func(t *testing.T) {
			sim.SetNetworkConditions(scenario.latency, scenario.packetLoss)
			
			start := time.Now()
			sim.Run(20 * time.Second)
			
			blocks := sim.GetFinalizedBlocksSince(start)
			require.GreaterOrEqual(blocks, scenario.minBlocks, 
				"Should finalize minimum blocks in %s", scenario.name)
		})
	}
}

// Helper functions for network simulation

func createNetworkSimulation(t *testing.T, numValidators, threshold int) *NetworkSimulator {
	validators := make([]*ValidatorNode, numValidators)
	network := &SimulatedNetwork{
		latency:    50 * time.Millisecond,
		packetLoss: 0.01,
		messages:   make(chan Message, 10000),
	}
	
	// Create validators
	for i := 0; i < numValidators; i++ {
		node := createValidatorNode(t, i, threshold)
		validators[i] = node
	}
	
	network.nodes = validators
	
	sim := &NetworkSimulator{
		validators:  validators,
		network:     network,
		attackers:   make(map[int]bool),
		partitioned: make(map[int]int),
	}
	
	// Start network
	go network.RouteMessages()
	
	// Start validators
	for _, v := range validators {
		go v.Run()
	}
	
	return sim
}

func createValidatorNode(t *testing.T, id int, threshold int) *ValidatorNode {
	nodeID := ids.GenerateTestNodeID()
	blsSK, _, _ := bls.KeyGen()
	
	seed := make([]byte, 32)
	seed[0] = byte(id)
	mock := &MockRingtail{}
	rtSK, rtPK, _ := mock.KeyGen(seed)
	
	cfg := Config{
		ChainID:       ids.GenerateTestID(),
		QPubKey:       rtPK,
		QThreshold:    threshold,
		QuasarTimeout: 100 * time.Millisecond,
	}
	
	engine, err := NewEngine(nodeID, blsSK, rtSK, cfg)
	require.NoError(t, err)
	
	ctx, cancel := context.WithCancel(context.Background())
	
	return &ValidatorNode{
		id:     id,
		nodeID: nodeID,
		engine: engine,
		inbox:  make(chan Message, 1000),
		outbox: make(chan Message, 1000),
		ctx:    ctx,
		cancel: cancel,
	}
}

func (v *ValidatorNode) Run() {
	ticker := time.NewTicker(500 * time.Millisecond)
	defer ticker.Stop()
	
	height := uint64(1)
	
	for {
		select {
		case <-v.ctx.Done():
			return
			
		case msg := <-v.inbox:
			// Process incoming message
			switch msg.Type {
			case "RTShare":
				v.engine.OnRTShare(msg.Height, msg.Data)
			}
			
		case <-ticker.C:
			// Propose new block
			parentID := ids.GenerateTestID()
			txs := generateTransactions(100)
			
			err := v.engine.Propose(v.ctx, height, parentID, txs)
			if err == nil {
				atomic.AddInt32(&v.blocksProposed, 1)
				height++
			}
		}
	}
}

func (sim *NetworkSimulator) Run(duration time.Duration) {
	time.Sleep(duration)
}

func (sim *NetworkSimulator) Stop() {
	for _, v := range sim.validators {
		v.cancel()
	}
}

func (sim *NetworkSimulator) GetFinalizedBlocks() int32 {
	var total int32
	for _, v := range sim.validators {
		total += atomic.LoadInt32(&v.blocksFinalized)
	}
	return total / int32(len(sim.validators))
}

func (sim *NetworkSimulator) GetSlashingEvents() int32 {
	var total int32
	for _, v := range sim.validators {
		total += atomic.LoadInt32(&v.slashingDetected)
	}
	return total
}

func (sim *NetworkSimulator) CreatePartition(group1, group2 []int) {
	for _, i := range group1 {
		sim.partitioned[i] = 1
	}
	for _, i := range group2 {
		sim.partitioned[i] = 2
	}
}

func (sim *NetworkSimulator) HealPartition() {
	sim.partitioned = make(map[int]int)
}

func (sim *NetworkSimulator) MakeByzantine(nodeIndex int) {
	sim.attackers[nodeIndex] = true
}

func (sim *NetworkSimulator) SimulateQuantumAttack(nodeIndex int) {
	// Attacker can forge BLS but not Ringtail
	sim.attackers[nodeIndex] = true
}

func (sim *NetworkSimulator) InjectTransactions(count int) {
	// Inject transactions to random validator
	idx := int(time.Now().UnixNano()) % len(sim.validators)
	// In real implementation, would send transactions
}

func (sim *NetworkSimulator) AddValidator() {
	id := len(sim.validators)
	node := createValidatorNode(nil, id, 15)
	sim.validators = append(sim.validators, node)
	go node.Run()
}

func (sim *NetworkSimulator) RemoveValidator(index int) {
	if index < len(sim.validators) {
		sim.validators[index].cancel()
	}
}

func (sim *NetworkSimulator) SetNetworkConditions(latency time.Duration, loss float64) {
	sim.network.latency = latency
	sim.network.packetLoss = loss
}

func (sim *NetworkSimulator) GetFinalizedBlocksSince(since time.Time) int32 {
	// Simplified - in real implementation would track timestamps
	return sim.GetFinalizedBlocks()
}

func (sim *NetworkSimulator) GetAverageFinalityTime() time.Duration {
	// Simplified - returns expected finality
	return 300 * time.Millisecond
}

func (n *SimulatedNetwork) RouteMessages() {
	for msg := range n.messages {
		// Simulate network delay
		time.Sleep(n.latency)
		
		// Simulate packet loss
		if rand.Float64() < n.packetLoss {
			continue
		}
		
		// Deliver to recipient
		if msg.To < len(n.nodes) {
			select {
			case n.nodes[msg.To].inbox <- msg:
			default:
				// Drop if inbox full
			}
		}
	}
}