// Copyright (C) 2025, Lux Industries Inc. All rights reserved.
// See the file LICENSE for licensing terms.

package testing

import (
	"context"
	"fmt"
	"math/rand"
	"sync"
	"time"

	"github.com/luxfi/consensus/config"
	"github.com/luxfi/consensus/poll"
	"github.com/luxfi/ids"
	"github.com/luxfi/log"
)

// NetworkSimulator simulates a consensus network
type NetworkSimulator struct {
	mu sync.RWMutex
	
	// Configuration
	params       config.Parameters
	nodes        map[ids.NodeID]*SimulatedNode
	byzantineIDs map[ids.NodeID]bool
	
	// Network conditions
	latency      time.Duration
	packetLoss   float64
	partitioned  bool
	
	// Metrics
	totalQueries uint64
	startTime    time.Time
	
	logger log.Logger
}

// NewNetworkSimulator creates a new network simulator
func NewNetworkSimulator(params config.Parameters) *NetworkSimulator {
	return &NetworkSimulator{
		params:       params,
		nodes:        make(map[ids.NodeID]*SimulatedNode),
		byzantineIDs: make(map[ids.NodeID]bool),
		latency:      50 * time.Millisecond,
		logger:       log.NewLogger("simulator"),
		startTime:    time.Now(),
	}
}

// AddNode adds a node to the simulation
func (ns *NetworkSimulator) AddNode(nodeID ids.NodeID, byzantine bool) (*SimulatedNode, error) {
	ns.mu.Lock()
	defer ns.mu.Unlock()
	
	if _, exists := ns.nodes[nodeID]; exists {
		return nil, fmt.Errorf("node %s already exists", nodeID)
	}
	
	node := &SimulatedNode{
		nodeID:     nodeID,
		simulator:  ns,
		byzantine:  byzantine,
		inbox:      make(chan Message, 1000),
		preference: ids.GenerateTestID(),
		logger:     ns.logger,
	}
	
	// Initialize focus
	node.focus = focus.NewFocus(ns.params, node.preference)
	
	ns.nodes[nodeID] = node
	if byzantine {
		ns.byzantineIDs[nodeID] = true
	}
	
	return node, nil
}

// RemoveNode removes a node from the simulation
func (ns *NetworkSimulator) RemoveNode(nodeID ids.NodeID) error {
	ns.mu.Lock()
	defer ns.mu.Unlock()
	
	node, exists := ns.nodes[nodeID]
	if !exists {
		return fmt.Errorf("node %s not found", nodeID)
	}
	
	close(node.inbox)
	delete(ns.nodes, nodeID)
	delete(ns.byzantineIDs, nodeID)
	
	return nil
}

// SetLatency sets the network latency
func (ns *NetworkSimulator) SetLatency(latency time.Duration) {
	ns.mu.Lock()
	defer ns.mu.Unlock()
	ns.latency = latency
}

// SetPacketLoss sets the packet loss rate (0.0 to 1.0)
func (ns *NetworkSimulator) SetPacketLoss(loss float64) {
	ns.mu.Lock()
	defer ns.mu.Unlock()
	ns.packetLoss = loss
}

// Partition creates a network partition
func (ns *NetworkSimulator) Partition(group1, group2 []ids.NodeID) {
	ns.mu.Lock()
	defer ns.mu.Unlock()
	ns.partitioned = true
	// TODO: Implement partition logic
}

// Heal removes the network partition
func (ns *NetworkSimulator) Heal() {
	ns.mu.Lock()
	defer ns.mu.Unlock()
	ns.partitioned = false
}

// Start starts the simulation
func (ns *NetworkSimulator) Start(ctx context.Context) error {
	ns.mu.RLock()
	nodes := make([]*SimulatedNode, 0, len(ns.nodes))
	for _, node := range ns.nodes {
		nodes = append(nodes, node)
	}
	ns.mu.RUnlock()
	
	// Start all nodes
	var wg sync.WaitGroup
	for _, node := range nodes {
		wg.Add(1)
		go func(n *SimulatedNode) {
			defer wg.Done()
			n.Start(ctx)
		}(node)
	}
	
	// Wait for context or all nodes to finish
	go func() {
		wg.Wait()
	}()
	
	<-ctx.Done()
	return ctx.Err()
}

// GetNode returns a specific node
func (ns *NetworkSimulator) GetNode(nodeID ids.NodeID) (*SimulatedNode, bool) {
	ns.mu.RLock()
	defer ns.mu.RUnlock()
	node, exists := ns.nodes[nodeID]
	return node, exists
}

// GetNodes returns all nodes
func (ns *NetworkSimulator) GetNodes() map[ids.NodeID]*SimulatedNode {
	ns.mu.RLock()
	defer ns.mu.RUnlock()
	
	nodes := make(map[ids.NodeID]*SimulatedNode)
	for id, node := range ns.nodes {
		nodes[id] = node
	}
	return nodes
}

// GetMetrics returns simulation metrics
func (ns *NetworkSimulator) GetMetrics() SimulationMetrics {
	ns.mu.RLock()
	defer ns.mu.RUnlock()
	
	byzantineCount := 0
	for _, byzantine := range ns.byzantineIDs {
		if byzantine {
			byzantineCount++
		}
	}
	
	return SimulationMetrics{
		TotalNodes:      len(ns.nodes),
		ByzantineNodes:  byzantineCount,
		TotalQueries:    ns.totalQueries,
		SimulationTime:  time.Since(ns.startTime),
		NetworkLatency:  ns.latency,
		PacketLossRate:  ns.packetLoss,
		IsPartitioned:   ns.partitioned,
	}
}

// SimulatedNode represents a node in the simulation
type SimulatedNode struct {
	mu sync.RWMutex
	
	nodeID     ids.NodeID
	simulator  *NetworkSimulator
	byzantine  bool
	inbox      chan Message
	focus   *focus.Focus
	preference ids.ID
	finalized  bool
	
	logger log.Logger
}

// Start starts the simulated node
func (n *SimulatedNode) Start(ctx context.Context) {
	ticker := time.NewTicker(n.simulator.params.MinRoundInterval)
	defer ticker.Stop()
	
	for {
		select {
		case <-ctx.Done():
			return
			
		case <-ticker.C:
			n.runConsensusRound(ctx)
			
		case msg := <-n.inbox:
			n.handleMessage(msg)
		}
	}
}

// runConsensusRound runs a single consensus round
func (n *SimulatedNode) runConsensusRound(ctx context.Context) {
	// Sample k-1 peers
	peers := n.samplePeers(n.simulator.params.K - 1)
	
	// Send query to each peer
	for _, peerID := range peers {
		msg := Message{
			Type:      QueryMessage,
			From:      n.nodeID,
			To:        peerID,
			Timestamp: time.Now(),
			Payload:   n.preference.Bytes(),
		}
		
		n.simulator.send(msg)
	}
	
	// Increment query counter
	n.simulator.mu.Lock()
	n.simulator.totalQueries++
	n.simulator.mu.Unlock()
}

// handleMessage handles an incoming message
func (n *SimulatedNode) handleMessage(msg Message) {
	switch msg.Type {
	case QueryMessage:
		// Respond with current preference
		response := Message{
			Type:      ResponseMessage,
			From:      n.nodeID,
			To:        msg.From,
			Timestamp: time.Now(),
			Payload:   n.preference.Bytes(),
		}
		
		// Byzantine nodes might lie
		if n.byzantine && rand.Float64() < 0.3 {
			response.Payload = ids.GenerateTestID().Bytes()
		}
		
		n.simulator.send(response)
		
	case ResponseMessage:
		// Process response
		// TODO: Update focus with response
	}
}

// samplePeers returns a random sample of k peers
func (n *SimulatedNode) samplePeers(k int) []ids.NodeID {
	n.simulator.mu.RLock()
	defer n.simulator.mu.RUnlock()
	
	// Get all other nodes
	peers := make([]ids.NodeID, 0, len(n.simulator.nodes)-1)
	for nodeID := range n.simulator.nodes {
		if nodeID != n.nodeID {
			peers = append(peers, nodeID)
		}
	}
	
	// Sample k peers
	if k > len(peers) {
		return peers
	}
	
	// Simple random sampling
	sampled := make([]ids.NodeID, k)
	perm := rand.Perm(len(peers))
	for i := 0; i < k; i++ {
		sampled[i] = peers[perm[i]]
	}
	
	return sampled
}

// send sends a message with simulated network conditions
func (ns *NetworkSimulator) send(msg Message) {
	ns.mu.RLock()
	latency := ns.latency
	packetLoss := ns.packetLoss
	toNode, exists := ns.nodes[msg.To]
	ns.mu.RUnlock()
	
	if !exists {
		return
	}
	
	// Simulate packet loss
	if rand.Float64() < packetLoss {
		return
	}
	
	// Simulate latency
	go func() {
		time.Sleep(latency)
		select {
		case toNode.inbox <- msg:
		default:
			// Inbox full, drop message
		}
	}()
}

// MessageType represents the type of consensus message
type MessageType int

const (
	QueryMessage MessageType = iota
	ResponseMessage
)

// Message represents a consensus message
type Message struct {
	Type      MessageType
	From      ids.NodeID
	To        ids.NodeID
	Timestamp time.Time
	Payload   []byte
}

// SimulationMetrics contains simulation metrics
type SimulationMetrics struct {
	TotalNodes      int
	ByzantineNodes  int
	TotalQueries    uint64
	SimulationTime  time.Duration
	NetworkLatency  time.Duration
	PacketLossRate  float64
	IsPartitioned   bool
}

// ConsensusTester provides utilities for testing consensus algorithms
type ConsensusTester struct {
	params config.Parameters
	logger log.Logger
}

// NewConsensusTester creates a new consensus tester
func NewConsensusTester(params config.Parameters) *ConsensusTester {
	return &ConsensusTester{
		params: params,
		logger: log.NewLogger("tester"),
	}
}

// TestByzantineResilience tests Byzantine resilience
func (t *ConsensusTester) TestByzantineResilience(nodeCount int, byzantineRatio float64) (bool, error) {
	byzantineCount := int(float64(nodeCount) * byzantineRatio)
	
	// Create simulator
	sim := NewNetworkSimulator(t.params)
	
	// Add honest nodes
	for i := 0; i < nodeCount-byzantineCount; i++ {
		nodeID := ids.GenerateTestNodeID()
		_, err := sim.AddNode(nodeID, false)
		if err != nil {
			return false, err
		}
	}
	
	// Add Byzantine nodes
	for i := 0; i < byzantineCount; i++ {
		nodeID := ids.GenerateTestNodeID()
		_, err := sim.AddNode(nodeID, true)
		if err != nil {
			return false, err
		}
	}
	
	// Run simulation
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()
	
	err := sim.Start(ctx)
	if err != nil && err != context.DeadlineExceeded {
		return false, err
	}
	
	// Check if honest nodes reached consensus
	nodes := sim.GetNodes()
	preferences := make(map[ids.ID]int)
	
	for _, node := range nodes {
		if !node.byzantine && node.focus.Finalized() {
			pref := node.focus.Preference()
			preferences[pref]++
		}
	}
	
	// Check if majority agreed
	for _, count := range preferences {
		if count > (nodeCount-byzantineCount)/2 {
			return true, nil
		}
	}
	
	return false, nil
}