// Copyright (C) 2019-2025, Lux Industries Inc. All rights reserved.
// See the file LICENSE for licensing terms.

package testing

import (
	"context"
	"testing"
	"time"

	"github.com/luxfi/consensus/config"
	"github.com/luxfi/consensus/snowball"
	"github.com/luxfi/ids"
)

// BenchmarkInMemoryNetwork benchmarks in-memory network operations
func BenchmarkInMemoryNetwork(b *testing.B) {
	seed := int64(12345)
	network := NewNetwork(seed)
	
	// Create nodes
	nodeCount := 100
	nodes := make([]*Node, nodeCount)
	for i := 0; i < nodeCount; i++ {
		nodeID := ids.GenerateTestNodeID()
		node := network.AddNode(nodeID, 10*time.Millisecond)
		nodes[i] = node
	}
	
	b.ResetTimer()
	b.ReportAllocs()
	
	ctx := context.Background()
	for i := 0; i < b.N; i++ {
		// Send messages between random nodes
		from := nodes[i%nodeCount]
		to := nodes[(i+1)%nodeCount]
		msg := &Message{
			From:      from.ID,
			To:        to.ID,
			Timestamp: time.Now(),
			Content:   []byte("benchmark message"),
		}
		network.SendAsync(ctx, msg)
	}
}

// BenchmarkNetworkPartition benchmarks network with partitions
func BenchmarkNetworkPartition(b *testing.B) {
	seed := int64(12345)
	network := NewNetwork(seed)
	
	// Create two groups of nodes
	group1 := make([]ids.NodeID, 50)
	group2 := make([]ids.NodeID, 50)
	
	for i := 0; i < 50; i++ {
		id1 := ids.GenerateTestNodeID()
		id2 := ids.GenerateTestNodeID()
		group1[i] = id1
		group2[i] = id2
		network.AddNode(id1, 5*time.Millisecond)
		network.AddNode(id2, 5*time.Millisecond)
	}
	
	// Create partition
	network.Partition(group1, group2)
	
	b.ResetTimer()
	b.ReportAllocs()
	
	ctx := context.Background()
	for i := 0; i < b.N; i++ {
		// Try to send across partition
		msg := &Message{
			From:      group1[i%50],
			To:        group2[i%50],
			Timestamp: time.Now(),
			Content:   []byte("cross-partition message"),
		}
		network.SendAsync(ctx, msg)
	}
}

// BenchmarkHighTPSSimulation benchmarks high-TPS consensus simulation
func BenchmarkHighTPSSimulation(b *testing.B) {
	seed := int64(12345)
	network := NewNetwork(seed)
	params := config.HighTPSParams
	
	// Create 5 validators
	validators := make([]*Node, 5)
	for i := 0; i < 5; i++ {
		nodeID := ids.GenerateTestNodeID()
		node := network.AddNode(nodeID, 1*time.Millisecond) // Low latency
		validators[i] = node
	}
	
	// Create consensus instances
	initialChoice := ids.GenerateTestID()
	snowballs := make([]*snowball.Snowball, len(validators))
	for i, node := range validators {
		sb := snowball.NewSnowball(params, initialChoice)
		snowballs[i] = sb
		
		// Add choices
		for j := 0; j < params.BatchSize; j++ {
			sb.Add(ids.GenerateTestID())
		}
		
		// Store in node's state
		node.State["snowball"] = sb
	}
	
	b.ResetTimer()
	b.ReportAllocs()
	
	ctx := context.Background()
	for i := 0; i < b.N; i++ {
		// Simulate consensus round
		for j, node := range validators {
			sb := node.State["snowball"].(*snowball.Snowball)
			
			// Sample k-1 peers
			peers := make([]ids.NodeID, 0, params.K-1)
			for k, peer := range validators {
				if k != j && len(peers) < params.K-1 {
					peers = append(peers, peer.ID)
				}
			}
			
			// Collect votes
			votes := make(map[ids.ID]int)
			votes[sb.Preference()] = len(peers)
			
			// Record poll
			sb.RecordPoll(votes)
		}
	}
}

// BenchmarkMessageLatency benchmarks message delivery with latency
func BenchmarkMessageLatency(b *testing.B) {
	seed := int64(12345)
	network := NewNetwork(seed)
	
	// Create nodes with varying latencies
	nodeCount := 10
	nodes := make([]*Node, nodeCount)
	latencies := []time.Duration{
		1 * time.Millisecond,
		5 * time.Millisecond,
		10 * time.Millisecond,
		50 * time.Millisecond,
		100 * time.Millisecond,
	}
	
	for i := 0; i < nodeCount; i++ {
		nodeID := ids.GenerateTestNodeID()
		latency := latencies[i%len(latencies)]
		node := network.AddNode(nodeID, latency)
		nodes[i] = node
	}
	
	// Set specific link latencies
	for i := 0; i < nodeCount; i++ {
		for j := i + 1; j < nodeCount; j++ {
			network.SetLatency(nodes[i].ID, nodes[j].ID, i*j)
		}
	}
	
	b.ResetTimer()
	b.ReportAllocs()
	
	ctx := context.Background()
	network.Start(ctx)
	defer network.Stop()
	
	for i := 0; i < b.N; i++ {
		from := nodes[i%nodeCount]
		to := nodes[(i+7)%nodeCount] // Non-adjacent node
		msg := &Message{
			From:      from.ID,
			To:        to.ID,
			Timestamp: time.Now(),
			Content:   []byte("latency test"),
		}
		network.SendAsync(ctx, msg)
	}
}

// BenchmarkDropRate benchmarks network with message drops
func BenchmarkDropRate(b *testing.B) {
	seed := int64(12345)
	network := NewNetwork(seed)
	
	// Create nodes
	nodeCount := 20
	nodes := make([]*Node, nodeCount)
	for i := 0; i < nodeCount; i++ {
		nodeID := ids.GenerateTestNodeID()
		node := network.AddNode(nodeID, 5*time.Millisecond)
		nodes[i] = node
	}
	
	// Set 10% drop rate
	network.SetDropRate(0.1)
	
	b.ResetTimer()
	b.ReportAllocs()
	
	ctx := context.Background()
	network.Start(ctx)
	defer network.Stop()
	
	sent := 0
	delivered := 0
	
	for i := 0; i < b.N; i++ {
		from := nodes[i%nodeCount]
		to := nodes[(i+1)%nodeCount]
		msg := &Message{
			From:      from.ID,
			To:        to.ID,
			Timestamp: time.Now(),
			Content:   []byte("drop test"),
		}
		
		sent++
		if err := network.SendAsync(ctx, msg); err == nil {
			delivered++
		}
	}
	
	b.Logf("Drop rate: %.2f%% (sent: %d, delivered: %d)", 
		float64(sent-delivered)/float64(sent)*100, sent, delivered)
}