
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>consensus: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/luxfi/consensus/acceptor.go (0.0%)</option>
				
				<option value="file1">github.com/luxfi/consensus/choices/choices.go (0.0%)</option>
				
				<option value="file2">github.com/luxfi/consensus/cmd/bench/main.go (0.0%)</option>
				
				<option value="file3">github.com/luxfi/consensus/cmd/checker/main.go (0.0%)</option>
				
				<option value="file4">github.com/luxfi/consensus/cmd/consensus/main.go (0.0%)</option>
				
				<option value="file5">github.com/luxfi/consensus/cmd/params/main.go (0.0%)</option>
				
				<option value="file6">github.com/luxfi/consensus/cmd/server/main.go (0.0%)</option>
				
				<option value="file7">github.com/luxfi/consensus/cmd/sim/main.go (0.0%)</option>
				
				<option value="file8">github.com/luxfi/consensus/codec/codec.go (0.0%)</option>
				
				<option value="file9">github.com/luxfi/consensus/config/config.go (89.5%)</option>
				
				<option value="file10">github.com/luxfi/consensus/config/constants.go (80.0%)</option>
				
				<option value="file11">github.com/luxfi/consensus/config/fpc.go (0.0%)</option>
				
				<option value="file12">github.com/luxfi/consensus/config/wave.go (100.0%)</option>
				
				<option value="file13">github.com/luxfi/consensus/consensus.go (46.2%)</option>
				
				<option value="file14">github.com/luxfi/consensus/consensustest/context.go (0.0%)</option>
				
				<option value="file15">github.com/luxfi/consensus/consensustest/test.go (0.0%)</option>
				
				<option value="file16">github.com/luxfi/consensus/context.go (0.0%)</option>
				
				<option value="file17">github.com/luxfi/consensus/context/context.go (0.0%)</option>
				
				<option value="file18">github.com/luxfi/consensus/core.go (0.0%)</option>
				
				<option value="file19">github.com/luxfi/consensus/core/app_error.go (0.0%)</option>
				
				<option value="file20">github.com/luxfi/consensus/core/appsender/fake_sender.go (0.0%)</option>
				
				<option value="file21">github.com/luxfi/consensus/core/coremock/mock_app_sender.go (0.0%)</option>
				
				<option value="file22">github.com/luxfi/consensus/core/dag/flare.go (0.0%)</option>
				
				<option value="file23">github.com/luxfi/consensus/core/dag/horizon.go (0.0%)</option>
				
				<option value="file24">github.com/luxfi/consensus/core/health.go (0.0%)</option>
				
				<option value="file25">github.com/luxfi/consensus/core/status.go (0.0%)</option>
				
				<option value="file26">github.com/luxfi/consensus/core/test_decidable.go (0.0%)</option>
				
				<option value="file27">github.com/luxfi/consensus/core/tracker/tracker.go (0.0%)</option>
				
				<option value="file28">github.com/luxfi/consensus/core/vm.go (0.0%)</option>
				
				<option value="file29">github.com/luxfi/consensus/engine/chain/block/blockmock/mock.go (0.0%)</option>
				
				<option value="file30">github.com/luxfi/consensus/engine/chain/block/blocktest/test.go (0.0%)</option>
				
				<option value="file31">github.com/luxfi/consensus/engine/chain/bootstrap/bootstrapper.go (0.0%)</option>
				
				<option value="file32">github.com/luxfi/consensus/engine/chain/chainmock/mock.go (0.0%)</option>
				
				<option value="file33">github.com/luxfi/consensus/engine/chain/chaintest/test.go (0.0%)</option>
				
				<option value="file34">github.com/luxfi/consensus/engine/chain/chaintest/test_blocks.go (0.0%)</option>
				
				<option value="file35">github.com/luxfi/consensus/engine/chain/engine.go (100.0%)</option>
				
				<option value="file36">github.com/luxfi/consensus/engine/chain/getter/getter.go (0.0%)</option>
				
				<option value="file37">github.com/luxfi/consensus/engine/core/cgo_available.go (0.0%)</option>
				
				<option value="file38">github.com/luxfi/consensus/engine/core/cgo_consensus.go (95.8%)</option>
				
				<option value="file39">github.com/luxfi/consensus/engine/core/cgo_consensus_factory.go (0.0%)</option>
				
				<option value="file40">github.com/luxfi/consensus/engine/core/common/errors.go (0.0%)</option>
				
				<option value="file41">github.com/luxfi/consensus/engine/core/common/message.go (0.0%)</option>
				
				<option value="file42">github.com/luxfi/consensus/engine/core/coremock/mock.go (0.0%)</option>
				
				<option value="file43">github.com/luxfi/consensus/engine/core/tracker/tracker.go (0.0%)</option>
				
				<option value="file44">github.com/luxfi/consensus/engine/dag/bootstrap/bootstrapper.go (0.0%)</option>
				
				<option value="file45">github.com/luxfi/consensus/engine/dag/bootstrap/queue/queue.go (0.0%)</option>
				
				<option value="file46">github.com/luxfi/consensus/engine/dag/engine.go (66.7%)</option>
				
				<option value="file47">github.com/luxfi/consensus/engine/dag/getter/getter.go (0.0%)</option>
				
				<option value="file48">github.com/luxfi/consensus/engine/dag/state/state.go (0.0%)</option>
				
				<option value="file49">github.com/luxfi/consensus/engine/enginetest/test.go (0.0%)</option>
				
				<option value="file50">github.com/luxfi/consensus/engine/pq/bootstrap/bootstrapper.go (0.0%)</option>
				
				<option value="file51">github.com/luxfi/consensus/engine/pq/consensus.go (53.1%)</option>
				
				<option value="file52">github.com/luxfi/consensus/engine/pq/engine.go (12.5%)</option>
				
				<option value="file53">github.com/luxfi/consensus/examples/node_integration.go (0.0%)</option>
				
				<option value="file54">github.com/luxfi/consensus/flare/flare.go (95.7%)</option>
				
				<option value="file55">github.com/luxfi/consensus/focus/focus.go (91.1%)</option>
				
				<option value="file56">github.com/luxfi/consensus/horizon/horizon.go (88.9%)</option>
				
				<option value="file57">github.com/luxfi/consensus/networking/router/routermock/mock.go (0.0%)</option>
				
				<option value="file58">github.com/luxfi/consensus/networking/router/stub.go (0.0%)</option>
				
				<option value="file59">github.com/luxfi/consensus/networking/sender/sendertest/test.go (0.0%)</option>
				
				<option value="file60">github.com/luxfi/consensus/networking/timeout/manager.go (0.0%)</option>
				
				<option value="file61">github.com/luxfi/consensus/networking/tracker/new.go (0.0%)</option>
				
				<option value="file62">github.com/luxfi/consensus/photon/emitter.go (0.0%)</option>
				
				<option value="file63">github.com/luxfi/consensus/photon/luminance.go (0.0%)</option>
				
				<option value="file64">github.com/luxfi/consensus/prism/cut.go (0.0%)</option>
				
				<option value="file65">github.com/luxfi/consensus/prism/prism.go (0.0%)</option>
				
				<option value="file66">github.com/luxfi/consensus/protocol/field/field.go (0.0%)</option>
				
				<option value="file67">github.com/luxfi/consensus/protocol/field/nebula.go (100.0%)</option>
				
				<option value="file68">github.com/luxfi/consensus/protocol/flare/flare.go (95.7%)</option>
				
				<option value="file69">github.com/luxfi/consensus/protocol/focus/focus.go (91.1%)</option>
				
				<option value="file70">github.com/luxfi/consensus/protocol/horizon/horizon.go (88.9%)</option>
				
				<option value="file71">github.com/luxfi/consensus/protocol/nebula/nebula.go (0.0%)</option>
				
				<option value="file72">github.com/luxfi/consensus/protocol/nova/nova.go (0.0%)</option>
				
				<option value="file73">github.com/luxfi/consensus/protocol/quasar/hybrid_consensus.go (0.0%)</option>
				
				<option value="file74">github.com/luxfi/consensus/protocol/quasar/quasar.go (48.6%)</option>
				
				<option value="file75">github.com/luxfi/consensus/protocol/quasar/ringtail.go (49.1%)</option>
				
				<option value="file76">github.com/luxfi/consensus/protocol/quasar/verkle_witness.go (0.0%)</option>
				
				<option value="file77">github.com/luxfi/consensus/protocol/ray/nova.go (0.0%)</option>
				
				<option value="file78">github.com/luxfi/consensus/protocol/ray/ray.go (0.0%)</option>
				
				<option value="file79">github.com/luxfi/consensus/qzmq/messages.go (41.5%)</option>
				
				<option value="file80">github.com/luxfi/consensus/qzmq/qzmq.go (47.1%)</option>
				
				<option value="file81">github.com/luxfi/consensus/snow/consensus/snowman/snowman.go (0.0%)</option>
				
				<option value="file82">github.com/luxfi/consensus/uptime/locked_calculator.go (0.0%)</option>
				
				<option value="file83">github.com/luxfi/consensus/uptime/noop.go (0.0%)</option>
				
				<option value="file84">github.com/luxfi/consensus/uptime/uptimemock/mock.go (0.0%)</option>
				
				<option value="file85">github.com/luxfi/consensus/utils/bag/bag.go (0.0%)</option>
				
				<option value="file86">github.com/luxfi/consensus/utils/set/set.go (0.0%)</option>
				
				<option value="file87">github.com/luxfi/consensus/utils/timer/mockable/clock.go (0.0%)</option>
				
				<option value="file88">github.com/luxfi/consensus/utils/utils.go (0.0%)</option>
				
				<option value="file89">github.com/luxfi/consensus/validators/new.go (0.0%)</option>
				
				<option value="file90">github.com/luxfi/consensus/validators/validators.go (0.0%)</option>
				
				<option value="file91">github.com/luxfi/consensus/validators/validatorsmock/mock.go (0.0%)</option>
				
				<option value="file92">github.com/luxfi/consensus/validators/validatorstest/test.go (0.0%)</option>
				
				<option value="file93">github.com/luxfi/consensus/version/version.go (0.0%)</option>
				
				<option value="file94">github.com/luxfi/consensus/wave/state.go (0.0%)</option>
				
				<option value="file95">github.com/luxfi/consensus/wave/wave.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package consensus provides the Lux consensus implementation.
package consensus

import (
        "context"

        "github.com/luxfi/ids"
)

// Acceptor interface for consensus acceptors
type Acceptor interface {
        // Accept processes an accepted item
        Accept(ctx context.Context, containerID ids.ID, container []byte) error
}

// BasicAcceptor is a simple implementation of the Acceptor interface
type BasicAcceptor struct {
        accepted map[ids.ID][]byte
}

// NewBasicAcceptor creates a new basic acceptor
func NewBasicAcceptor() *BasicAcceptor <span class="cov0" title="0">{
        return &amp;BasicAcceptor{
                accepted: make(map[ids.ID][]byte),
        }
}</span>

// Accept marks an item as accepted
func (a *BasicAcceptor) Accept(ctx context.Context, containerID ids.ID, container []byte) error <span class="cov0" title="0">{
        a.accepted[containerID] = container
        return nil
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package choices

// Status represents the status of a block
type Status uint8

const (
        Unknown Status = iota
        Processing
        Rejected
        Accepted
)

// String returns string representation
func (s Status) String() string <span class="cov0" title="0">{
        switch s </span>{
        case Unknown:<span class="cov0" title="0">
                return "Unknown"</span>
        case Processing:<span class="cov0" title="0">
                return "Processing"</span>
        case Rejected:<span class="cov0" title="0">
                return "Rejected"</span>
        case Accepted:<span class="cov0" title="0">
                return "Accepted"</span>
        default:<span class="cov0" title="0">
                return "Invalid"</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package main provides the bench CLI tool for consensus benchmarking
package main

import (
        "context"
        "flag"
        "fmt"
        "os"
        "time"

        "github.com/luxfi/consensus/config"
        "github.com/luxfi/consensus/engine/chain"
        "github.com/luxfi/consensus/engine/dag"
        "github.com/luxfi/consensus/engine/pq"
        "github.com/luxfi/ids"
)

func main() <span class="cov0" title="0">{
        var (
                engine   = flag.String("engine", "all", "Engine to benchmark (chain, dag, pq, all)")
                network  = flag.String("network", "local", "Network configuration (mainnet, testnet, local)")
                duration = flag.Duration("duration", 10*time.Second, "Benchmark duration")
                blocks   = flag.Int("blocks", 1000, "Number of blocks to process")
                parallel = flag.Int("parallel", 1, "Number of parallel workers")
                useZMQ   = flag.Bool("zmq", false, "Use ZMQ transport (if available)")
                verbose  = flag.Bool("verbose", false, "Verbose output")
                help     = flag.Bool("help", false, "Show help message")
        )
        flag.Parse()

        if *help </span><span class="cov0" title="0">{
                printHelp()
                os.Exit(0)
        }</span>

        // Get network configuration
        <span class="cov0" title="0">params := getNetworkParams(*network)

        ctx, cancel := context.WithTimeout(context.Background(), *duration)
        defer cancel()

        fmt.Printf("Benchmarking %s engine(s) with %s configuration\n", *engine, *network)
        fmt.Printf("Duration: %s, Blocks: %d, Parallel: %d, ZMQ: %v\n\n", *duration, *blocks, *parallel, *useZMQ)

        switch *engine </span>{
        case "chain":<span class="cov0" title="0">
                benchmarkChain(ctx, params, *blocks, *parallel, *verbose)</span>
        case "dag":<span class="cov0" title="0">
                benchmarkDAG(ctx, params, *blocks, *parallel, *verbose)</span>
        case "pq":<span class="cov0" title="0">
                benchmarkPQ(ctx, params, *blocks, *parallel, *verbose)</span>
        case "all":<span class="cov0" title="0">
                benchmarkChain(ctx, params, *blocks, *parallel, *verbose)
                fmt.Println()
                benchmarkDAG(ctx, params, *blocks, *parallel, *verbose)
                fmt.Println()
                benchmarkPQ(ctx, params, *blocks, *parallel, *verbose)</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Unknown engine: %s\n", *engine)
                os.Exit(1)</span>
        }
}

func printHelp() <span class="cov0" title="0">{
        fmt.Println("Consensus Benchmark Tool")
        fmt.Println("\nUsage: bench [options]")
        fmt.Println("\nOptions:")
        fmt.Println("  -engine string    Engine to benchmark (default: all)")
        fmt.Println("                    Options: chain, dag, pq, all")
        fmt.Println("  -network string   Network configuration (default: local)")
        fmt.Println("                    Options: mainnet, testnet, local")
        fmt.Println("  -duration time    Benchmark duration (default: 10s)")
        fmt.Println("  -blocks int       Number of blocks to process (default: 1000)")
        fmt.Println("  -parallel int     Number of parallel workers (default: 1)")
        fmt.Println("  -zmq              Use ZMQ transport if available")
        fmt.Println("  -verbose          Verbose output")
        fmt.Println("  -help             Show this help message")
        fmt.Println("\nExamples:")
        fmt.Println("  bench                                  # Benchmark all engines")
        fmt.Println("  bench -engine chain -blocks 5000       # Benchmark chain engine with 5000 blocks")
        fmt.Println("  bench -engine dag -parallel 4          # Benchmark DAG with 4 workers")
        fmt.Println("  bench -network mainnet -duration 30s   # Use mainnet config for 30s")
}</span>

func getNetworkParams(network string) config.Parameters <span class="cov0" title="0">{
        switch network </span>{
        case "mainnet":<span class="cov0" title="0">
                return config.MainnetParams()</span>
        case "testnet":<span class="cov0" title="0">
                return config.TestnetParams()</span>
        case "local":<span class="cov0" title="0">
                return config.LocalParams()</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Unknown network: %s, using local\n", network)
                return config.LocalParams()</span>
        }
}

func benchmarkChain(ctx context.Context, params config.Parameters, blocks int, parallel int, verbose bool) <span class="cov0" title="0">{
        fmt.Println("=== Chain Engine Benchmark ===")
        engine := chain.New()

        start := time.Now()
        if err := engine.Start(ctx, 1); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to start chain engine: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">processed := 0
        errors := 0

        for i := 0; i &lt; blocks &amp;&amp; ctx.Err() == nil; i++ </span><span class="cov0" title="0">{
                blockID := ids.GenerateTestID()
                err := engine.GetBlock(ctx, ids.EmptyNodeID, 0, blockID)
                if err != nil </span><span class="cov0" title="0">{
                        errors++
                        if verbose </span><span class="cov0" title="0">{
                                fmt.Printf("Error processing block %d: %v\n", i, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        processed++
                }</span>

                <span class="cov0" title="0">if verbose &amp;&amp; i%100 == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Processed %d blocks...\n", i)
                }</span>
        }

        <span class="cov0" title="0">elapsed := time.Since(start)
        tps := float64(processed) / elapsed.Seconds()

        fmt.Printf("Results:\n")
        fmt.Printf("  Processed: %d blocks\n", processed)
        fmt.Printf("  Errors:    %d\n", errors)
        fmt.Printf("  Time:      %s\n", elapsed)
        fmt.Printf("  TPS:       %.2f blocks/sec\n", tps)

        _ = engine.Stop(ctx)</span>
}

func benchmarkDAG(ctx context.Context, params config.Parameters, blocks int, parallel int, verbose bool) <span class="cov0" title="0">{
        fmt.Println("=== DAG Engine Benchmark ===")
        engine := dag.New()

        start := time.Now()
        if err := engine.Start(ctx, 1); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to start DAG engine: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">processed := 0
        errors := 0

        for i := 0; i &lt; blocks &amp;&amp; ctx.Err() == nil; i++ </span><span class="cov0" title="0">{
                vertexID := ids.GenerateTestID()
                _, err := engine.GetVtx(ctx, vertexID)
                if err != nil </span><span class="cov0" title="0">{
                        errors++
                        if verbose </span><span class="cov0" title="0">{
                                fmt.Printf("Error processing vertex %d: %v\n", i, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        processed++
                }</span>

                <span class="cov0" title="0">if verbose &amp;&amp; i%100 == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Processed %d vertices...\n", i)
                }</span>
        }

        <span class="cov0" title="0">elapsed := time.Since(start)
        tps := float64(processed) / elapsed.Seconds()

        fmt.Printf("Results:\n")
        fmt.Printf("  Processed: %d vertices\n", processed)
        fmt.Printf("  Errors:    %d\n", errors)
        fmt.Printf("  Time:      %s\n", elapsed)
        fmt.Printf("  TPS:       %.2f vertices/sec\n", tps)

        _ = engine.Shutdown(ctx)</span>
}

func benchmarkPQ(ctx context.Context, params config.Parameters, blocks int, parallel int, verbose bool) <span class="cov0" title="0">{
        fmt.Println("=== Post-Quantum Engine Benchmark ===")
        engine := pq.New()

        start := time.Now()
        if err := engine.Start(ctx, 1); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to start PQ engine: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">processed := 0
        errors := 0
        proofSizes := []int{}

        for i := 0; i &lt; blocks &amp;&amp; ctx.Err() == nil; i++ </span><span class="cov0" title="0">{
                blockID := ids.GenerateTestID()
                proof, err := engine.GenerateQuantumProof(ctx, blockID)
                if err != nil </span><span class="cov0" title="0">{
                        errors++
                        if verbose </span><span class="cov0" title="0">{
                                fmt.Printf("Error generating proof %d: %v\n", i, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        processed++
                        proofSizes = append(proofSizes, len(proof))
                }</span>

                <span class="cov0" title="0">if verbose &amp;&amp; i%100 == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("Generated %d proofs...\n", i)
                }</span>
        }

        <span class="cov0" title="0">elapsed := time.Since(start)
        tps := float64(processed) / elapsed.Seconds()

        // Calculate average proof size
        avgProofSize := 0
        if len(proofSizes) &gt; 0 </span><span class="cov0" title="0">{
                sum := 0
                for _, size := range proofSizes </span><span class="cov0" title="0">{
                        sum += size
                }</span>
                <span class="cov0" title="0">avgProofSize = sum / len(proofSizes)</span>
        }

        <span class="cov0" title="0">fmt.Printf("Results:\n")
        fmt.Printf("  Generated: %d proofs\n", processed)
        fmt.Printf("  Errors:    %d\n", errors)
        fmt.Printf("  Time:      %s\n", elapsed)
        fmt.Printf("  TPS:       %.2f proofs/sec\n", tps)
        fmt.Printf("  Avg Proof: %d bytes\n", avgProofSize)

        _ = engine.Stop(ctx)</span>
}

func init() {<span class="cov0" title="0">
        // As of Go 1.20, rand.Seed is deprecated - random seeding is automatic
        // No manual seeding required for better randomness
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package main provides the checker CLI tool for consensus health checking
package main

import (
        "context"
        "flag"
        "fmt"
        "os"
        "time"

        "github.com/luxfi/consensus"
        "github.com/luxfi/consensus/config"
)

func main() <span class="cov0" title="0">{
        var (
                engine  = flag.String("engine", "all", "Engine to check (chain, dag, pq, all)")
                timeout = flag.Duration("timeout", 5*time.Second, "Health check timeout")
                verbose = flag.Bool("verbose", false, "Verbose output")
                help    = flag.Bool("help", false, "Show help message")
        )
        flag.Parse()

        if *help </span><span class="cov0" title="0">{
                printHelp()
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), *timeout)
        defer cancel()

        exitCode := 0

        switch *engine </span>{
        case "chain":<span class="cov0" title="0">
                if !checkEngine(ctx, "chain", consensus.NewChainEngine(), *verbose) </span><span class="cov0" title="0">{
                        exitCode = 1
                }</span>
        case "dag":<span class="cov0" title="0">
                if !checkEngine(ctx, "dag", consensus.NewDAGEngine(), *verbose) </span><span class="cov0" title="0">{
                        exitCode = 1
                }</span>
        case "pq":<span class="cov0" title="0">
                if !checkEngine(ctx, "pq", consensus.NewPQEngine(), *verbose) </span><span class="cov0" title="0">{
                        exitCode = 1
                }</span>
        case "all":<span class="cov0" title="0">
                if !checkEngine(ctx, "chain", consensus.NewChainEngine(), *verbose) </span><span class="cov0" title="0">{
                        exitCode = 1
                }</span>
                <span class="cov0" title="0">if !checkEngine(ctx, "dag", consensus.NewDAGEngine(), *verbose) </span><span class="cov0" title="0">{
                        exitCode = 1
                }</span>
                <span class="cov0" title="0">if !checkEngine(ctx, "pq", consensus.NewPQEngine(), *verbose) </span><span class="cov0" title="0">{
                        exitCode = 1
                }</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Unknown engine: %s\n", *engine)
                os.Exit(1)</span>
        }

        // Check configurations
        <span class="cov0" title="0">if !checkConfigurations(*verbose) </span><span class="cov0" title="0">{
                exitCode = 1
        }</span>

        <span class="cov0" title="0">if exitCode == 0 </span><span class="cov0" title="0">{
                fmt.Println("\n✓ All health checks passed")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("\n✗ Some health checks failed")
        }</span>

        <span class="cov0" title="0">os.Exit(exitCode)</span>
}

func printHelp() <span class="cov0" title="0">{
        fmt.Println("Consensus Health Checker")
        fmt.Println("\nUsage: checker [options]")
        fmt.Println("\nOptions:")
        fmt.Println("  -engine string    Engine to check (default: all)")
        fmt.Println("                    Options: chain, dag, pq, all")
        fmt.Println("  -timeout duration Health check timeout (default: 5s)")
        fmt.Println("  -verbose          Verbose output")
        fmt.Println("  -help             Show this help message")
        fmt.Println("\nExamples:")
        fmt.Println("  checker                    # Check all engines")
        fmt.Println("  checker -engine chain      # Check only chain engine")
        fmt.Println("  checker -verbose           # Verbose output for debugging")
}</span>

func checkEngine(ctx context.Context, name string, engine consensus.Engine, verbose bool) bool <span class="cov0" title="0">{
        fmt.Printf("Checking %s engine... ", name)

        // Start engine
        if err := engine.Start(ctx, 1); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("✗ Failed to start: %v\n", err)
                return false
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = engine.Stop(ctx) }</span>()

        // Check bootstrapped
        <span class="cov0" title="0">if !engine.IsBootstrapped() </span><span class="cov0" title="0">{
                fmt.Println("✗ Not bootstrapped")
                return false
        }</span>

        // Perform health check
        <span class="cov0" title="0">health, err := engine.HealthCheck(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("✗ Health check failed: %v\n", err)
                return false
        }</span>

        <span class="cov0" title="0">fmt.Println("✓")

        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("  Health data: %+v\n", health)
        }</span>

        <span class="cov0" title="0">return true</span>
}

func checkConfigurations(verbose bool) bool <span class="cov0" title="0">{
        fmt.Println("\nChecking configurations...")

        configs := map[string]config.Parameters{
                "mainnet": config.MainnetParams(),
                "testnet": config.TestnetParams(),
                "local":   config.LocalParams(),
                "xchain":  config.XChainParams(),
        }

        allValid := true

        for name, cfg := range configs </span><span class="cov0" title="0">{
                fmt.Printf("  %s: ", name)
                if err := cfg.Valid(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("✗ %v\n", err)
                        allValid = false
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("✓")
                        if verbose </span><span class="cov0" title="0">{
                                fmt.Printf("    K=%d, Alpha=%.2f, Beta=%d, BlockTime=%s\n",
                                        cfg.K, cfg.Alpha, cfg.Beta, cfg.BlockTime)
                        }</span>
                }
        }

        <span class="cov0" title="0">return allValid</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Package main provides the main consensus CLI tool
package main

import (
        "context"
        "flag"
        "fmt"
        "os"
        "time"

        "github.com/luxfi/consensus"
        "github.com/luxfi/consensus/config"
)

func main() <span class="cov0" title="0">{
        var (
                engine  = flag.String("engine", "chain", "Consensus engine (chain, dag, pq)")
                network = flag.String("network", "mainnet", "Network configuration")
                action  = flag.String("action", "info", "Action to perform (info, test, health)")
                help    = flag.Bool("help", false, "Show help message")
        )
        flag.Parse()

        if *help </span><span class="cov0" title="0">{
                printHelp()
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">switch *action </span>{
        case "info":<span class="cov0" title="0">
                showInfo(*engine, *network)</span>
        case "test":<span class="cov0" title="0">
                testEngine(*engine, *network)</span>
        case "health":<span class="cov0" title="0">
                checkHealth(*engine)</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Unknown action: %s\n", *action)
                os.Exit(1)</span>
        }
}

func printHelp() <span class="cov0" title="0">{
        fmt.Println("Lux Consensus CLI")
        fmt.Println("\nUsage: consensus [options]")
        fmt.Println("\nOptions:")
        fmt.Println("  -engine string   Consensus engine (default: chain)")
        fmt.Println("                   Options: chain, dag, pq")
        fmt.Println("  -network string  Network configuration (default: mainnet)")
        fmt.Println("                   Options: mainnet, testnet, local")
        fmt.Println("  -action string   Action to perform (default: info)")
        fmt.Println("                   Options: info, test, health")
        fmt.Println("  -help            Show this help message")
        fmt.Println("\nExamples:")
        fmt.Println("  consensus                          # Show chain engine info")
        fmt.Println("  consensus -engine dag -action test # Test DAG engine")
        fmt.Println("  consensus -action health           # Check engine health")
}</span>

func showInfo(engineType, network string) <span class="cov0" title="0">{
        fmt.Printf("=== Consensus Engine Info ===\n")
        fmt.Printf("Engine:  %s\n", engineType)
        fmt.Printf("Network: %s\n", network)

        params := getNetworkParams(network)
        fmt.Printf("\nParameters:\n")
        fmt.Printf("  K (sample size):        %d\n", params.K)
        fmt.Printf("  Alpha (quorum):         %.2f\n", params.Alpha)
        fmt.Printf("  Beta (decision rounds): %d\n", params.Beta)
        fmt.Printf("  Block Time:             %s\n", params.BlockTime)
        fmt.Printf("  Round Timeout:          %s\n", params.RoundTO)

        switch engineType </span>{
        case "chain":<span class="cov0" title="0">
                fmt.Println("\nChain Engine:")
                fmt.Println("  - Linear blockchain consensus")
                fmt.Println("  - Sequential block processing")
                fmt.Println("  - Optimized for ordered transactions")</span>
        case "dag":<span class="cov0" title="0">
                fmt.Println("\nDAG Engine:")
                fmt.Println("  - Directed Acyclic Graph consensus")
                fmt.Println("  - Parallel transaction processing")
                fmt.Println("  - High throughput optimization")</span>
        case "pq":<span class="cov0" title="0">
                fmt.Println("\nPost-Quantum Engine:")
                fmt.Println("  - Quantum-resistant cryptography")
                fmt.Println("  - ML-DSA-65 algorithm")
                fmt.Println("  - Future-proof security")</span>
        }
}

func testEngine(engineType, network string) <span class="cov0" title="0">{
        fmt.Printf("Testing %s engine with %s configuration...\n", engineType, network)

        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        var engine consensus.Engine
        switch engineType </span>{
        case "chain":<span class="cov0" title="0">
                engine = consensus.NewChainEngine()</span>
        case "dag":<span class="cov0" title="0">
                engine = consensus.NewDAGEngine()</span>
        case "pq":<span class="cov0" title="0">
                engine = consensus.NewPQEngine()</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Unknown engine: %s\n", engineType)
                os.Exit(1)</span>
        }

        // Start engine
        <span class="cov0" title="0">if err := engine.Start(ctx, 1); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("✗ Failed to start: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = engine.Stop(ctx) }</span>()

        // Check bootstrapped
        <span class="cov0" title="0">if !engine.IsBootstrapped() </span><span class="cov0" title="0">{
                fmt.Println("✗ Not bootstrapped")
                os.Exit(1)
        }</span>

        // Health check
        <span class="cov0" title="0">health, err := engine.HealthCheck(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("✗ Health check failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("✓ Engine test passed")
        fmt.Printf("  Health: %+v\n", health)</span>
}

func checkHealth(engineType string) <span class="cov0" title="0">{
        fmt.Printf("Checking %s engine health...\n", engineType)

        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
        defer cancel()

        var engine consensus.Engine
        switch engineType </span>{
        case "chain":<span class="cov0" title="0">
                engine = consensus.NewChainEngine()</span>
        case "dag":<span class="cov0" title="0">
                engine = consensus.NewDAGEngine()</span>
        case "pq":<span class="cov0" title="0">
                engine = consensus.NewPQEngine()</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Unknown engine: %s\n", engineType)
                os.Exit(1)</span>
        }

        // Start engine
        <span class="cov0" title="0">if err := engine.Start(ctx, 1); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("✗ Failed to start: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{ _ = engine.Stop(ctx) }</span>()

        // Health check
        <span class="cov0" title="0">health, err := engine.HealthCheck(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("✗ Health check failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("✓ Healthy")
        fmt.Printf("  Status: %+v\n", health)</span>
}

func getNetworkParams(network string) config.Parameters <span class="cov0" title="0">{
        switch network </span>{
        case "mainnet":<span class="cov0" title="0">
                return config.MainnetParams()</span>
        case "testnet":<span class="cov0" title="0">
                return config.TestnetParams()</span>
        case "local":<span class="cov0" title="0">
                return config.LocalParams()</span>
        default:<span class="cov0" title="0">
                return config.MainnetParams()</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package main provides the params CLI tool for viewing consensus network parameters
package main

import (
        "flag"
        "fmt"
        "os"

        "github.com/luxfi/consensus/config"
)

func main() <span class="cov0" title="0">{
        var (
                network = flag.String("network", "mainnet", "Network to show parameters for (mainnet, testnet, local, xchain)")
                json    = flag.Bool("json", false, "Output in JSON format")
                help    = flag.Bool("help", false, "Show help message")
        )
        flag.Parse()

        if *help </span><span class="cov0" title="0">{
                printHelp()
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">var params config.Parameters
        switch *network </span>{
        case "mainnet":<span class="cov0" title="0">
                params = config.MainnetParams()</span>
        case "testnet":<span class="cov0" title="0">
                params = config.TestnetParams()</span>
        case "local":<span class="cov0" title="0">
                params = config.LocalParams()</span>
        case "xchain":<span class="cov0" title="0">
                params = config.XChainParams()</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Unknown network: %s\n", *network)
                fmt.Fprintln(os.Stderr, "Valid networks: mainnet, testnet, local, xchain")
                os.Exit(1)</span>
        }

        <span class="cov0" title="0">if *json </span><span class="cov0" title="0">{
                printJSON(params)
        }</span> else<span class="cov0" title="0"> {
                printTable(params)
        }</span>
}

func printHelp() <span class="cov0" title="0">{
        fmt.Println("Consensus Parameters Viewer")
        fmt.Println("\nUsage: params [options]")
        fmt.Println("\nOptions:")
        fmt.Println("  -network string   Network to show parameters for (default: mainnet)")
        fmt.Println("                    Options: mainnet, testnet, local, xchain")
        fmt.Println("  -json            Output in JSON format")
        fmt.Println("  -help            Show this help message")
        fmt.Println("\nExamples:")
        fmt.Println("  params                      # Show mainnet parameters")
        fmt.Println("  params -network testnet     # Show testnet parameters")
        fmt.Println("  params -network local -json # Show local parameters in JSON")
}</span>

func printTable(p config.Parameters) <span class="cov0" title="0">{
        fmt.Printf("K (sample size):        %d\n", p.K)
        fmt.Printf("Alpha (quorum):         %.2f\n", p.Alpha)
        fmt.Printf("Beta (decision rounds): %d\n", p.Beta)
        fmt.Printf("Block Time:             %s\n", p.BlockTime)
        fmt.Printf("Round Timeout:          %s\n", p.RoundTO)

        if p.AlphaPreference &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Alpha Preference:       %d\n", p.AlphaPreference)
        }</span>
        <span class="cov0" title="0">if p.AlphaConfidence &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Alpha Confidence:       %d\n", p.AlphaConfidence)
        }</span>
        <span class="cov0" title="0">if p.BetaVirtuous &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Beta Virtuous:          %d\n", p.BetaVirtuous)
        }</span>
        <span class="cov0" title="0">if p.BetaRogue &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Beta Rogue:             %d\n", p.BetaRogue)
        }</span>
        <span class="cov0" title="0">if p.ConcurrentPolls &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Concurrent Polls:       %d\n", p.ConcurrentPolls)
        }</span>
        <span class="cov0" title="0">if p.ConcurrentRepolls &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Concurrent Repolls:     %d\n", p.ConcurrentRepolls)
        }</span>
        <span class="cov0" title="0">if p.OptimalProcessing &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Optimal Processing:     %d\n", p.OptimalProcessing)
        }</span>
        <span class="cov0" title="0">if p.MaxOutstandingItems &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Max Outstanding Items:  %d\n", p.MaxOutstandingItems)
        }</span>
        <span class="cov0" title="0">if p.Parents &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Parents:                %d\n", p.Parents)
        }</span>
        <span class="cov0" title="0">if p.BatchSize &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("Batch Size:             %d\n", p.BatchSize)
        }</span>
}

func printJSON(p config.Parameters) <span class="cov0" title="0">{
        fmt.Printf(`{
  "k": %d,
  "alpha": %.2f,
  "beta": %d,
  "blockTime": "%s",
  "roundTimeout": "%s",
  "alphaPreference": %d,
  "alphaConfidence": %d,
  "betaVirtuous": %d,
  "betaRogue": %d,
  "concurrentPolls": %d,
  "concurrentRepolls": %d,
  "optimalProcessing": %d,
  "maxOutstandingItems": %d,
  "parents": %d,
  "batchSize": %d
}
`, p.K, p.Alpha, p.Beta, p.BlockTime, p.RoundTO,
                p.AlphaPreference, p.AlphaConfidence, p.BetaVirtuous, p.BetaRogue,
                p.ConcurrentPolls, p.ConcurrentRepolls, p.OptimalProcessing,
                p.MaxOutstandingItems, p.Parents, p.BatchSize)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "context"
        "encoding/json"
        "flag"
        "log"
        "net/http"
        "time"

        "github.com/luxfi/consensus"
        "github.com/luxfi/consensus/config"
        "github.com/luxfi/ids"
)

type ConsensusServer struct {
        engine consensus.Engine
        config config.Parameters
}

type StatusResponse struct {
        Engine     string            `json:"engine"`
        Network    string            `json:"network"`
        Healthy    bool              `json:"healthy"`
        Parameters config.Parameters `json:"parameters"`
        Health     interface{}       `json:"health,omitempty"`
}

type TestRequest struct {
        Rounds int `json:"rounds"`
        Nodes  int `json:"nodes"`
}

type TestResponse struct {
        Success    bool    `json:"success"`
        Rounds     int     `json:"rounds"`
        Accepts    int     `json:"accepts"`
        Rejects    int     `json:"rejects"`
        AvgTime    string  `json:"avg_time"`
        Confidence float64 `json:"confidence"`
}

func (s *ConsensusServer) handleStatus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        ctx := context.Background()

        health := make(map[string]interface{})
        health["healthy"] = true

        if adapter, ok := s.engine.(interface {
                HealthCheck(context.Context) (interface{}, error)
        }); ok </span><span class="cov0" title="0">{
                if h, err := adapter.HealthCheck(ctx); err == nil </span><span class="cov0" title="0">{
                        if healthMap, ok := h.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                health = healthMap
                        }</span> else<span class="cov0" title="0"> if healthBoolMap, ok := h.(map[string]bool); ok </span><span class="cov0" title="0">{
                                for k, v := range healthBoolMap </span><span class="cov0" title="0">{
                                        health[k] = v
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">healthy := true
        if val, ok := health["healthy"].(bool); ok </span><span class="cov0" title="0">{
                healthy = val
        }</span>

        <span class="cov0" title="0">resp := StatusResponse{
                Engine:     "chain",
                Network:    "mainnet",
                Healthy:    healthy,
                Parameters: s.config,
                Health:     health,
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error encoding response: %v", err)
        }</span>
}

func (s *ConsensusServer) handleTest(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req TestRequest
        if r.Method == http.MethodPost </span><span class="cov0" title="0">{
                if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                        http.Error(w, err.Error(), http.StatusBadRequest)
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                req.Rounds = 10
                req.Nodes = 5
        }</span>

        // Run simple consensus test
        <span class="cov0" title="0">accepts := 0
        rejects := 0
        totalTime := time.Duration(0)

        for i := 0; i &lt; req.Rounds; i++ </span><span class="cov0" title="0">{
                start := time.Now()

                // Simulate consensus round
                blockID := ids.GenerateTestID()

                // Simulate votes from nodes
                acceptVotes := 0
                for j := 0; j &lt; req.Nodes; j++ </span><span class="cov0" title="0">{
                        if j &lt; (req.Nodes * 8 / 10) </span><span class="cov0" title="0">{ // 80% vote to accept
                                acceptVotes++
                        }</span>
                }

                <span class="cov0" title="0">if float64(acceptVotes)/float64(req.Nodes) &gt;= s.config.Alpha </span><span class="cov0" title="0">{
                        accepts++
                }</span> else<span class="cov0" title="0"> {
                        rejects++
                }</span>

                <span class="cov0" title="0">totalTime += time.Since(start)

                // Log the vote
                log.Printf("Round %d: BlockID=%s, Accept=%d/%d\n", i+1, blockID, acceptVotes, req.Nodes)</span>
        }

        <span class="cov0" title="0">avgTime := totalTime / time.Duration(req.Rounds)
        confidence := float64(accepts) / float64(req.Rounds)

        resp := TestResponse{
                Success:    true,
                Rounds:     req.Rounds,
                Accepts:    accepts,
                Rejects:    rejects,
                AvgTime:    avgTime.String(),
                Confidence: confidence * 100,
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error encoding response: %v", err)
        }</span>
}

func (s *ConsensusServer) handleConsensus(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                BlockID string         `json:"block_id"`
                Votes   map[string]int `json:"votes"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusBadRequest)
                return
        }</span>

        // Process consensus
        <span class="cov0" title="0">blockID, err := ids.FromString(req.BlockID)
        if err != nil </span><span class="cov0" title="0">{
                blockID = ids.GenerateTestID()
        }</span>

        // Calculate if consensus reached
        <span class="cov0" title="0">totalVotes := 0
        acceptVotes := 0
        for _, count := range req.Votes </span><span class="cov0" title="0">{
                totalVotes += count
                if count &gt; 0 </span><span class="cov0" title="0">{
                        acceptVotes += count
                }</span>
        }

        <span class="cov0" title="0">finalized := false
        if totalVotes &gt; 0 </span><span class="cov0" title="0">{
                confidence := float64(acceptVotes) / float64(totalVotes)
                finalized = confidence &gt;= s.config.Alpha
        }</span>

        <span class="cov0" title="0">resp := map[string]interface{}{
                "block_id":   blockID.String(),
                "finalized":  finalized,
                "votes":      req.Votes,
                "confidence": float64(acceptVotes) / float64(totalVotes) * 100,
                "alpha":      s.config.Alpha * 100,
        }

        w.Header().Set("Content-Type", "application/json")
        if err := json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                log.Printf("Error encoding response: %v", err)
        }</span>
}

func main() <span class="cov0" title="0">{
        var (
                port    = flag.String("port", "8080", "Server port")
                network = flag.String("network", "mainnet", "Network configuration")
        )
        flag.Parse()

        // Initialize consensus engine
        engine := consensus.NewChainEngine()
        var params config.Parameters

        switch *network </span>{
        case "testnet":<span class="cov0" title="0">
                params = config.TestnetParams()</span>
        case "local":<span class="cov0" title="0">
                params = config.LocalParams()</span>
        default:<span class="cov0" title="0">
                params = config.MainnetParams()</span>
        }

        <span class="cov0" title="0">server := &amp;ConsensusServer{
                engine: engine,
                config: params,
        }

        // Set up routes
        mux := http.NewServeMux()
        mux.HandleFunc("/status", server.handleStatus)
        mux.HandleFunc("/test", server.handleTest)
        mux.HandleFunc("/consensus", server.handleConsensus)
        mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                if _, err := w.Write([]byte("OK")); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error writing response: %v", err)
                }</span>
        })

        <span class="cov0" title="0">log.Printf("Starting consensus server on port %s with %s config", *port, *network)
        log.Printf("Endpoints:")
        log.Printf("  GET  /status    - Get engine status")
        log.Printf("  GET  /health    - Health check")
        log.Printf("  GET  /test      - Run consensus test")
        log.Printf("  POST /test      - Run consensus test with custom params")
        log.Printf("  POST /consensus - Process consensus round")

        // Create server with timeouts to avoid G114 warning
        srv := &amp;http.Server{
                Addr:         ":" + *port,
                Handler:      mux,
                ReadTimeout:  15 * time.Second,
                WriteTimeout: 15 * time.Second,
                IdleTimeout:  60 * time.Second,
        }

        if err := srv.ListenAndServe(); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Package main provides the sim CLI tool for consensus simulation
package main

import (
        "context"
        "flag"
        "fmt"
        "math/rand"
        "os"
        "time"

        "github.com/luxfi/consensus/config"
)

func main() <span class="cov0" title="0">{
        var (
                nodes   = flag.Int("nodes", 100, "Number of nodes in the network")
                rounds  = flag.Int("rounds", 10, "Number of consensus rounds to simulate")
                network = flag.String("network", "mainnet", "Network configuration (mainnet, testnet, local)")
                failure = flag.Float64("failure", 0.1, "Node failure rate (0.0-1.0)")
                latency = flag.Duration("latency", 50*time.Millisecond, "Network latency")
                verbose = flag.Bool("verbose", false, "Verbose output")
                help    = flag.Bool("help", false, "Show help message")
        )
        flag.Parse()

        if *help </span><span class="cov0" title="0">{
                printHelp()
                os.Exit(0)
        }</span>

        <span class="cov0" title="0">if *failure &lt; 0 || *failure &gt; 1 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Failure rate must be between 0.0 and 1.0\n")
                os.Exit(1)
        }</span>

        // Get network configuration
        <span class="cov0" title="0">params := getNetworkParams(*network)

        fmt.Println("=== Consensus Simulation ===")
        fmt.Printf("Network:    %s\n", *network)
        fmt.Printf("Nodes:      %d\n", *nodes)
        fmt.Printf("Rounds:     %d\n", *rounds)
        fmt.Printf("Failure:    %.1f%%\n", *failure*100)
        fmt.Printf("Latency:    %s\n", *latency)
        fmt.Printf("Parameters: K=%d, Alpha=%.2f, Beta=%d\n\n", params.K, params.Alpha, params.Beta)

        // Run simulation
        results := runSimulation(*nodes, *rounds, params, *failure, *latency, *verbose)

        // Print results
        printResults(results, params)</span>
}

func printHelp() <span class="cov0" title="0">{
        fmt.Println("Consensus Simulator")
        fmt.Println("\nUsage: sim [options]")
        fmt.Println("\nOptions:")
        fmt.Println("  -nodes int        Number of nodes in the network (default: 100)")
        fmt.Println("  -rounds int       Number of consensus rounds (default: 10)")
        fmt.Println("  -network string   Network configuration (default: mainnet)")
        fmt.Println("                    Options: mainnet, testnet, local")
        fmt.Println("  -failure float    Node failure rate 0.0-1.0 (default: 0.1)")
        fmt.Println("  -latency duration Network latency (default: 50ms)")
        fmt.Println("  -verbose          Verbose output")
        fmt.Println("  -help             Show this help message")
        fmt.Println("\nExamples:")
        fmt.Println("  sim                                  # Run default simulation")
        fmt.Println("  sim -nodes 1000 -rounds 100          # Large scale simulation")
        fmt.Println("  sim -failure 0.3 -latency 200ms      # High failure, slow network")
        fmt.Println("  sim -network testnet -verbose        # Testnet config with details")
}</span>

func getNetworkParams(network string) config.Parameters <span class="cov0" title="0">{
        switch network </span>{
        case "mainnet":<span class="cov0" title="0">
                return config.MainnetParams()</span>
        case "testnet":<span class="cov0" title="0">
                return config.TestnetParams()</span>
        case "local":<span class="cov0" title="0">
                return config.LocalParams()</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Unknown network: %s, using mainnet\n", network)
                return config.MainnetParams()</span>
        }
}

type SimulationResult struct {
        Round           int
        VotesReceived   int
        Confidence      float64
        Decision        string
        TimeToConsensus time.Duration
        FailedNodes     int
}

func runSimulation(nodes int, rounds int, params config.Parameters, failureRate float64, latency time.Duration, verbose bool) []SimulationResult <span class="cov0" title="0">{
        results := make([]SimulationResult, 0, rounds)
        ctx := context.Background()

        for round := 1; round &lt;= rounds; round++ </span><span class="cov0" title="0">{
                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("Round %d: ", round)
                }</span>

                <span class="cov0" title="0">start := time.Now()
                result := simulateRound(ctx, nodes, params, failureRate, latency)
                result.Round = round
                result.TimeToConsensus = time.Since(start)

                if verbose </span><span class="cov0" title="0">{
                        fmt.Printf("%s (confidence: %.2f%%, time: %s)\n",
                                result.Decision, result.Confidence*100, result.TimeToConsensus)
                }</span>

                <span class="cov0" title="0">results = append(results, result)

                // Simulate inter-round delay
                time.Sleep(latency)</span>
        }

        <span class="cov0" title="0">return results</span>
}

func simulateRound(ctx context.Context, nodes int, params config.Parameters, failureRate float64, latency time.Duration) SimulationResult <span class="cov0" title="0">{
        // Calculate failed nodes
        failedNodes := int(float64(nodes) * failureRate)
        activeNodes := nodes - failedNodes

        // Sample K nodes randomly
        k := params.K
        if k &gt; activeNodes </span><span class="cov0" title="0">{
                k = activeNodes
        }</span>

        // Simulate voting
        <span class="cov0" title="0">votes := 0
        for i := 0; i &lt; k; i++ </span><span class="cov0" title="0">{
                // Simulate network latency
                time.Sleep(latency / time.Duration(k))

                // Random vote with Byzantine behavior (simulation only, not security-critical)
                if rand.Float64() &gt; 0.2 </span><span class="cov0" title="0">{ // 80% honest nodes //nolint:gosec // simulation randomness
                        votes++
                }</span>
        }

        // Calculate confidence
        <span class="cov0" title="0">confidence := float64(votes) / float64(k)

        // Determine decision based on alpha threshold
        decision := "REJECT"
        if confidence &gt;= params.Alpha </span><span class="cov0" title="0">{
                decision = "ACCEPT"
        }</span>

        <span class="cov0" title="0">return SimulationResult{
                VotesReceived: votes,
                Confidence:    confidence,
                Decision:      decision,
                FailedNodes:   failedNodes,
        }</span>
}

func printResults(results []SimulationResult, params config.Parameters) <span class="cov0" title="0">{
        fmt.Println("=== Simulation Results ===")

        accepts := 0
        rejects := 0
        totalTime := time.Duration(0)
        totalConfidence := 0.0

        for _, r := range results </span><span class="cov0" title="0">{
                if r.Decision == "ACCEPT" </span><span class="cov0" title="0">{
                        accepts++
                }</span> else<span class="cov0" title="0"> {
                        rejects++
                }</span>
                <span class="cov0" title="0">totalTime += r.TimeToConsensus
                totalConfidence += r.Confidence</span>
        }

        <span class="cov0" title="0">fmt.Printf("\nConsensus Decisions:\n")
        fmt.Printf("  Accepts:  %d (%.1f%%)\n", accepts, float64(accepts)/float64(len(results))*100)
        fmt.Printf("  Rejects:  %d (%.1f%%)\n", rejects, float64(rejects)/float64(len(results))*100)

        fmt.Printf("\nPerformance:\n")
        fmt.Printf("  Avg Time:       %s\n", totalTime/time.Duration(len(results)))
        fmt.Printf("  Avg Confidence: %.2f%%\n", totalConfidence/float64(len(results))*100)
        fmt.Printf("  Alpha Required: %.2f%%\n", params.Alpha*100)

        // Calculate finality probability
        finalityProb := calculateFinalityProbability(params.Alpha, params.Beta, totalConfidence/float64(len(results)))
        fmt.Printf("\nFinality:\n")
        fmt.Printf("  Probability:    %.4f%%\n", finalityProb*100)
        fmt.Printf("  Beta Rounds:    %d\n", params.Beta)</span>
}

func calculateFinalityProbability(alpha float64, beta uint32, avgConfidence float64) float64 <span class="cov0" title="0">{
        // Simplified finality calculation
        // P(finality) = confidence^beta
        prob := 1.0
        for i := uint32(0); i &lt; beta; i++ </span><span class="cov0" title="0">{
                prob *= avgConfidence
        }</span>
        <span class="cov0" title="0">return prob</span>
}

func init() {<span class="cov0" title="0">
        // As of Go 1.20, rand.Seed is deprecated - random seeding is automatic
        // No manual seeding required for better randomness
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">// Package codec provides encoding/decoding for consensus types
package codec

import (
        "encoding/json"
        "fmt"
)

// CodecVersion represents the codec version
type CodecVersion uint16

const (
        // CurrentVersion is the current codec version
        CurrentVersion CodecVersion = 0
)

// Codec provides marshaling/unmarshaling
var Codec = &amp;JSONCodec{}

// JSONCodec implements JSON encoding/decoding
type JSONCodec struct{}

// Marshal marshals an object to bytes
func (c *JSONCodec) Marshal(version CodecVersion, v interface{}) ([]byte, error) <span class="cov0" title="0">{
        if version != CurrentVersion </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported codec version: %d", version)
        }</span>
        <span class="cov0" title="0">return json.Marshal(v)</span>
}

// Unmarshal unmarshals bytes to an object
func (c *JSONCodec) Unmarshal(data []byte, v interface{}) (CodecVersion, error) <span class="cov0" title="0">{
        err := json.Unmarshal(data, v)
        return CurrentVersion, err
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package config

import (
        "errors"
        "time"
)

// Error variables for parameter validation
var (
        ErrParametersInvalid  = errors.New("invalid consensus parameters")
        ErrInvalidK           = errors.New("k must be &gt;= 1")
        ErrInvalidAlpha       = errors.New("alpha must be between 0.5 and 1.0")
        ErrInvalidBeta        = errors.New("beta must be &gt;= 1")
        ErrBlockTimeTooLow    = errors.New("block time must be &gt;= 1ms")
        ErrRoundTimeoutTooLow = errors.New("round timeout must be &gt;= block time")
)

// Parameters defines consensus parameters
type Parameters struct {
        K                     int
        Alpha                 float64 // For compatibility with Quasar
        Beta                  uint32  // For compatibility with Quasar
        AlphaPreference       int
        AlphaConfidence       int
        BetaVirtuous          int
        BetaRogue             int
        ConcurrentPolls       int
        ConcurrentRepolls     int
        OptimalProcessing     int
        MaxOutstandingItems   int
        MaxItemProcessingTime time.Duration
        Parents               int
        BatchSize             int
        BlockTime             time.Duration // For compatibility
        RoundTO               time.Duration // For compatibility
}

// DefaultParams returns default parameters with 69% threshold
func DefaultParams() Parameters <span class="cov8" title="1">{
        return Parameters{
                K:                     20,
                Alpha:                 0.69, // 69% threshold for BFT
                Beta:                  14,   // Adjusted for 69% (was 15)
                AlphaPreference:       14,   // 70% of K for 69% threshold
                AlphaConfidence:       14,   // Matches AlphaPreference for 69%
                BetaVirtuous:          14,   // Virtuous confidence for 69%
                BetaRogue:             20,   // Rogue confidence remains high
                ConcurrentPolls:       4,
                ConcurrentRepolls:     4,
                OptimalProcessing:     10,
                MaxOutstandingItems:   1024,
                MaxItemProcessingTime: 2 * time.Minute,
                Parents:               2, // Reduced for efficiency
                BatchSize:             30,
                BlockTime:             100 * time.Millisecond,
                RoundTO:               250 * time.Millisecond,
        }
}</span>

// MainnetParams returns mainnet parameters with 69% threshold
func MainnetParams() Parameters <span class="cov8" title="1">{
        p := DefaultParams()
        p.K = 21
        p.AlphaPreference = 15 // ~71% of K for 69% threshold
        p.AlphaConfidence = 15 // Matches AlphaPreference
        p.BetaVirtuous = 15    // Virtuous confidence for 69%
        p.BlockTime = 200 * time.Millisecond
        p.RoundTO = 400 * time.Millisecond
        return p
}</span>

// TestnetParams returns testnet parameters with 69% threshold
func TestnetParams() Parameters <span class="cov8" title="1">{
        p := DefaultParams()
        p.K = 11
        p.Alpha = 0.69        // 69% threshold
        p.Beta = 8            // Adjusted for 69%
        p.AlphaPreference = 8 // ~73% of K for 69% threshold
        p.AlphaConfidence = 8 // Matches AlphaPreference
        p.BetaVirtuous = 8    // Virtuous confidence for 69%
        p.BlockTime = 100 * time.Millisecond
        p.RoundTO = 225 * time.Millisecond
        return p
}</span>

// LocalParams returns local parameters with 69% threshold
func LocalParams() Parameters <span class="cov8" title="1">{
        p := DefaultParams()
        p.K = 5
        p.Alpha = 0.69        // 69% threshold
        p.Beta = 4            // Adjusted for 69%
        p.AlphaPreference = 4 // 80% of K for 69% threshold
        p.AlphaConfidence = 4 // Matches AlphaPreference
        p.BetaVirtuous = 4    // Virtuous confidence for 69%
        p.BlockTime = 10 * time.Millisecond
        p.RoundTO = 45 * time.Millisecond
        return p
}</span>

// XChainParams returns X-Chain parameters with 69% threshold
func XChainParams() Parameters <span class="cov8" title="1">{
        p := DefaultParams()
        p.K = 5
        p.Alpha = 0.69        // 69% threshold
        p.Beta = 4            // Adjusted for 69%
        p.AlphaPreference = 4 // 80% of K for 69% threshold
        p.AlphaConfidence = 4 // Matches AlphaPreference
        p.BetaVirtuous = 4    // Virtuous confidence for 69%
        p.BlockTime = 1 * time.Millisecond
        p.RoundTO = 5 * time.Millisecond
        return p
}</span>

// WithBlockTime returns a copy of Parameters with updated block time
func (p Parameters) WithBlockTime(blockTime time.Duration) Parameters <span class="cov8" title="1">{
        p.BlockTime = blockTime
        // Adjust round timeout based on block time
        if blockTime &lt;= time.Millisecond </span><span class="cov8" title="1">{
                p.RoundTO = 5 * time.Millisecond
        }</span> else<span class="cov8" title="1"> if blockTime &lt; 10*time.Millisecond </span><span class="cov8" title="1">{
                p.RoundTO = 25 * time.Millisecond
        }</span> else<span class="cov8" title="1"> if blockTime &lt; 100*time.Millisecond </span><span class="cov8" title="1">{
                p.RoundTO = 250 * time.Millisecond
        }</span> else<span class="cov8" title="1"> {
                p.RoundTO = blockTime * 2
        }</span>
        <span class="cov8" title="1">return p</span>
}

// Validate validates parameters (compatibility method)
func (p Parameters) Validate() error <span class="cov8" title="1">{
        return p.Valid()
}</span>

// Valid validates parameters with 69% threshold enforcement
func (p Parameters) Valid() error <span class="cov8" title="1">{
        // Check K, Alpha, Beta first - these are always required
        if p.K &lt; 1 </span><span class="cov8" title="1">{
                return ErrInvalidK
        }</span>
        // Enforce 69% threshold minimum (with small tolerance for rounding)
        <span class="cov8" title="1">if p.Alpha &lt; 0.68 || p.Alpha &gt; 1.0 </span><span class="cov8" title="1">{
                return ErrInvalidAlpha
        }</span>
        <span class="cov8" title="1">if p.Beta &lt; 1 </span><span class="cov8" title="1">{
                return ErrInvalidBeta
        }</span>
        <span class="cov8" title="1">if p.BlockTime &gt; 0 &amp;&amp; p.BlockTime &lt; time.Millisecond </span><span class="cov8" title="1">{
                return ErrBlockTimeTooLow
        }</span>
        <span class="cov8" title="1">if p.BlockTime &gt; 0 &amp;&amp; p.RoundTO &gt; 0 &amp;&amp; p.RoundTO &lt; p.BlockTime </span><span class="cov8" title="1">{
                return ErrRoundTimeoutTooLow
        }</span>

        // Only validate other fields if they are set (non-zero)
        <span class="cov8" title="1">if p.AlphaPreference != 0 &amp;&amp; (p.AlphaPreference &lt; 0 || p.AlphaPreference &gt; p.K) </span><span class="cov0" title="0">{
                return ErrParametersInvalid
        }</span>
        <span class="cov8" title="1">if p.AlphaConfidence != 0 &amp;&amp; (p.AlphaConfidence &lt; 0 || p.AlphaConfidence &gt; p.K) </span><span class="cov0" title="0">{
                return ErrParametersInvalid
        }</span>
        <span class="cov8" title="1">if p.BetaVirtuous &lt; 0 </span><span class="cov0" title="0">{
                return ErrParametersInvalid
        }</span>
        <span class="cov8" title="1">if p.BetaRogue != 0 &amp;&amp; p.BetaRogue &lt; p.BetaVirtuous </span><span class="cov0" title="0">{
                return ErrParametersInvalid
        }</span>
        <span class="cov8" title="1">if p.ConcurrentPolls != 0 &amp;&amp; p.ConcurrentPolls &lt; 1 </span><span class="cov0" title="0">{
                return ErrParametersInvalid
        }</span>
        <span class="cov8" title="1">if p.OptimalProcessing != 0 &amp;&amp; p.OptimalProcessing &lt; 1 </span><span class="cov0" title="0">{
                return ErrParametersInvalid
        }</span>
        <span class="cov8" title="1">if p.MaxOutstandingItems != 0 &amp;&amp; p.MaxOutstandingItems &lt; 1 </span><span class="cov0" title="0">{
                return ErrParametersInvalid
        }</span>
        <span class="cov8" title="1">if p.MaxItemProcessingTime != 0 &amp;&amp; p.MaxItemProcessingTime &lt;= 0 </span><span class="cov0" title="0">{
                return ErrParametersInvalid
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import "math"

// Consensus threshold constants (LP-CONSENSUS-69)
const (
        // ConsensusSuperMajority is the 69% threshold for Byzantine fault tolerance
        // This provides an additional 2% safety margin above traditional 67% BFT
        ConsensusSuperMajority = 0.69

        // ConsensusSimpleMajority is the simple majority threshold
        ConsensusSimpleMajority = 0.51

        // MaxByzantineWeight is the maximum tolerable Byzantine weight (31%)
        MaxByzantineWeight = 0.31
)

// CalculateQuorum calculates the minimum weight needed for 69% consensus
func CalculateQuorum(totalWeight uint64) uint64 <span class="cov8" title="1">{
        return uint64(math.Ceil(float64(totalWeight) * ConsensusSuperMajority))
}</span>

// HasSuperMajority checks if the given weight meets the 69% threshold
func HasSuperMajority(weight, totalWeight uint64) bool <span class="cov8" title="1">{
        return float64(weight) &gt;= float64(totalWeight)*ConsensusSuperMajority
}</span>

// HasSimpleMajority checks if the given weight meets simple majority
func HasSimpleMajority(weight, totalWeight uint64) bool <span class="cov0" title="0">{
        return float64(weight) &gt;= float64(totalWeight)*ConsensusSimpleMajority
}</span>

// CanTolerateFailure checks if the Byzantine weight is within tolerance
func CanTolerateFailure(byzantineWeight, totalWeight uint64) bool <span class="cov8" title="1">{
        return float64(byzantineWeight) &lt;= float64(totalWeight)*MaxByzantineWeight
}</span>

// AlphaForK calculates the appropriate Alpha value for a given K
// to achieve 69% consensus threshold
func AlphaForK(k int) int <span class="cov8" title="1">{
        return int(math.Ceil(float64(k) * ConsensusSuperMajority))
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package config

// FPCConfig represents Firing Photon Cannon configuration
type FPCConfig struct {
        // Enable indicates whether FPC is enabled (default: true)
        Enable bool

        // Rounds is the number of FPC rounds to run
        Rounds int

        // Threshold is the confidence threshold for FPC
        Threshold float64

        // SampleSize is the number of nodes to sample per round
        SampleSize int
}

// DefaultFPC returns the default FPC configuration
func DefaultFPC() FPCConfig <span class="cov0" title="0">{
        return FPCConfig{
                Enable:     true, // FPC enabled by default
                Rounds:     10,
                Threshold:  0.8,
                SampleSize: 20,
        }
}</span>

// WithFPC adds FPC configuration to Parameters
func (p Parameters) WithFPC(fpc FPCConfig) Parameters <span class="cov0" title="0">{
        // In a real implementation, you'd add FPC fields to Parameters
        // For now, just return the parameters unchanged
        return p
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package config

type WaveConfig struct {
        Enable              bool
        VoteLimitPerBlock   int
        ExecuteOwned        bool
        ExecuteMixedOnFinal bool
        EpochFence          bool
        VotePrefix          []byte
}

func DefaultWave() WaveConfig <span class="cov8" title="1">{
        return WaveConfig{
                Enable:              true,
                VoteLimitPerBlock:   256,
                ExecuteOwned:        true,
                ExecuteMixedOnFinal: true,
                EpochFence:          true,
                VotePrefix:          []byte("WAVE/V1"),
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Package consensus provides the Lux consensus implementation.
package consensus

import (
        "context"

        "github.com/luxfi/consensus/codec"
        "github.com/luxfi/consensus/config"
        consensuscontext "github.com/luxfi/consensus/context"
        "github.com/luxfi/consensus/engine/chain"
        "github.com/luxfi/consensus/engine/dag"
        "github.com/luxfi/consensus/engine/pq"
)

// Engine is the main consensus engine interface
type Engine interface {
        // Start starts the engine
        Start(context.Context, uint32) error

        // Stop stops the engine
        Stop(context.Context) error

        // HealthCheck performs a health check
        HealthCheck(context.Context) (interface{}, error)

        // IsBootstrapped returns whether the engine is bootstrapped
        IsBootstrapped() bool
}

// NewChainEngine creates a new chain consensus engine
func NewChainEngine() Engine <span class="cov8" title="1">{
        return chain.New()
}</span>

// NewDAGEngine creates a new DAG consensus engine
func NewDAGEngine() Engine <span class="cov8" title="1">{
        return &amp;dagEngineWrapper{dag.New()}
}</span>

// dagEngineWrapper wraps dag.Engine to implement consensus.Engine
type dagEngineWrapper struct {
        dag.Engine
}

func (d *dagEngineWrapper) Stop(ctx context.Context) error <span class="cov8" title="1">{
        return d.Shutdown(ctx)
}</span>

func (d *dagEngineWrapper) HealthCheck(ctx context.Context) (interface{}, error) <span class="cov8" title="1">{
        return map[string]string{"status": "healthy"}, nil
}</span>

func (d *dagEngineWrapper) IsBootstrapped() bool <span class="cov8" title="1">{
        return true
}</span>

// NewPQEngine creates a new post-quantum consensus engine
func NewPQEngine() Engine <span class="cov8" title="1">{
        return pq.New()
}</span>

// Config returns default consensus parameters for different network sizes
func Config(nodes int) config.Parameters <span class="cov0" title="0">{
        switch </span>{
        case nodes &lt;= 5:<span class="cov0" title="0">
                return config.LocalParams()</span>
        case nodes &lt;= 11:<span class="cov0" title="0">
                return config.TestnetParams()</span>
        case nodes &lt;= 21:<span class="cov0" title="0">
                return config.MainnetParams()</span>
        default:<span class="cov0" title="0">
                // For larger networks, use mainnet with adjusted K
                cfg := config.MainnetParams()
                cfg.K = nodes
                return cfg</span>
        }
}

// Export types from sub-packages for convenience
type (
        // Context is the consensus context
        Context = consensuscontext.Context

        // ValidatorState provides validator information
        ValidatorState = consensuscontext.ValidatorState

        // IDs holds consensus IDs
        IDs = consensuscontext.IDs

        // CodecVersion is the codec version
        CodecVersion = codec.CodecVersion
)

// Export constants
const (
        // CurrentCodecVersion is the current codec version
        CurrentCodecVersion = codec.CurrentVersion
)

// Export variables
var (
        // Codec is the consensus codec
        Codec = codec.Codec
)

// Export functions from context
var (
        GetTimestamp       = consensuscontext.GetTimestamp
        GetChainID         = consensuscontext.GetChainID
        GetNetID           = consensuscontext.GetNetID
        GetNetworkID       = consensuscontext.GetNetworkID
        GetValidatorState  = consensuscontext.GetValidatorState
        GetSubnetID        = consensuscontext.GetNetID // GetSubnetID is an alias for GetNetID for backward compatibility
        WithContext        = consensuscontext.WithContext
        FromContext        = consensuscontext.FromContext
        GetNodeID          = consensuscontext.GetNodeID
        WithIDs            = consensuscontext.WithIDs
        WithValidatorState = consensuscontext.WithValidatorState
)

// AppError represents an application error
type AppError struct {
        Code    int
        Message string
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright (C) 2019-2024, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

package consensustest

import (
        "context"
        "testing"

        "github.com/luxfi/consensus"
        "github.com/luxfi/ids"
)

var (
        PChainID   = ids.GenerateTestID()
        XChainID   = ids.GenerateTestID()
        CChainID   = ids.GenerateTestID()
        LUXAssetID = ids.GenerateTestID()
)

// SimpleValidatorState is a minimal validator state for testing
type SimpleValidatorState struct{}

func (s *SimpleValidatorState) GetChainID(chainID ids.ID) (ids.ID, error) <span class="cov0" title="0">{
        return chainID, nil
}</span>

func (s *SimpleValidatorState) GetNetID(chainID ids.ID) (ids.ID, error) <span class="cov0" title="0">{
        return ids.Empty, nil
}</span>

func (s *SimpleValidatorState) GetSubnetID(chainID ids.ID) (ids.ID, error) <span class="cov0" title="0">{
        return ids.Empty, nil
}</span>

func (s *SimpleValidatorState) GetValidatorSet(height uint64, subnetID ids.ID) (map[ids.NodeID]uint64, error) <span class="cov0" title="0">{
        return map[ids.NodeID]uint64{}, nil
}</span>

func (s *SimpleValidatorState) GetCurrentHeight() (uint64, error) <span class="cov0" title="0">{
        return 0, nil
}</span>

func (s *SimpleValidatorState) GetMinimumHeight(ctx context.Context) (uint64, error) <span class="cov0" title="0">{
        return 0, nil
}</span>

// ConsensusContext updates a consensus context with default test values
func ConsensusContext(ctx *consensus.Context) *consensus.Context <span class="cov0" title="0">{
        // Simple consensus package doesn't have these fields, just return the context as-is
        return ctx
}</span>

// NewContext creates a new consensus context for testing
// This is a compatibility function that creates a context with a generated chain ID
func NewContext(tb testing.TB) *consensus.Context <span class="cov0" title="0">{
        return Context(tb, ids.GenerateTestID())
}</span>

// Context creates a new consensus context for testing with a specific chain ID
func Context(tb testing.TB, chainID ids.ID) *consensus.Context <span class="cov0" title="0">{
        tb.Helper()

        ctx := &amp;consensus.Context{
                QuantumID: 1,
                ChainID:   chainID,
                NodeID:    ids.GenerateTestNodeID(),
                NetID:     ids.Empty,
        }

        // Set up a simple validator state
        ctx.ValidatorState = &amp;SimpleValidatorState{}

        return ctx
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package consensustest

import (
        "context"
        "testing"

        "github.com/luxfi/consensus/choices"
        "github.com/luxfi/ids"
)

// Block status constants
const (
        Unknown    uint8 = 0
        Processing uint8 = 1
        Accepted   uint8 = 2
        Rejected   uint8 = 3
)

// Decidable is an embedded struct for test blocks
type Decidable struct {
        IDV     ids.ID
        StatusV choices.Status
}

// ID returns the ID of this decidable
func (d *Decidable) ID() ids.ID <span class="cov0" title="0">{
        return d.IDV
}</span>

// Accept marks this as accepted
func (d *Decidable) Accept(context.Context) error <span class="cov0" title="0">{
        d.StatusV = choices.Accepted
        return nil
}</span>

// Reject marks this as rejected
func (d *Decidable) Reject(context.Context) error <span class="cov0" title="0">{
        d.StatusV = choices.Rejected
        return nil
}</span>

// Status returns the current status
func (d *Decidable) Status() choices.Status <span class="cov0" title="0">{
        return d.StatusV
}</span>

// TestConfig provides test configuration
type TestConfig struct {
        NodeID    ids.NodeID
        NetworkID uint32
        ChainID   ids.ID
}

// NewTestConfig creates a test config
func NewTestConfig(t *testing.T) *TestConfig <span class="cov0" title="0">{
        return &amp;TestConfig{
                NodeID:    ids.GenerateTestNodeID(),
                NetworkID: 1,
                ChainID:   ids.GenerateTestID(),
        }
}</span>

// MockEngine is a mock consensus engine
type MockEngine struct {
        StartCalled  bool
        StopCalled   bool
        Bootstrapped bool
}

// Start starts the engine
func (m *MockEngine) Start(ctx context.Context, requestID uint32) error <span class="cov0" title="0">{
        m.StartCalled = true
        m.Bootstrapped = true
        return nil
}</span>

// Stop stops the engine
func (m *MockEngine) Stop(ctx context.Context) error <span class="cov0" title="0">{
        m.StopCalled = true
        return nil
}</span>

// IsBootstrapped returns bootstrap status
func (m *MockEngine) IsBootstrapped() bool <span class="cov0" title="0">{
        return m.Bootstrapped
}</span>

// HealthCheck performs health check
func (m *MockEngine) HealthCheck(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{
        return map[string]bool{"healthy": true}, nil
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright (C) 2019-2024, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

package consensus

import "context"

// ContextInitializable can be initialized with context
type ContextInitializable interface {
        InitCtx(context.Context)
}

// Contextualizable can be contextualized
type Contextualizable interface {
        InitializeContext(context.Context) error
}

// LuxAssetID returns the ID of the LUX asset
func LuxAssetID(ctx context.Context) interface{} <span class="cov0" title="0">{
        // This is a placeholder implementation
        // In production, this would get the actual LUX asset ID from context
        return nil
}</span>

// QuantumNetworkID returns the quantum network ID from context
func QuantumNetworkID(ctx context.Context) uint32 <span class="cov0" title="0">{
        if qids := GetQuantumIDs(ctx); qids != nil </span><span class="cov0" title="0">{
                return qids.QuantumID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// GetQuantumIDs retrieves QuantumIDs from context
func GetQuantumIDs(ctx context.Context) *QuantumIDs <span class="cov0" title="0">{
        // Placeholder - would retrieve from context
        return nil
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">// Package context provides consensus context for VMs
package context

import (
        "context"
        "time"

        "github.com/luxfi/ids"
)

// Context provides consensus context for VMs
type Context struct {
        // QuantumID is the root quantum network identifier
        QuantumID uint32 `json:"quantumID"`
        // NetID identifies the specific network/subnet within the quantum network
        NetID ids.ID `json:"netID"`
        // ChainID identifies the specific chain within the network
        ChainID     ids.ID     `json:"chainID"`
        NodeID      ids.NodeID `json:"nodeID"`
        PublicKey   []byte     `json:"publicKey"`
        XChainID    ids.ID     `json:"xChainID"`
        CChainID    ids.ID     `json:"cChainID"`
        AVAXAssetID ids.ID     `json:"avaxAssetID"`

        // Timing
        StartTime time.Time `json:"startTime"`

        // Additional fields for consensus
        ValidatorState ValidatorState
        Keystore       Keystore
        BCLookup       BlockchainIDLookup
        Metrics        Metrics
}

// ValidatorState provides validator information
type ValidatorState interface {
        GetChainID(ids.ID) (ids.ID, error)
        GetNetID(ids.ID) (ids.ID, error)
        GetSubnetID(chainID ids.ID) (ids.ID, error)
        GetValidatorSet(uint64, ids.ID) (map[ids.NodeID]uint64, error)
        GetCurrentHeight() (uint64, error)
        GetMinimumHeight(context.Context) (uint64, error)
}

// GetValidatorOutput contains validator information
type GetValidatorOutput struct {
        NodeID    ids.NodeID
        PublicKey []byte
        Weight    uint64
}

// Keystore provides key management
type Keystore interface {
        GetDatabase(username, password string) (interface{}, error)
        NewAccount(username, password string) error
}

// BlockchainIDLookup provides blockchain ID lookup
type BlockchainIDLookup interface {
        Lookup(alias string) (ids.ID, error)
}

// Metrics provides metrics tracking
type Metrics interface {
        Register(namespace string, registerer interface{}) error
}

// GetTimestamp returns the current timestamp
func GetTimestamp() int64 <span class="cov0" title="0">{
        return time.Now().Unix()
}</span>

// GetChainID gets the chain ID from context
func GetChainID(ctx context.Context) ids.ID <span class="cov0" title="0">{
        if c, ok := ctx.Value(contextKey).(*Context); ok </span><span class="cov0" title="0">{
                return c.ChainID
        }</span>
        <span class="cov0" title="0">return ids.Empty</span>
}

// GetNetID gets the network ID from context
func GetNetID(ctx context.Context) ids.ID <span class="cov0" title="0">{
        if c, ok := ctx.Value(contextKey).(*Context); ok </span><span class="cov0" title="0">{
                return c.NetID
        }</span>
        <span class="cov0" title="0">return ids.Empty</span>
}

// Deprecated: GetSubnetID is deprecated, use GetNetID instead
func GetSubnetID(ctx context.Context) ids.ID <span class="cov0" title="0">{
        // Direct implementation to avoid calling deprecated functions
        if c, ok := ctx.Value(contextKey).(*Context); ok </span><span class="cov0" title="0">{
                return c.NetID
        }</span>
        <span class="cov0" title="0">return ids.Empty</span>
}

// GetNetworkID gets the network ID from context
func GetNetworkID(ctx context.Context) uint32 <span class="cov0" title="0">{
        if c, ok := ctx.Value(contextKey).(*Context); ok </span><span class="cov0" title="0">{
                return c.QuantumID
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// GetValidatorState gets the validator state from context
func GetValidatorState(ctx context.Context) ValidatorState <span class="cov0" title="0">{
        if c, ok := ctx.Value(contextKey).(*Context); ok </span><span class="cov0" title="0">{
                return c.ValidatorState
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// WithContext adds consensus context to a context
func WithContext(ctx context.Context, cc *Context) context.Context <span class="cov0" title="0">{
        return context.WithValue(ctx, contextKey, cc)
}</span>

// FromContext extracts consensus context from a context
func FromContext(ctx context.Context) *Context <span class="cov0" title="0">{
        if c, ok := ctx.Value(contextKey).(*Context); ok </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetNodeID gets the node ID from context
func GetNodeID(ctx context.Context) ids.NodeID <span class="cov0" title="0">{
        if c, ok := ctx.Value(contextKey).(*Context); ok </span><span class="cov0" title="0">{
                return c.NodeID
        }</span>
        <span class="cov0" title="0">return ids.EmptyNodeID</span>
}

// IDs holds the IDs for consensus context
type IDs struct {
        // NetworkID is the network identifier
        NetworkID uint32
        // QuantumID is the root quantum network identifier
        QuantumID uint32
        // NetID identifies the network within the quantum network
        NetID ids.ID
        // ChainID identifies the chain within the network
        ChainID   ids.ID
        NodeID    ids.NodeID
        PublicKey []byte
        // LUXAssetID is the asset ID for LUX
        LUXAssetID ids.ID
}

// WithIDs adds IDs to the context
func WithIDs(ctx context.Context, ids IDs) context.Context <span class="cov0" title="0">{
        c := FromContext(ctx)
        if c == nil </span><span class="cov0" title="0">{
                c = &amp;Context{}
        }</span>
        <span class="cov0" title="0">c.QuantumID = ids.QuantumID
        c.NetID = ids.NetID
        c.ChainID = ids.ChainID
        c.NodeID = ids.NodeID
        c.PublicKey = ids.PublicKey
        return WithContext(ctx, c)</span>
}

// WithValidatorState adds validator state to the context
func WithValidatorState(ctx context.Context, vs ValidatorState) context.Context <span class="cov0" title="0">{
        c := FromContext(ctx)
        if c == nil </span><span class="cov0" title="0">{
                c = &amp;Context{}
        }</span>
        <span class="cov0" title="0">c.ValidatorState = vs
        return WithContext(ctx, c)</span>
}

type contextKeyType struct{}

var contextKey = contextKeyType{}
</pre>
		
		<pre class="file" id="file18" style="display: none">package consensus

import (
        "github.com/luxfi/ids"
)

// Fx represents a feature extension
type Fx interface {
        Initialize(interface{}) error
}

// State represents consensus state
type State interface {
        GetTimestamp() int64
        SetTimestamp(int64)
}

// AcceptorGroup manages a group of acceptors
type AcceptorGroup interface {
        RegisterAcceptor(chainID ids.ID, acceptorName string, acceptor Acceptor, dieOnError bool) error
        DeregisterAcceptor(chainID ids.ID, acceptorName string) error
}

// acceptorGroupImpl implements AcceptorGroup
type acceptorGroupImpl struct {
        // Add fields as needed
}

// NewAcceptorGroup creates a new acceptor group
func NewAcceptorGroup() AcceptorGroup <span class="cov0" title="0">{
        return &amp;acceptorGroupImpl{}
}</span>

// RegisterAcceptor registers an acceptor
func (a *acceptorGroupImpl) RegisterAcceptor(chainID ids.ID, acceptorName string, acceptor Acceptor, dieOnError bool) error <span class="cov0" title="0">{
        return nil
}</span>

// DeregisterAcceptor deregisters an acceptor
func (a *acceptorGroupImpl) DeregisterAcceptor(chainID ids.ID, acceptorName string) error <span class="cov0" title="0">{
        return nil
}</span>

// QuantumIDs contains various quantum network and chain IDs
type QuantumIDs struct {
        // QuantumID is the root quantum network identifier
        QuantumID uint32
        NodeID    ids.NodeID
        // NetID identifies networks within the quantum network
        NetID   ids.ID
        ChainID ids.ID
        // P-Chain is the quantum validation chain
        PChainID    ids.ID
        XChainID    ids.ID
        CChainID    ids.ID
        AVAXAssetID ids.ID
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright (C) 2019-2024, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

package core

import "fmt"

// AppError represents an application error
type AppError struct {
        Code    int32
        Message string
}

// Error implements the error interface
func (e *AppError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("app error %d: %s", e.Code, e.Message)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright (C) 2019-2024, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

package appsender

import (
        "context"

        "github.com/luxfi/consensus/utils/set"
        "github.com/luxfi/ids"
)

// FakeSender is a fake implementation of AppSender for testing
type FakeSender struct {
        SentAppRequest           []byte
        SentAppGossip            []byte
        SentCrossChainAppRequest []byte
}

func (f *FakeSender) SendAppRequest(ctx context.Context, nodeIDs set.Set[ids.NodeID], requestID uint32, appRequestBytes []byte) error <span class="cov0" title="0">{
        f.SentAppRequest = appRequestBytes
        return nil
}</span>

func (f *FakeSender) SendAppResponse(ctx context.Context, nodeID ids.NodeID, requestID uint32, appResponseBytes []byte) error <span class="cov0" title="0">{
        return nil
}</span>

func (f *FakeSender) SendAppError(ctx context.Context, nodeID ids.NodeID, requestID uint32, errorCode int32, errorMessage string) error <span class="cov0" title="0">{
        return nil
}</span>

func (f *FakeSender) SendAppGossip(ctx context.Context, nodeIDs set.Set[ids.NodeID], appGossipBytes []byte) error <span class="cov0" title="0">{
        f.SentAppGossip = appGossipBytes
        return nil
}</span>

func (f *FakeSender) SendAppGossipSpecific(ctx context.Context, nodeIDs set.Set[ids.NodeID], appGossipBytes []byte) error <span class="cov0" title="0">{
        f.SentAppGossip = appGossipBytes
        return nil
}</span>

func (f *FakeSender) SendCrossChainAppRequest(ctx context.Context, chainID ids.ID, requestID uint32, appRequestBytes []byte) error <span class="cov0" title="0">{
        f.SentCrossChainAppRequest = appRequestBytes
        return nil
}</span>

func (f *FakeSender) SendCrossChainAppResponse(ctx context.Context, chainID ids.ID, requestID uint32, appResponseBytes []byte) error <span class="cov0" title="0">{
        return nil
}</span>

func (f *FakeSender) SendCrossChainAppError(ctx context.Context, chainID ids.ID, requestID uint32, errorCode int32, errorMessage string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright (C) 2019-2024, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

// Package coremock provides mock implementations for testing
package coremock

import (
        "context"
        "sync"

        "github.com/luxfi/consensus/utils/set"
        "github.com/luxfi/ids"
)

// MockAppSender is a mock implementation of AppSender
type MockAppSender struct {
        mu sync.RWMutex

        SendAppRequestF        func(context.Context, set.Set[ids.NodeID], uint32, []byte) error
        SendAppResponseF       func(context.Context, ids.NodeID, uint32, []byte) error
        SendAppErrorF          func(context.Context, ids.NodeID, uint32, int32, string) error
        SendAppGossipF         func(context.Context, set.Set[ids.NodeID], []byte) error
        SendAppGossipSpecificF func(context.Context, set.Set[ids.NodeID], []byte) error
}

// NewMockAppSender creates a new mock AppSender
func NewMockAppSender(ctrl interface{}) *MockAppSender <span class="cov0" title="0">{
        return &amp;MockAppSender{}
}</span>

// SendAppRequest implements AppSender
func (m *MockAppSender) SendAppRequest(ctx context.Context, nodeIDs set.Set[ids.NodeID], requestID uint32, appRequestBytes []byte) error <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        if m.SendAppRequestF != nil </span><span class="cov0" title="0">{
                return m.SendAppRequestF(ctx, nodeIDs, requestID, appRequestBytes)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SendAppResponse implements AppSender
func (m *MockAppSender) SendAppResponse(ctx context.Context, nodeID ids.NodeID, requestID uint32, appResponseBytes []byte) error <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        if m.SendAppResponseF != nil </span><span class="cov0" title="0">{
                return m.SendAppResponseF(ctx, nodeID, requestID, appResponseBytes)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SendAppError implements AppSender
func (m *MockAppSender) SendAppError(ctx context.Context, nodeID ids.NodeID, requestID uint32, errorCode int32, errorMessage string) error <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        if m.SendAppErrorF != nil </span><span class="cov0" title="0">{
                return m.SendAppErrorF(ctx, nodeID, requestID, errorCode, errorMessage)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SendAppGossip implements AppSender
func (m *MockAppSender) SendAppGossip(ctx context.Context, nodeIDs set.Set[ids.NodeID], appGossipBytes []byte) error <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        if m.SendAppGossipF != nil </span><span class="cov0" title="0">{
                return m.SendAppGossipF(ctx, nodeIDs, appGossipBytes)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SendAppGossipSpecific implements AppSender
func (m *MockAppSender) SendAppGossipSpecific(ctx context.Context, nodeIDs set.Set[ids.NodeID], appGossipBytes []byte) error <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        if m.SendAppGossipSpecificF != nil </span><span class="cov0" title="0">{
                return m.SendAppGossipSpecificF(ctx, nodeIDs, appGossipBytes)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// EXPECT returns mock expectation handler
func (m *MockAppSender) EXPECT() *MockAppSenderExpects <span class="cov0" title="0">{
        return &amp;MockAppSenderExpects{mock: m}
}</span>

// MockAppSenderExpects handles expectations
type MockAppSenderExpects struct {
        mock *MockAppSender
}

// SendAppRequest sets expectation for SendAppRequest
func (e *MockAppSenderExpects) SendAppRequest() *MockAppSenderCall <span class="cov0" title="0">{
        return &amp;MockAppSenderCall{mock: e.mock}
}</span>

// MockAppSenderCall represents a mock call
type MockAppSenderCall struct {
        mock *MockAppSender
}

// Times sets the number of times the call is expected
func (c *MockAppSenderCall) Times(n int) *MockAppSenderCall <span class="cov0" title="0">{
        return c
}</span>

// Return sets the return value
func (c *MockAppSenderCall) Return(err error) *MockAppSenderCall <span class="cov0" title="0">{
        return c
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package dag

// Decision represents the outcome of cert/skip analysis
type Decision int

const (
        DecideUndecided Decision = iota
        DecideCommit             // Certificate found - vertex should be committed
        DecideSkip               // Skip certificate found - vertex should be skipped
)

// Cert: &gt;=2f+1 in r+1 support proposer(author,round). Skip: &gt;=2f+1 in r+1 not supporting.
func HasCertificate(v View, proposer Meta, p Params) bool <span class="cov0" title="0">{
        r1 := proposer.Round() + 1
        next := v.ByRound(r1)
        support := 0
        for _, m := range next </span><span class="cov0" title="0">{
                if v.Supports(m.ID(), proposer.Author(), proposer.Round()) </span><span class="cov0" title="0">{
                        support++
                        if support &gt;= 2*p.F+1 </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func HasSkip(v View, proposer Meta, p Params) bool <span class="cov0" title="0">{
        r1 := proposer.Round() + 1
        next := v.ByRound(r1)
        nos := 0
        for _, m := range next </span><span class="cov0" title="0">{
                if !v.Supports(m.ID(), proposer.Author(), proposer.Round()) </span><span class="cov0" title="0">{
                        nos++
                        if nos &gt;= 2*p.F+1 </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

type Flare struct{ p Params }

func NewFlare(p Params) *Flare <span class="cov0" title="0">{ return &amp;Flare{p: p} }</span>

func (f *Flare) Classify(v View, proposer Meta) Decision <span class="cov0" title="0">{
        switch </span>{
        case HasCertificate(v, proposer, f.p):<span class="cov0" title="0">
                return DecideCommit</span>
        case HasSkip(v, proposer, f.p):<span class="cov0" title="0">
                return DecideSkip</span>
        default:<span class="cov0" title="0">
                return DecideUndecided</span>
        }
}

// Generic versions for new protocol interfaces

// HasCertificateGeneric checks if a vertex has a certificate (≥2f+1 validators support it)
func HasCertificateGeneric[V VID](store Store[V], vertex V, params Params) bool <span class="cov0" title="0">{
        // TODO: Implement certificate detection
        // A vertex has a certificate if ≥2f+1 vertices in the next round reference it
        // This indicates strong support from honest validators
        return false
}</span>

// HasSkipGeneric checks if a vertex has a skip certificate (≥2f+1 validators do not support it)
func HasSkipGeneric[V VID](store Store[V], vertex V, params Params) bool <span class="cov0" title="0">{
        // TODO: Implement skip detection
        // A vertex has a skip certificate if ≥2f+1 vertices in the next round do NOT reference it
        // This indicates the vertex should be skipped/rejected
        return false
}</span>

// ClassifyGeneric determines the status of a vertex based on cert/skip analysis
func ClassifyGeneric[V VID](store Store[V], vertex V, params Params) Decision <span class="cov0" title="0">{
        switch </span>{
        case HasCertificateGeneric(store, vertex, params):<span class="cov0" title="0">
                return DecideCommit</span>
        case HasSkipGeneric(store, vertex, params):<span class="cov0" title="0">
                return DecideSkip</span>
        default:<span class="cov0" title="0">
                return DecideUndecided</span>
        }
}

// ComputeFinalizableSet returns vertices that can be finalized based on cert/skip analysis
func ComputeFinalizableSet[V VID](store Store[V], candidates []V, params Params) []V <span class="cov0" title="0">{
        var finalizable []V
        for _, v := range candidates </span><span class="cov0" title="0">{
                if ClassifyGeneric(store, v, params) == DecideCommit </span><span class="cov0" title="0">{
                        finalizable = append(finalizable, v)
                }</span>
        }
        <span class="cov0" title="0">return finalizable</span>
}

// UpdateDAGFrontier computes the new frontier after finalizing a set of vertices
func UpdateDAGFrontier[V VID](store Store[V], finalized []V) []V <span class="cov0" title="0">{
        // TODO: Implement frontier update logic
        // After finalizing vertices, compute the new frontier (tips) of the DAG
        return []V{}
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package dag

// VertexID represents a vertex identifier in the DAG
type VertexID [32]byte

// Meta interface represents metadata for a DAG vertex
type Meta interface {
        ID() VertexID
        Author() string
        Round() uint64
        Parents() []VertexID
}

// View interface provides access to DAG structure and vertex relationships
type View interface {
        Get(VertexID) (Meta, bool)
        ByRound(round uint64) []Meta
        Supports(from VertexID, author string, round uint64) bool
}

// Params holds DAG consensus parameters
type Params struct{ N, F int }

// VID represents a generic vertex identifier for new protocol interfaces
type VID interface{ comparable }

// BlockView represents a view of a block/vertex in the DAG (generic version)
type BlockView[V VID] interface {
        ID() V
        Parents() []V
        Author() string
        Round() uint64
}

// Store represents DAG storage interface (generic version)
type Store[V VID] interface {
        Head() []V
        Get(V) (BlockView[V], bool)
        Children(V) []V
}

// ComputeSafePrefix computes the safe prefix of vertices that can be committed
// based on DAG order theory using horizon (reachability) and flare (cert/skip) analysis
func ComputeSafePrefix[V VID](store Store[V], frontier []V) []V <span class="cov0" title="0">{
        // TODO: Implement using horizon reachability analysis and flare cert/skip detection
        // This should return vertices that have achieved finality according to DAG consensus rules

        // Placeholder implementation - return empty for now
        return []V{}
}</span>

// ChooseFrontier selects appropriate parents for a new vertex proposal
// This typically involves choosing a subset of frontier vertices to reference
func ChooseFrontier[V VID](frontier []V) []V <span class="cov0" title="0">{
        // TODO: Implement frontier selection logic
        // Common strategies:
        // - Choose all recent vertices (small frontier)
        // - Choose 2f+1 vertices for Byzantine tolerance
        // - Choose based on validator weight or other criteria

        // Placeholder implementation - return first few vertices
        if len(frontier) &lt;= 3 </span><span class="cov0" title="0">{
                return frontier
        }</span>
        <span class="cov0" title="0">return frontier[:3]</span>
}

// IsReachable checks if vertex 'from' can reach vertex 'to' in the DAG
func IsReachable[V VID](store Store[V], from, to V) bool <span class="cov0" title="0">{
        // TODO: Implement reachability check using DFS/BFS
        return false
}</span>

// LCA finds the lowest common ancestor of two vertices
func LCA[V VID](store Store[V], a, b V) V <span class="cov0" title="0">{
        // TODO: Implement LCA algorithm
        var zero V
        return zero
}</span>

// Antichain computes an antichain (set of mutually unreachable vertices) in the DAG
func Antichain[V VID](store Store[V], vertices []V) []V <span class="cov0" title="0">{
        // TODO: Implement antichain computation
        return []V{}
}</span>

// EventHorizon represents the finality boundary in Quasar P-Chain consensus
// Beyond this horizon, no events can affect the finalized state
type EventHorizon[V VID] struct {
        // Checkpoint represents a finalized state boundary
        Checkpoint V
        // Height at which this horizon was established
        Height uint64
        // Validators that signed this horizon
        Validators []string
        // Post-quantum signature (Ringtail + BLS)
        Signature []byte
}

// Horizon computes the event horizon for Quasar P-Chain finality
// This determines which vertices are beyond the point of no return
func Horizon[V VID](store Store[V], checkpoints []EventHorizon[V]) EventHorizon[V] <span class="cov0" title="0">{
        // TODO: Implement event horizon computation for P-Chain finality
        // This should:
        // 1. Analyze reachability from latest checkpoints
        // 2. Find vertices that have achieved post-quantum finality
        // 3. Establish new event horizon boundary

        // Placeholder - return latest checkpoint
        if len(checkpoints) &gt; 0 </span><span class="cov0" title="0">{
                return checkpoints[len(checkpoints)-1]
        }</span>

        <span class="cov0" title="0">var zero EventHorizon[V]
        return zero</span>
}

// BeyondHorizon checks if a vertex is beyond the event horizon (finalized)
func BeyondHorizon[V VID](store Store[V], vertex V, horizon EventHorizon[V]) bool <span class="cov0" title="0">{
        // TODO: Implement horizon reachability check
        // Vertices beyond the event horizon cannot be affected by future consensus
        return IsReachable(store, horizon.Checkpoint, vertex)
}</span>

// ComputeHorizonOrder determines the canonical order of vertices beyond the event horizon
func ComputeHorizonOrder[V VID](store Store[V], horizon EventHorizon[V]) []V <span class="cov0" title="0">{
        // TODO: Implement canonical ordering for finalized vertices
        // This provides deterministic ordering for P-Chain state transitions
        return []V{}
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package core

import "context"

// HealthCheckable represents something that can report its health
type HealthCheckable interface {
        // HealthCheck returns health information
        HealthCheck(context.Context) (interface{}, error)
}

// HealthStatus represents health status
type HealthStatus int

const (
        HealthUnknown HealthStatus = iota
        HealthHealthy
        HealthUnhealthy
)

// String returns the string representation
func (h HealthStatus) String() string <span class="cov0" title="0">{
        switch h </span>{
        case HealthHealthy:<span class="cov0" title="0">
                return "healthy"</span>
        case HealthUnhealthy:<span class="cov0" title="0">
                return "unhealthy"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package core

// Status represents the consensus status of an item
type Status int

const (
        // StatusUnknown means the status is unknown
        StatusUnknown Status = iota

        // StatusPending means the item is pending decision
        StatusPending

        // StatusProcessing means the item is being processed
        StatusProcessing

        // StatusAccepted means the item has been accepted
        StatusAccepted

        // StatusRejected means the item has been rejected
        StatusRejected
)

// String returns the string representation of the status
func (s Status) String() string <span class="cov0" title="0">{
        switch s </span>{
        case StatusPending:<span class="cov0" title="0">
                return "pending"</span>
        case StatusProcessing:<span class="cov0" title="0">
                return "processing"</span>
        case StatusAccepted:<span class="cov0" title="0">
                return "accepted"</span>
        case StatusRejected:<span class="cov0" title="0">
                return "rejected"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// Decided returns true if the status represents a final decision
func (s Status) Decided() bool <span class="cov0" title="0">{
        return s == StatusAccepted || s == StatusRejected
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package core

import (
        "context"

        "github.com/luxfi/ids"
)

// TestDecidable is a test implementation of Decidable
type TestDecidable struct {
        TestID     ids.ID
        TestStatus Status
        AcceptFunc func(context.Context) error
        RejectFunc func(context.Context) error
}

// NewTestDecidable creates a new test decidable
func NewTestDecidable(id ids.ID) *TestDecidable <span class="cov0" title="0">{
        return &amp;TestDecidable{
                TestID:     id,
                TestStatus: StatusPending,
                AcceptFunc: func(context.Context) error </span><span class="cov0" title="0">{ return nil }</span>,
                RejectFunc: func(context.Context) error <span class="cov0" title="0">{ return nil }</span>,
        }
}

// ID returns the ID
func (t *TestDecidable) ID() ids.ID <span class="cov0" title="0">{
        return t.TestID
}</span>

// Accept marks as accepted
func (t *TestDecidable) Accept(ctx context.Context) error <span class="cov0" title="0">{
        if t.AcceptFunc != nil </span><span class="cov0" title="0">{
                if err := t.AcceptFunc(ctx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">t.TestStatus = StatusAccepted
        return nil</span>
}

// Reject marks as rejected
func (t *TestDecidable) Reject(ctx context.Context) error <span class="cov0" title="0">{
        if t.RejectFunc != nil </span><span class="cov0" title="0">{
                if err := t.RejectFunc(ctx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">t.TestStatus = StatusRejected
        return nil</span>
}

// Status returns current status
func (t *TestDecidable) Status() Status <span class="cov0" title="0">{
        return t.TestStatus
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">// Copyright (C) 2019-2024, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

// Package tracker provides consensus tracking utilities
package tracker

import (
        "sync"
        "time"

        "github.com/luxfi/ids"
)

// Tracker tracks consensus operations
type Tracker interface {
        // Track starts tracking an operation
        Track(id ids.ID) time.Time

        // Stop stops tracking an operation
        Stop(id ids.ID) time.Duration

        // IsTracked checks if an operation is being tracked
        IsTracked(id ids.ID) bool

        // Len returns the number of tracked operations
        Len() int
}

// TimeTracker tracks operation times
type TimeTracker struct {
        mu     sync.RWMutex
        starts map[ids.ID]time.Time
}

// NewTimeTracker creates a new time tracker
func NewTimeTracker() *TimeTracker <span class="cov0" title="0">{
        return &amp;TimeTracker{
                starts: make(map[ids.ID]time.Time),
        }
}</span>

// Track starts tracking an operation
func (t *TimeTracker) Track(id ids.ID) time.Time <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()

        now := time.Now()
        t.starts[id] = now
        return now
}</span>

// Stop stops tracking an operation
func (t *TimeTracker) Stop(id ids.ID) time.Duration <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()

        start, ok := t.starts[id]
        if !ok </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">delete(t.starts, id)
        return time.Since(start)</span>
}

// IsTracked checks if an operation is being tracked
func (t *TimeTracker) IsTracked(id ids.ID) bool <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        _, ok := t.starts[id]
        return ok
}</span>

// Len returns the number of tracked operations
func (t *TimeTracker) Len() int <span class="cov0" title="0">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        return len(t.starts)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright (C) 2019-2024, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

package core

import (
        "context"
        "net/http"

        "github.com/luxfi/consensus/snow"
        "github.com/luxfi/database/manager"
        "github.com/luxfi/ids"
)

// VM defines the interface that all VMs must implement
type VM interface {
        // Initialize initializes the VM
        Initialize(
                ctx context.Context,
                chainCtx *snow.Context,
                dbManager manager.Manager,
                genesisBytes []byte,
                upgradeBytes []byte,
                configBytes []byte,
                toEngine chan&lt;- Message,
                fxs []*Fx,
                appSender interface{}, // AppSender interface from appsender package
        ) error

        // SetState sets the state of the VM
        SetState(ctx context.Context, state snow.State) error

        // Shutdown shuts down the VM
        Shutdown(ctx context.Context) error

        // Version returns the version of the VM
        Version(ctx context.Context) (string, error)

        // HealthCheck returns nil if the VM is healthy
        HealthCheck(ctx context.Context) (interface{}, error)

        // CreateHandlers returns the HTTP handlers for the VM
        CreateHandlers(ctx context.Context) (map[string]http.Handler, error)

        // CreateStaticHandlers returns the static HTTP handlers for the VM
        CreateStaticHandlers(ctx context.Context) (map[string]http.Handler, error)
}

// Message defines a message that can be sent to the consensus engine
type Message struct {
        Type    MessageType
        NodeID  ids.NodeID
        Content []byte
}

// MessageType defines the type of a message
type MessageType uint32

// String returns the string representation of the message type
func (m MessageType) String() string <span class="cov0" title="0">{
        switch m </span>{
        case PendingTxs:<span class="cov0" title="0">
                return "PendingTxs"</span>
        case PutBlock:<span class="cov0" title="0">
                return "PutBlock"</span>
        case GetBlock:<span class="cov0" title="0">
                return "GetBlock"</span>
        case GetAccepted:<span class="cov0" title="0">
                return "GetAccepted"</span>
        case Accepted:<span class="cov0" title="0">
                return "Accepted"</span>
        case GetAncestors:<span class="cov0" title="0">
                return "GetAncestors"</span>
        case MultiPut:<span class="cov0" title="0">
                return "MultiPut"</span>
        case GetFailed:<span class="cov0" title="0">
                return "GetFailed"</span>
        case QueryFailed:<span class="cov0" title="0">
                return "QueryFailed"</span>
        case Chits:<span class="cov0" title="0">
                return "Chits"</span>
        case ChitsV2:<span class="cov0" title="0">
                return "ChitsV2"</span>
        case GetAcceptedFrontier:<span class="cov0" title="0">
                return "GetAcceptedFrontier"</span>
        case AcceptedFrontier:<span class="cov0" title="0">
                return "AcceptedFrontier"</span>
        case GetAcceptedFrontierFailed:<span class="cov0" title="0">
                return "GetAcceptedFrontierFailed"</span>
        case AppRequest:<span class="cov0" title="0">
                return "AppRequest"</span>
        case AppResponse:<span class="cov0" title="0">
                return "AppResponse"</span>
        case AppGossip:<span class="cov0" title="0">
                return "AppGossip"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

const (
        // PendingTxs indicates pending transactions
        PendingTxs MessageType = iota
        // PutBlock indicates a block to be added
        PutBlock
        // GetBlock indicates a request for a block
        GetBlock
        // GetAccepted indicates a request for accepted blocks
        GetAccepted
        // Accepted indicates an accepted block
        Accepted
        // GetAncestors indicates a request for ancestors
        GetAncestors
        // MultiPut indicates multiple blocks
        MultiPut
        // GetFailed indicates a failed get request
        GetFailed
        // QueryFailed indicates a failed query
        QueryFailed
        // Chits indicates chits
        Chits
        // ChitsV2 indicates chits v2
        ChitsV2
        // GetAcceptedFrontier indicates a request for the accepted frontier
        GetAcceptedFrontier
        // AcceptedFrontier indicates the accepted frontier
        AcceptedFrontier
        // GetAcceptedFrontierFailed indicates a failed frontier request
        GetAcceptedFrontierFailed
        // AppRequest indicates an app request
        AppRequest
        // AppResponse indicates an app response
        AppResponse
        // AppGossip indicates app gossip
        AppGossip
)

// Fx defines a feature extension
type Fx struct {
        ID ids.ID
        Fx interface{}
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Package blockmock provides mock implementations for testing
package blockmock

import (
        "context"
        "time"
)

// MockBlock provides a mock implementation for testing
type MockBlock struct {
        id       []byte
        height   uint64
        parent   []byte
        accepted bool
}

// NewMockBlock creates a new mock block
func NewMockBlock(id []byte, height uint64, parent []byte) *MockBlock <span class="cov0" title="0">{
        return &amp;MockBlock{
                id:     id,
                height: height,
                parent: parent,
        }
}</span>

// ID returns the block ID
func (m *MockBlock) ID() []byte <span class="cov0" title="0">{
        return m.id
}</span>

// Height returns the block height
func (m *MockBlock) Height() uint64 <span class="cov0" title="0">{
        return m.height
}</span>

// Parent returns the parent block ID
func (m *MockBlock) Parent() []byte <span class="cov0" title="0">{
        return m.parent
}</span>

// Accept marks the block as accepted
func (m *MockBlock) Accept(ctx context.Context) error <span class="cov0" title="0">{
        m.accepted = true
        return nil
}</span>

// Reject marks the block as rejected
func (m *MockBlock) Reject(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// Status returns the block status
func (m *MockBlock) Status() int <span class="cov0" title="0">{
        if m.accepted </span><span class="cov0" title="0">{
                return 2 // Accepted
        }</span>
        <span class="cov0" title="0">return 0</span> // Processing
}

// Timestamp returns the block timestamp
func (m *MockBlock) Timestamp() time.Time <span class="cov0" title="0">{
        return time.Now()
}</span>

// Bytes returns the block bytes
func (m *MockBlock) Bytes() []byte <span class="cov0" title="0">{
        return m.id
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Package blocktest provides test utilities for blocks
package blocktest

import (
        "context"
        "time"

        "github.com/luxfi/consensus/consensustest"
        "github.com/luxfi/ids"
)

// Block provides a full test implementation for blocks
type Block struct {
        consensustest.Decidable
        HeightV    uint64
        ParentV    ids.ID
        BytesV     []byte
        TimestampV time.Time
        StatusV    uint8
        VerifyV    error
        AcceptV    error
        RejectV    error
}

// Height returns the block height
func (b *Block) Height() uint64 <span class="cov0" title="0">{
        return b.HeightV
}</span>

// Parent returns the parent block ID
func (b *Block) Parent() ids.ID <span class="cov0" title="0">{
        return b.ParentV
}</span>

// ParentID returns the parent block ID
func (b *Block) ParentID() ids.ID <span class="cov0" title="0">{
        return b.ParentV
}</span>

// Bytes returns the block bytes
func (b *Block) Bytes() []byte <span class="cov0" title="0">{
        return b.BytesV
}</span>

// Timestamp returns the block timestamp
func (b *Block) Timestamp() time.Time <span class="cov0" title="0">{
        if b.TimestampV.IsZero() </span><span class="cov0" title="0">{
                return time.Now()
        }</span>
        <span class="cov0" title="0">return b.TimestampV</span>
}

// Status returns the block status as uint8
func (b *Block) Status() uint8 <span class="cov0" title="0">{
        return b.StatusV
}</span>

// Verify verifies the block
func (b *Block) Verify(ctx context.Context) error <span class="cov0" title="0">{
        if b.VerifyV != nil </span><span class="cov0" title="0">{
                return b.VerifyV
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Accept accepts the block
func (b *Block) Accept(ctx context.Context) error <span class="cov0" title="0">{
        if b.AcceptV != nil </span><span class="cov0" title="0">{
                return b.AcceptV
        }</span>
        <span class="cov0" title="0">err := b.Decidable.Accept(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b.StatusV = consensustest.Accepted
        return nil</span>
}

// Reject rejects the block
func (b *Block) Reject(ctx context.Context) error <span class="cov0" title="0">{
        if b.RejectV != nil </span><span class="cov0" title="0">{
                return b.RejectV
        }</span>
        <span class="cov0" title="0">err := b.Decidable.Reject(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">b.StatusV = consensustest.Rejected
        return nil</span>
}

// TestBlock provides a test implementation for blocks (deprecated, use Block)
type TestBlock struct {
        id     []byte
        height uint64
        parent []byte
}

// NewTestBlock creates a new test block
func NewTestBlock(id []byte, height uint64, parent []byte) *TestBlock <span class="cov0" title="0">{
        return &amp;TestBlock{
                id:     id,
                height: height,
                parent: parent,
        }
}</span>

// ID returns the block ID
func (t *TestBlock) ID() []byte <span class="cov0" title="0">{
        return t.id
}</span>

// Height returns the block height
func (t *TestBlock) Height() uint64 <span class="cov0" title="0">{
        return t.height
}</span>

// Parent returns the parent block ID
func (t *TestBlock) Parent() []byte <span class="cov0" title="0">{
        return t.parent
}</span>

// Accept marks the block as accepted
func (t *TestBlock) Accept(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// Reject marks the block as rejected
func (t *TestBlock) Reject(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// Timestamp returns the block timestamp
func (t *TestBlock) Timestamp() time.Time <span class="cov0" title="0">{
        return time.Now()
}</span>

// Bytes returns the block bytes
func (t *TestBlock) Bytes() []byte <span class="cov0" title="0">{
        return t.id
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package bootstrap

import (
        "context"

        "github.com/luxfi/ids"
)

// Version represents protocol version
type Version uint32

// Bootstrapper bootstraps a chain
type Bootstrapper interface {
        // Start starts bootstrapping
        Start(context.Context, uint32) error

        // Connected notifies the bootstrapper of a connected validator
        Connected(context.Context, ids.NodeID, Version) error

        // Disconnected notifies the bootstrapper of a disconnected validator
        Disconnected(context.Context, ids.NodeID) error

        // HealthCheck performs a health check
        HealthCheck(context.Context) (interface{}, error)
}

// Bootstrapper implementation
type bootstrapper struct {
        started bool
}

// New creates a new bootstrapper
func New() Bootstrapper <span class="cov0" title="0">{
        return &amp;bootstrapper{}
}</span>

// Start starts bootstrapping
func (b *bootstrapper) Start(ctx context.Context, requestID uint32) error <span class="cov0" title="0">{
        b.started = true
        return nil
}</span>

// Connected notifies the bootstrapper of a connected validator
func (b *bootstrapper) Connected(ctx context.Context, nodeID ids.NodeID, version Version) error <span class="cov0" title="0">{
        return nil
}</span>

// Disconnected notifies the bootstrapper of a disconnected validator
func (b *bootstrapper) Disconnected(ctx context.Context, nodeID ids.NodeID) error <span class="cov0" title="0">{
        return nil
}</span>

// HealthCheck performs a health check
func (b *bootstrapper) HealthCheck(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{"started": b.started}, nil
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Package chainmock provides mock implementations for testing
package chainmock

// MockChain provides a mock implementation for testing
type MockChain struct {
        id     []byte
        height uint64
}

// NewMockChain creates a new mock chain
func NewMockChain(id []byte) *MockChain <span class="cov0" title="0">{
        return &amp;MockChain{
                id:     id,
                height: 0,
        }
}</span>

// ID returns the chain ID
func (m *MockChain) ID() []byte <span class="cov0" title="0">{
        return m.id
}</span>

// Height returns the current height
func (m *MockChain) Height() uint64 <span class="cov0" title="0">{
        return m.height
}</span>

// SetHeight sets the chain height
func (m *MockChain) SetHeight(height uint64) <span class="cov0" title="0">{
        m.height = height
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">// Package chaintest provides test utilities for chains
package chaintest

// TestChain provides a test implementation for chains
type TestChain struct {
        id     []byte
        height uint64
}

// NewTestChain creates a new test chain
func NewTestChain(id []byte) *TestChain <span class="cov0" title="0">{
        return &amp;TestChain{
                id:     id,
                height: 0,
        }
}</span>

// ID returns the chain ID
func (t *TestChain) ID() []byte <span class="cov0" title="0">{
        return t.id
}</span>

// Height returns the current height
func (t *TestChain) Height() uint64 <span class="cov0" title="0">{
        return t.height
}</span>

// SetHeight sets the chain height
func (t *TestChain) SetHeight(height uint64) <span class="cov0" title="0">{
        t.height = height
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright (C) 2019-2024, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

// Package chaintest provides test utilities for chain testing
package chaintest

import (
        "context"
        "time"

        "github.com/luxfi/consensus/consensustest"
        "github.com/luxfi/ids"
)

// TestBlock is a mock block for testing
type TestBlock struct {
        id        ids.ID
        parentID  ids.ID
        height    uint64
        bytes     []byte
        status    uint8
        timestamp time.Time
}

// ID returns the block ID
func (b *TestBlock) ID() ids.ID <span class="cov0" title="0">{
        return b.id
}</span>

// Parent returns the parent block ID (alias for ParentID)
func (b *TestBlock) Parent() ids.ID <span class="cov0" title="0">{
        return b.parentID
}</span>

// ParentID returns the parent block ID
func (b *TestBlock) ParentID() ids.ID <span class="cov0" title="0">{
        return b.parentID
}</span>

// Height returns the block height
func (b *TestBlock) Height() uint64 <span class="cov0" title="0">{
        return b.height
}</span>

// Timestamp returns the block timestamp
func (b *TestBlock) Timestamp() time.Time <span class="cov0" title="0">{
        return b.timestamp
}</span>

// Bytes returns the block bytes
func (b *TestBlock) Bytes() []byte <span class="cov0" title="0">{
        return b.bytes
}</span>

// Status returns the block status
func (b *TestBlock) Status() uint8 <span class="cov0" title="0">{
        return b.status
}</span>

// Accept accepts the block
func (b *TestBlock) Accept(ctx context.Context) error <span class="cov0" title="0">{
        b.status = consensustest.Accepted
        return nil
}</span>

// Reject rejects the block
func (b *TestBlock) Reject(ctx context.Context) error <span class="cov0" title="0">{
        b.status = consensustest.Rejected
        return nil
}</span>

// Verify verifies the block
func (b *TestBlock) Verify(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// Genesis is the genesis test block
var Genesis = &amp;TestBlock{
        id:        ids.GenerateTestID(),
        parentID:  ids.Empty,
        height:    0,
        bytes:     []byte("genesis"),
        status:    consensustest.Accepted,
        timestamp: time.Now(),
}

// BuildChild builds a child block
func BuildChild(parent *TestBlock) *TestBlock <span class="cov0" title="0">{
        return &amp;TestBlock{
                id:        ids.GenerateTestID(),
                parentID:  parent.ID(),
                height:    parent.Height() + 1,
                bytes:     []byte("child"),
                status:    consensustest.Processing,
                timestamp: time.Now(),
        }
}</span>

// BuildChildWithTime builds a child block with timestamp
func BuildChildWithTime(parent *TestBlock, timestamp time.Time) *TestBlock <span class="cov0" title="0">{
        return &amp;TestBlock{
                id:        ids.GenerateTestID(),
                parentID:  parent.ID(),
                height:    parent.Height() + 1,
                bytes:     append([]byte("child"), timestamp.Format(time.RFC3339)...),
                status:    consensustest.Processing,
                timestamp: timestamp,
        }
}</span>
</pre>
		
		<pre class="file" id="file35" style="display: none">package chain

import (
        "context"

        "github.com/luxfi/ids"
)

// Engine defines the chain consensus engine
type Engine interface {
        // Start starts the engine
        Start(context.Context, uint32) error

        // Stop stops the engine
        Stop(context.Context) error

        // HealthCheck performs a health check
        HealthCheck(context.Context) (interface{}, error)

        // IsBootstrapped returns whether the chain is bootstrapped
        IsBootstrapped() bool
}

// Transitive implements transitive chain consensus
type Transitive struct {
        bootstrapped bool
}

// Transport handles message transport for consensus
type Transport[ID comparable] interface {
        // Send sends a message
        Send(ctx context.Context, to string, msg interface{}) error

        // Receive receives messages
        Receive(ctx context.Context) (interface{}, error)
}

// New creates a new chain consensus engine
func New() *Transitive <span class="cov8" title="1">{
        return &amp;Transitive{
                bootstrapped: false,
        }
}</span>

// Start starts the engine
func (t *Transitive) Start(ctx context.Context, requestID uint32) error <span class="cov8" title="1">{
        t.bootstrapped = true
        return nil
}</span>

// Stop stops the engine
func (t *Transitive) Stop(ctx context.Context) error <span class="cov8" title="1">{
        return nil
}</span>

// HealthCheck performs a health check
func (t *Transitive) HealthCheck(ctx context.Context) (interface{}, error) <span class="cov8" title="1">{
        return map[string]interface{}{"healthy": true}, nil
}</span>

// IsBootstrapped returns whether the chain is bootstrapped
func (t *Transitive) IsBootstrapped() bool <span class="cov8" title="1">{
        return t.bootstrapped
}</span>

// GetBlock gets a block by ID
func (t *Transitive) GetBlock(ctx context.Context, nodeID ids.NodeID, requestID uint32, blockID ids.ID) error <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package getter

import (
        "context"

        "github.com/luxfi/ids"
)

// Getter gets blocks
type Getter interface {
        // Get gets a block
        Get(context.Context, ids.NodeID, uint32, ids.ID) error

        // GetAncestors gets ancestors
        GetAncestors(context.Context, ids.NodeID, uint32, ids.ID, int) error

        // Put puts a block
        Put(context.Context, ids.NodeID, uint32, []byte) error

        // PushQuery pushes a query
        PushQuery(context.Context, ids.NodeID, uint32, []byte) error

        // PullQuery pulls a query
        PullQuery(context.Context, ids.NodeID, uint32, ids.ID) error
}

// getter implementation
type getter struct{}

// New creates a new getter
func New() Getter <span class="cov0" title="0">{
        return &amp;getter{}
}</span>

// Get gets a block
func (g *getter) Get(ctx context.Context, nodeID ids.NodeID, requestID uint32, blockID ids.ID) error <span class="cov0" title="0">{
        return nil
}</span>

// GetAncestors gets ancestors
func (g *getter) GetAncestors(ctx context.Context, nodeID ids.NodeID, requestID uint32, blockID ids.ID, maxBlocks int) error <span class="cov0" title="0">{
        return nil
}</span>

// Put puts a block
func (g *getter) Put(ctx context.Context, nodeID ids.NodeID, requestID uint32, block []byte) error <span class="cov0" title="0">{
        return nil
}</span>

// PushQuery pushes a query
func (g *getter) PushQuery(ctx context.Context, nodeID ids.NodeID, requestID uint32, block []byte) error <span class="cov0" title="0">{
        return nil
}</span>

// PullQuery pulls a query
func (g *getter) PullQuery(ctx context.Context, nodeID ids.NodeID, requestID uint32, blockID ids.ID) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// Copyright (C) 2019-2024, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

//go:build cgo &amp;&amp; !zmq
// +build cgo,!zmq

package core

// cgoAvailable returns true when CGO is enabled (but ZMQ is not required)
func cgoAvailable() bool <span class="cov0" title="0">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">// Copyright (C) 2019-2024, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

//go:build cgo
// +build cgo

package core

import (
        "sync"
        "sync/atomic"

        "github.com/luxfi/ids"
)

// CGOConsensus is a CGO-based implementation of consensus
// For now, it's the same as the pure Go implementation
type CGOConsensus struct {
        mu         sync.RWMutex
        preference atomic.Value // ids.ID
        finalized  atomic.Bool

        // Cache for blocks
        blockCache map[ids.ID]*cachedBlock
        cacheMu    sync.RWMutex

        // Store parameters for later retrieval
        params ConsensusParams

        // Consensus state
        accepted map[ids.ID]bool
}

// cachedBlock stores block data
type cachedBlock struct {
        id        ids.ID
        parentID  ids.ID
        height    uint64
        timestamp int64
        data      []byte
        status    BlockStatus
}

// NewCGOConsensus creates a new CGO consensus engine
func NewCGOConsensus(params ConsensusParams) (*CGOConsensus, error) <span class="cov8" title="1">{
        c := &amp;CGOConsensus{
                blockCache: make(map[ids.ID]*cachedBlock, params.MaxOutstandingItems),
                params:     params,
                accepted:   make(map[ids.ID]bool),
        }

        // Set initial preference to empty ID
        c.preference.Store(ids.Empty)

        return c, nil
}</span>

// Add adds a block to consensus
func (c *CGOConsensus) Add(block Block) error <span class="cov8" title="1">{
        c.cacheMu.Lock()
        defer c.cacheMu.Unlock()

        blockID := block.ID()

        // Cache the block
        c.blockCache[blockID] = &amp;cachedBlock{
                id:        blockID,
                parentID:  block.ParentID(),
                height:    block.Height(),
                timestamp: block.Timestamp(),
                data:      block.Bytes(),
                status:    StatusProcessing,
        }

        // Update preference to latest block
        c.preference.Store(blockID)

        return nil
}</span>

// RecordPoll records a poll result
func (c *CGOConsensus) RecordPoll(blockID ids.ID, accept bool) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if accept </span><span class="cov8" title="1">{
                c.accepted[blockID] = true
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsAccepted checks if a block is accepted
func (c *CGOConsensus) IsAccepted(blockID ids.ID) bool <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        return c.accepted[blockID]
}</span>

// GetPreference returns the current preference
func (c *CGOConsensus) GetPreference() ids.ID <span class="cov8" title="1">{
        pref := c.preference.Load()
        if pref == nil </span><span class="cov0" title="0">{
                return ids.Empty
        }</span>
        <span class="cov8" title="1">return pref.(ids.ID)</span>
}

// Finalized checks if consensus is finalized
func (c *CGOConsensus) Finalized() bool <span class="cov8" title="1">{
        return c.finalized.Load()
}</span>

// Parameters returns consensus parameters
func (c *CGOConsensus) Parameters() ConsensusParams <span class="cov8" title="1">{
        return c.params
}</span>

// HealthCheck performs a health check
func (c *CGOConsensus) HealthCheck() error <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright (C) 2019-2024, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

//go:build cgo
// +build cgo

package core

// ConsensusFactory creates the appropriate consensus implementation
// This is the CGO version when CGO is enabled
type ConsensusFactory struct{}

// NewConsensusFactory creates a new consensus factory
func NewConsensusFactory() *ConsensusFactory <span class="cov0" title="0">{
        return &amp;ConsensusFactory{}
}</span>

// CreateConsensus creates a consensus engine instance
func (f *ConsensusFactory) CreateConsensus(params ConsensusParams) (Consensus, error) <span class="cov0" title="0">{
        // Use the existing consensus implementation
        return NewCGOConsensus(params)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package common

import "errors"

// Common errors
var (
        ErrUndefined = errors.New("undefined error")
)

// AppError represents an application error
type AppError struct {
        Code    int32
        Message string
}

// Error returns the error message
func (e *AppError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright (C) 2019-2024, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

package common

import "github.com/luxfi/ids"

// Message represents a network message
type Message struct {
        Type    MessageType
        NodeID  ids.NodeID
        Content []byte
}

// MessageType defines the type of a message
type MessageType uint32

// String returns the string representation of the message type
func (m MessageType) String() string <span class="cov0" title="0">{
        switch m </span>{
        case PendingTxs:<span class="cov0" title="0">
                return "PendingTxs"</span>
        case PutBlock:<span class="cov0" title="0">
                return "PutBlock"</span>
        case GetBlock:<span class="cov0" title="0">
                return "GetBlock"</span>
        case GetAccepted:<span class="cov0" title="0">
                return "GetAccepted"</span>
        case Accepted:<span class="cov0" title="0">
                return "Accepted"</span>
        case GetAncestors:<span class="cov0" title="0">
                return "GetAncestors"</span>
        case MultiPut:<span class="cov0" title="0">
                return "MultiPut"</span>
        case GetFailed:<span class="cov0" title="0">
                return "GetFailed"</span>
        case QueryFailed:<span class="cov0" title="0">
                return "QueryFailed"</span>
        case Chits:<span class="cov0" title="0">
                return "Chits"</span>
        case ChitsV2:<span class="cov0" title="0">
                return "ChitsV2"</span>
        case GetAcceptedFrontier:<span class="cov0" title="0">
                return "GetAcceptedFrontier"</span>
        case AcceptedFrontier:<span class="cov0" title="0">
                return "AcceptedFrontier"</span>
        case GetAcceptedFrontierFailed:<span class="cov0" title="0">
                return "GetAcceptedFrontierFailed"</span>
        case AppRequest:<span class="cov0" title="0">
                return "AppRequest"</span>
        case AppResponse:<span class="cov0" title="0">
                return "AppResponse"</span>
        case AppGossip:<span class="cov0" title="0">
                return "AppGossip"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

const (
        // PendingTxs indicates pending transactions
        PendingTxs MessageType = iota
        // PutBlock indicates a block to be added
        PutBlock
        // GetBlock indicates a request for a block
        GetBlock
        // GetAccepted indicates a request for accepted blocks
        GetAccepted
        // Accepted indicates an accepted block
        Accepted
        // GetAncestors indicates a request for ancestors
        GetAncestors
        // MultiPut indicates multiple blocks
        MultiPut
        // GetFailed indicates a failed get request
        GetFailed
        // QueryFailed indicates a failed query
        QueryFailed
        // Chits indicates chits message
        Chits
        // ChitsV2 indicates chits v2 message
        ChitsV2
        // GetAcceptedFrontier indicates a request for accepted frontier
        GetAcceptedFrontier
        // AcceptedFrontier indicates accepted frontier
        AcceptedFrontier
        // GetAcceptedFrontierFailed indicates a failed frontier request
        GetAcceptedFrontierFailed
        // AppRequest indicates an app request
        AppRequest
        // AppResponse indicates an app response
        AppResponse
        // AppGossip indicates app gossip
        AppGossip
)
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package coremock provides mock implementations for core consensus
package coremock

import "context"

// MockConsensus provides a mock implementation for consensus
type MockConsensus struct {
        decided bool
        result  int
}

// NewMockConsensus creates a new mock consensus
func NewMockConsensus() *MockConsensus <span class="cov0" title="0">{
        return &amp;MockConsensus{
                decided: false,
                result:  0,
        }
}</span>

// Decide makes a consensus decision
func (m *MockConsensus) Decide(ctx context.Context, value int) error <span class="cov0" title="0">{
        m.decided = true
        m.result = value
        return nil
}</span>

// IsDecided returns whether consensus has been reached
func (m *MockConsensus) IsDecided() bool <span class="cov0" title="0">{
        return m.decided
}</span>

// Result returns the consensus result
func (m *MockConsensus) Result() int <span class="cov0" title="0">{
        return m.result
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package tracker

import (
        "github.com/luxfi/ids"
)

// Tracker tracks consensus state
type Tracker interface {
        // IsBootstrapped checks if bootstrapped
        IsBootstrapped() bool

        // Bootstrapped marks as bootstrapped
        Bootstrapped(ids.ID)

        // OnBootstrapCompleted called when bootstrap completes
        OnBootstrapCompleted() chan ids.ID
}

// tracker implementation
type tracker struct {
        bootstrapped bool
        completed    chan ids.ID
}

// NewTracker creates a new tracker
func NewTracker() Tracker <span class="cov0" title="0">{
        return &amp;tracker{
                completed: make(chan ids.ID, 1),
        }
}</span>

// IsBootstrapped checks if bootstrapped
func (t *tracker) IsBootstrapped() bool <span class="cov0" title="0">{
        return t.bootstrapped
}</span>

// Bootstrapped marks as bootstrapped
func (t *tracker) Bootstrapped(chainID ids.ID) <span class="cov0" title="0">{
        t.bootstrapped = true
        select </span>{
        case t.completed &lt;- chainID:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0"></span>
        }
}

// OnBootstrapCompleted returns completion channel
func (t *tracker) OnBootstrapCompleted() chan ids.ID <span class="cov0" title="0">{
        return t.completed
}</span>
</pre>
		
		<pre class="file" id="file44" style="display: none">package bootstrap

import (
        "context"

        "github.com/luxfi/ids"
)

// Version represents protocol version
type Version uint32

// Bootstrapper bootstraps a DAG
type Bootstrapper interface {
        // Start starts bootstrapping
        Start(context.Context, uint32) error

        // Connected notifies the bootstrapper of a connected validator
        Connected(context.Context, ids.NodeID, Version) error

        // Disconnected notifies the bootstrapper of a disconnected validator
        Disconnected(context.Context, ids.NodeID) error

        // HealthCheck performs a health check
        HealthCheck(context.Context) (interface{}, error)
}

// bootstrapper implementation
type bootstrapper struct {
        started bool
}

// New creates a new bootstrapper
func New() Bootstrapper <span class="cov0" title="0">{
        return &amp;bootstrapper{}
}</span>

// Start starts bootstrapping
func (b *bootstrapper) Start(ctx context.Context, requestID uint32) error <span class="cov0" title="0">{
        b.started = true
        return nil
}</span>

// Connected notifies the bootstrapper of a connected validator
func (b *bootstrapper) Connected(ctx context.Context, nodeID ids.NodeID, version Version) error <span class="cov0" title="0">{
        return nil
}</span>

// Disconnected notifies the bootstrapper of a disconnected validator
func (b *bootstrapper) Disconnected(ctx context.Context, nodeID ids.NodeID) error <span class="cov0" title="0">{
        return nil
}</span>

// HealthCheck performs a health check
func (b *bootstrapper) HealthCheck(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{"started": b.started}, nil
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package queue

import (
        "container/heap"

        "github.com/luxfi/ids"
)

// Job represents a bootstrap job
type Job interface {
        ID() ids.ID
        Priority() uint64
        Execute() error
}

// Queue is a priority queue for jobs
type Queue interface {
        // Push adds a job
        Push(Job)

        // Pop removes highest priority job
        Pop() Job

        // Len returns queue length
        Len() int

        // Has checks if job exists
        Has(ids.ID) bool
}

// priorityQueue implements heap.Interface
type priorityQueue []Job

func (pq priorityQueue) Len() int <span class="cov0" title="0">{ return len(pq) }</span>

func (pq priorityQueue) Less(i, j int) bool <span class="cov0" title="0">{
        return pq[i].Priority() &gt; pq[j].Priority()
}</span>

func (pq priorityQueue) Swap(i, j int) <span class="cov0" title="0">{
        pq[i], pq[j] = pq[j], pq[i]
}</span>

func (pq *priorityQueue) Push(x interface{}) <span class="cov0" title="0">{
        *pq = append(*pq, x.(Job))
}</span>

func (pq *priorityQueue) Pop() interface{} <span class="cov0" title="0">{
        old := *pq
        n := len(old)
        item := old[n-1]
        *pq = old[0 : n-1]
        return item
}</span>

// queue implementation
type queue struct {
        pq   priorityQueue
        jobs map[ids.ID]Job
}

// NewQueue creates a new queue
func NewQueue() Queue <span class="cov0" title="0">{
        q := &amp;queue{
                jobs: make(map[ids.ID]Job),
        }
        heap.Init(&amp;q.pq)
        return q
}</span>

// Push adds a job
func (q *queue) Push(job Job) <span class="cov0" title="0">{
        if _, exists := q.jobs[job.ID()]; !exists </span><span class="cov0" title="0">{
                heap.Push(&amp;q.pq, job)
                q.jobs[job.ID()] = job
        }</span>
}

// Pop removes highest priority job
func (q *queue) Pop() Job <span class="cov0" title="0">{
        if q.pq.Len() == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">job := heap.Pop(&amp;q.pq).(Job)
        delete(q.jobs, job.ID())
        return job</span>
}

// Len returns queue length
func (q *queue) Len() int <span class="cov0" title="0">{
        return q.pq.Len()
}</span>

// Has checks if job exists
func (q *queue) Has(id ids.ID) bool <span class="cov0" title="0">{
        _, exists := q.jobs[id]
        return exists
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">// Copyright (C) 2019-2024, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

package dag

import (
        "context"

        "github.com/luxfi/ids"
)

// Transaction represents a DAG transaction
type Transaction interface {
        ID() ids.ID
        Parent() ids.ID
        Height() uint64
        Bytes() []byte
        Verify(context.Context) error
        Accept(context.Context) error
        Reject(context.Context) error
}

// Engine defines the DAG consensus engine interface
type Engine interface {
        // GetVtx gets a vertex by ID
        GetVtx(context.Context, ids.ID) (Transaction, error)

        // BuildVtx builds a new vertex
        BuildVtx(context.Context) (Transaction, error)

        // ParseVtx parses a vertex from bytes
        ParseVtx(context.Context, []byte) (Transaction, error)

        // Start starts the engine
        Start(context.Context, uint32) error

        // Shutdown shuts down the engine
        Shutdown(context.Context) error
}

// dagEngine implements the Engine interface
type dagEngine struct{}

// New creates a new DAG engine
func New() Engine <span class="cov8" title="1">{
        return &amp;dagEngine{}
}</span>

func (e *dagEngine) GetVtx(ctx context.Context, id ids.ID) (Transaction, error) <span class="cov8" title="1">{
        return nil, nil
}</span>

func (e *dagEngine) BuildVtx(ctx context.Context) (Transaction, error) <span class="cov8" title="1">{
        return nil, nil
}</span>

func (e *dagEngine) ParseVtx(ctx context.Context, b []byte) (Transaction, error) <span class="cov8" title="1">{
        return nil, nil
}</span>

func (e *dagEngine) Start(ctx context.Context, requestID uint32) error <span class="cov8" title="1">{
        return nil
}</span>

func (e *dagEngine) Shutdown(ctx context.Context) error <span class="cov8" title="1">{
        return nil
}</span>

// Stop stops the engine (alias for Shutdown for interface compatibility)
func (e *dagEngine) Stop(ctx context.Context) error <span class="cov0" title="0">{
        return e.Shutdown(ctx)
}</span>

// HealthCheck performs a health check
func (e *dagEngine) HealthCheck(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{
        return map[string]string{"status": "healthy"}, nil
}</span>

// IsBootstrapped returns whether the engine is bootstrapped
func (e *dagEngine) IsBootstrapped() bool <span class="cov0" title="0">{
        return true
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package getter

import (
        "context"

        "github.com/luxfi/ids"
)

// Getter gets vertices
type Getter interface {
        // Get gets a vertex
        Get(context.Context, ids.NodeID, uint32, ids.ID) error

        // GetAncestors gets ancestors
        GetAncestors(context.Context, ids.NodeID, uint32, ids.ID, int) error

        // Put puts a vertex
        Put(context.Context, ids.NodeID, uint32, []byte) error

        // PushQuery pushes a query
        PushQuery(context.Context, ids.NodeID, uint32, []byte) error

        // PullQuery pulls a query
        PullQuery(context.Context, ids.NodeID, uint32, ids.ID) error
}

// getter implementation
type getter struct{}

// New creates a new getter
func New() Getter <span class="cov0" title="0">{
        return &amp;getter{}
}</span>

// Get gets a vertex
func (g *getter) Get(ctx context.Context, nodeID ids.NodeID, requestID uint32, vertexID ids.ID) error <span class="cov0" title="0">{
        return nil
}</span>

// GetAncestors gets ancestors
func (g *getter) GetAncestors(ctx context.Context, nodeID ids.NodeID, requestID uint32, vertexID ids.ID, maxVertices int) error <span class="cov0" title="0">{
        return nil
}</span>

// Put puts a vertex
func (g *getter) Put(ctx context.Context, nodeID ids.NodeID, requestID uint32, vertex []byte) error <span class="cov0" title="0">{
        return nil
}</span>

// PushQuery pushes a query
func (g *getter) PushQuery(ctx context.Context, nodeID ids.NodeID, requestID uint32, vertex []byte) error <span class="cov0" title="0">{
        return nil
}</span>

// PullQuery pulls a query
func (g *getter) PullQuery(ctx context.Context, nodeID ids.NodeID, requestID uint32, vertexID ids.ID) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package state

import (
        "github.com/luxfi/ids"
)

// State represents DAG state
type State interface {
        // GetVertex gets a vertex
        GetVertex(ids.ID) (Vertex, error)

        // AddVertex adds a vertex
        AddVertex(Vertex) error

        // VertexIssued checks if vertex issued
        VertexIssued(Vertex) bool

        // IsProcessing checks if processing
        IsProcessing(ids.ID) bool
}

// Vertex represents a DAG vertex
type Vertex interface {
        ID() ids.ID
        ParentIDs() []ids.ID
        Height() uint64
        Bytes() []byte
}

// state implementation
type state struct {
        vertices   map[ids.ID]Vertex
        processing map[ids.ID]bool
}

// New creates a new state
func New() State <span class="cov0" title="0">{
        return &amp;state{
                vertices:   make(map[ids.ID]Vertex),
                processing: make(map[ids.ID]bool),
        }
}</span>

// GetVertex gets a vertex
func (s *state) GetVertex(id ids.ID) (Vertex, error) <span class="cov0" title="0">{
        vertex, exists := s.vertices[id]
        if !exists </span><span class="cov0" title="0">{
                return nil, ErrVertexNotFound
        }</span>
        <span class="cov0" title="0">return vertex, nil</span>
}

// AddVertex adds a vertex
func (s *state) AddVertex(vertex Vertex) error <span class="cov0" title="0">{
        s.vertices[vertex.ID()] = vertex
        return nil
}</span>

// VertexIssued checks if vertex issued
func (s *state) VertexIssued(vertex Vertex) bool <span class="cov0" title="0">{
        _, exists := s.vertices[vertex.ID()]
        return exists
}</span>

// IsProcessing checks if processing
func (s *state) IsProcessing(id ids.ID) bool <span class="cov0" title="0">{
        return s.processing[id]
}</span>

// ErrVertexNotFound is returned when vertex not found
var ErrVertexNotFound = &amp;vertexNotFoundError{}

type vertexNotFoundError struct{}

func (e *vertexNotFoundError) Error() string <span class="cov0" title="0">{
        return "vertex not found"
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">// Package enginetest provides test utilities for consensus engines
package enginetest

import "context"

// TestEngine provides a test implementation for consensus engines
type TestEngine struct {
        started bool
        height  uint64
}

// NewTestEngine creates a new test engine
func NewTestEngine() *TestEngine <span class="cov0" title="0">{
        return &amp;TestEngine{
                started: false,
                height:  0,
        }
}</span>

// Start starts the test engine
func (t *TestEngine) Start(ctx context.Context) error <span class="cov0" title="0">{
        t.started = true
        return nil
}</span>

// Stop stops the test engine
func (t *TestEngine) Stop(ctx context.Context) error <span class="cov0" title="0">{
        t.started = false
        return nil
}</span>

// IsStarted returns whether the engine is started
func (t *TestEngine) IsStarted() bool <span class="cov0" title="0">{
        return t.started
}</span>

// Height returns the current height
func (t *TestEngine) Height() uint64 <span class="cov0" title="0">{
        return t.height
}</span>

// SetHeight sets the engine height
func (t *TestEngine) SetHeight(height uint64) <span class="cov0" title="0">{
        t.height = height
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package bootstrap

import (
        "context"

        "github.com/luxfi/ids"
)

// Version represents protocol version
type Version uint32

// Bootstrapper bootstraps a post-quantum chain
type Bootstrapper interface {
        // Start starts bootstrapping
        Start(context.Context, uint32) error

        // Connected notifies the bootstrapper of a connected validator
        Connected(context.Context, ids.NodeID, Version) error

        // Disconnected notifies the bootstrapper of a disconnected validator
        Disconnected(context.Context, ids.NodeID) error

        // HealthCheck performs a health check
        HealthCheck(context.Context) (interface{}, error)

        // VerifyQuantumCredentials verifies node's quantum credentials
        VerifyQuantumCredentials(context.Context, ids.NodeID, []byte) error
}

// bootstrapper implementation
type bootstrapper struct {
        started   bool
        algorithm string
}

// New creates a new post-quantum bootstrapper
func New(algorithm string) Bootstrapper <span class="cov0" title="0">{
        return &amp;bootstrapper{
                algorithm: algorithm,
        }
}</span>

// Start starts bootstrapping
func (b *bootstrapper) Start(ctx context.Context, requestID uint32) error <span class="cov0" title="0">{
        b.started = true
        return nil
}</span>

// Connected notifies the bootstrapper of a connected validator
func (b *bootstrapper) Connected(ctx context.Context, nodeID ids.NodeID, version Version) error <span class="cov0" title="0">{
        return nil
}</span>

// Disconnected notifies the bootstrapper of a disconnected validator
func (b *bootstrapper) Disconnected(ctx context.Context, nodeID ids.NodeID) error <span class="cov0" title="0">{
        return nil
}</span>

// HealthCheck performs a health check
func (b *bootstrapper) HealthCheck(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "started":   b.started,
                "algorithm": b.algorithm,
        }, nil
}</span>

// VerifyQuantumCredentials verifies node's quantum credentials
func (b *bootstrapper) VerifyQuantumCredentials(ctx context.Context, nodeID ids.NodeID, credentials []byte) error <span class="cov0" title="0">{
        // Verify post-quantum credentials
        return nil
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">// Package pq implements the post-quantum consensus engine that combines
// classical and quantum-resistant consensus mechanisms.
package pq

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/luxfi/consensus/config"
        "github.com/luxfi/consensus/core/dag"
        "github.com/luxfi/consensus/protocol/quasar"
        "github.com/luxfi/ids"
)

// ConsensusEngine implements post-quantum consensus combining classical and quantum-resistant security
type ConsensusEngine struct {
        params   config.Parameters
        quasar   *quasar.Quasar
        finality chan FinalityEvent
        mu       sync.RWMutex

        // State tracking
        height    uint64
        round     uint64
        finalized map[ids.ID]bool
}

// FinalityEvent represents a finalized block with quantum-resistant proofs
type FinalityEvent struct {
        Height    uint64
        BlockID   ids.ID
        Timestamp time.Time
        PQProof   []byte // Post-quantum proof
        BLSProof  []byte // Classical BLS proof
}

// memoryStore is a simple in-memory implementation of dag.Store for P-Chain vertices
type memoryStore struct {
        vertices map[quasar.VertexID]*memoryVertex
        heads    []quasar.VertexID
        mu       sync.RWMutex
}

type memoryVertex struct {
        id       quasar.VertexID
        parents  []quasar.VertexID
        author   string
        round    uint64
        children []quasar.VertexID
}

func (v *memoryVertex) ID() quasar.VertexID        <span class="cov0" title="0">{ return v.id }</span>
func (v *memoryVertex) Parents() []quasar.VertexID <span class="cov0" title="0">{ return v.parents }</span>
func (v *memoryVertex) Author() string             <span class="cov0" title="0">{ return v.author }</span>
func (v *memoryVertex) Round() uint64              <span class="cov0" title="0">{ return v.round }</span>

func (s *memoryStore) Head() []quasar.VertexID <span class="cov0" title="0">{
        if s.vertices == nil </span><span class="cov0" title="0">{
                s.vertices = make(map[quasar.VertexID]*memoryVertex)
        }</span>
        <span class="cov0" title="0">s.mu.RLock()
        defer s.mu.RUnlock()
        result := make([]quasar.VertexID, len(s.heads))
        copy(result, s.heads)
        return result</span>
}

func (s *memoryStore) Get(id quasar.VertexID) (dag.BlockView[quasar.VertexID], bool) <span class="cov0" title="0">{
        if s.vertices == nil </span><span class="cov0" title="0">{
                s.vertices = make(map[quasar.VertexID]*memoryVertex)
        }</span>
        <span class="cov0" title="0">s.mu.RLock()
        defer s.mu.RUnlock()
        vertex, exists := s.vertices[id]
        return vertex, exists</span>
}

func (s *memoryStore) Children(id quasar.VertexID) []quasar.VertexID <span class="cov0" title="0">{
        if s.vertices == nil </span><span class="cov0" title="0">{
                s.vertices = make(map[quasar.VertexID]*memoryVertex)
        }</span>
        <span class="cov0" title="0">s.mu.RLock()
        defer s.mu.RUnlock()
        if vertex, exists := s.vertices[id]; exists </span><span class="cov0" title="0">{
                result := make([]quasar.VertexID, len(vertex.children))
                copy(result, vertex.children)
                return result
        }</span>
        <span class="cov0" title="0">return []quasar.VertexID{}</span>
}

// NewConsensus creates a new post-quantum consensus engine
func NewConsensus(params config.Parameters) *ConsensusEngine <span class="cov8" title="1">{
        // Create a simple in-memory store for P-Chain vertices
        // TODO: Use proper persistent storage in production
        store := &amp;memoryStore{}

        return &amp;ConsensusEngine{
                params:    params,
                quasar:    quasar.New(params, store),
                finality:  make(chan FinalityEvent, 100),
                finalized: make(map[ids.ID]bool),
        }
}</span>

// Initialize sets up the PQ engine with keys
func (e *ConsensusEngine) Initialize(ctx context.Context, blsKey, pqKey []byte) error <span class="cov8" title="1">{
        return e.quasar.Initialize(ctx, blsKey, pqKey)
}</span>

// ProcessBlock processes a block through PQ consensus
func (e *ConsensusEngine) ProcessBlock(ctx context.Context, blockID ids.ID, votes map[string]int) error <span class="cov8" title="1">{
        e.mu.Lock()
        defer e.mu.Unlock()

        // Check if already finalized
        if e.finalized[blockID] </span><span class="cov8" title="1">{
                return nil
        }</span>

        // For now, use simplified consensus logic
        // In production, this would integrate with quasar's internal methods
        <span class="cov8" title="1">totalVotes := 0
        maxVotes := 0
        bestBlock := ""

        for block, count := range votes </span><span class="cov8" title="1">{
                totalVotes += count
                if count &gt; maxVotes </span><span class="cov8" title="1">{
                        maxVotes = count
                        bestBlock = block
                }</span>
        }

        // Check if we have enough votes for the best block
        <span class="cov8" title="1">if totalVotes == 0 || float64(maxVotes)/float64(totalVotes) &lt; e.params.Alpha </span><span class="cov8" title="1">{
                return fmt.Errorf("insufficient votes for finality: %d/%d for block %s", maxVotes, totalVotes, bestBlock)
        }</span>

        // Create mock certificate
        <span class="cov8" title="1">cert := &amp;quasar.CertBundle{
                BLSAgg: []byte("mock-bls-aggregate"),
                PQCert: []byte("mock-pq-certificate"),
        }

        // Validate certificate (placeholder logic)
        if len(cert.BLSAgg) == 0 &amp;&amp; len(cert.PQCert) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("insufficient votes for finality")
        }</span>

        // Mark as finalized
        <span class="cov8" title="1">e.finalized[blockID] = true
        e.height++

        // Emit finality event
        select </span>{
        case e.finality &lt;- FinalityEvent{
                Height:    e.height,
                BlockID:   blockID,
                Timestamp: time.Now(),
                PQProof:   cert.PQCert,
                BLSProof:  cert.BLSAgg,
        }:<span class="cov8" title="1"></span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
                // Channel full, drop oldest
        }

        <span class="cov8" title="1">return nil</span>
}

// IsFinalized checks if a block has achieved PQ finality
func (e *ConsensusEngine) IsFinalized(blockID ids.ID) bool <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        return e.finalized[blockID]
}</span>

// FinalityChannel returns the channel for finality events
func (e *ConsensusEngine) FinalityChannel() &lt;-chan FinalityEvent <span class="cov8" title="1">{
        return e.finality
}</span>

// Height returns the current finalized height
func (e *ConsensusEngine) Height() uint64 <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()
        return e.height
}</span>

// SetFinalizedCallback sets a callback for finalized blocks
func (e *ConsensusEngine) SetFinalizedCallback(cb func(FinalityEvent)) <span class="cov8" title="1">{
        e.quasar.SetFinalizedCallback(func(qb quasar.QBlock) </span><span class="cov0" title="0">{
                blockID, _ := ids.FromString(qb.Hash)
                cb(FinalityEvent{
                        Height:    uint64(qb.Height),
                        BlockID:   blockID,
                        Timestamp: qb.Timestamp,
                        PQProof:   qb.Cert.PQCert,
                        BLSProof:  qb.Cert.BLSAgg,
                })
        }</span>)
}

// Metrics returns engine metrics
func (e *ConsensusEngine) Metrics() map[string]interface{} <span class="cov8" title="1">{
        e.mu.RLock()
        defer e.mu.RUnlock()

        return map[string]interface{}{
                "height":     e.height,
                "round":      e.round,
                "finalized":  len(e.finalized),
                "k":          e.params.K,
                "alpha":      e.params.Alpha,
                "beta":       e.params.Beta,
                "block_time": e.params.BlockTime.String(),
        }
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package pq

import (
        "context"

        "github.com/luxfi/ids"
)

// Engine defines the post-quantum consensus engine
type Engine interface {
        // Start starts the engine
        Start(context.Context, uint32) error

        // Stop stops the engine
        Stop(context.Context) error

        // HealthCheck performs a health check
        HealthCheck(context.Context) (interface{}, error)

        // IsBootstrapped returns whether the engine is bootstrapped
        IsBootstrapped() bool

        // VerifyQuantumSignature verifies a post-quantum signature
        VerifyQuantumSignature([]byte, []byte, []byte) error

        // GenerateQuantumProof generates a quantum-resistant proof
        GenerateQuantumProof(context.Context, ids.ID) ([]byte, error)
}

// PostQuantum implements post-quantum consensus engine
type PostQuantum struct {
        bootstrapped bool
        algorithm    string // ML-DSA, ML-KEM, etc.
}

// New creates a new post-quantum consensus engine
func New() *PostQuantum <span class="cov8" title="1">{
        return &amp;PostQuantum{
                bootstrapped: false,
                algorithm:    "ML-DSA-65", // Default to ML-DSA-65
        }
}</span>

// Start starts the engine
func (pq *PostQuantum) Start(ctx context.Context, requestID uint32) error <span class="cov0" title="0">{
        pq.bootstrapped = true
        return nil
}</span>

// Stop stops the engine
func (pq *PostQuantum) Stop(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// HealthCheck performs a health check
func (pq *PostQuantum) HealthCheck(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "healthy":   true,
                "algorithm": pq.algorithm,
        }, nil
}</span>

// IsBootstrapped returns whether the engine is bootstrapped
func (pq *PostQuantum) IsBootstrapped() bool <span class="cov0" title="0">{
        return pq.bootstrapped
}</span>

// VerifyQuantumSignature verifies a post-quantum signature
func (pq *PostQuantum) VerifyQuantumSignature(message, signature, publicKey []byte) error <span class="cov0" title="0">{
        // Implementation would use the configured post-quantum algorithm
        return nil
}</span>

// GenerateQuantumProof generates a quantum-resistant proof
func (pq *PostQuantum) GenerateQuantumProof(ctx context.Context, blockID ids.ID) ([]byte, error) <span class="cov0" title="0">{
        // Implementation would generate proof using post-quantum cryptography
        return []byte{}, nil
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">// Package main demonstrates integration between consensus and node packages
package main

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/luxfi/consensus/engine/core"
        "github.com/luxfi/ids"
)

// Example block for demonstration
type ExampleBlock struct {
        id        ids.ID
        parentID  ids.ID
        height    uint64
        timestamp int64
        data      []byte
}

func (b *ExampleBlock) ID() ids.ID          <span class="cov0" title="0">{ return b.id }</span>
func (b *ExampleBlock) ParentID() ids.ID    <span class="cov0" title="0">{ return b.parentID }</span>
func (b *ExampleBlock) Height() uint64      <span class="cov0" title="0">{ return b.height }</span>
func (b *ExampleBlock) Timestamp() int64    <span class="cov0" title="0">{ return b.timestamp }</span>
func (b *ExampleBlock) Bytes() []byte       <span class="cov0" title="0">{ return b.data }</span>
func (b *ExampleBlock) Verify(context.Context) error  <span class="cov0" title="0">{ return nil }</span>
func (b *ExampleBlock) Accept(context.Context) error  <span class="cov0" title="0">{ 
        fmt.Printf("Block %s accepted at height %d\n", b.id, b.height)
        return nil 
}</span>
func (b *ExampleBlock) Reject(context.Context) error  <span class="cov0" title="0">{ 
        fmt.Printf("Block %s rejected\n", b.id)
        return nil 
}</span>

func main() <span class="cov0" title="0">{
        // Configure consensus parameters for fast finality
        params := core.ConsensusParams{
                K:                     20,
                AlphaPreference:      15,
                AlphaConfidence:      15,
                Beta:                 20,
                ConcurrentPolls:      10,
                OptimalProcessing:    10,
                MaxOutstandingItems:  1000,
                MaxItemProcessingTime: 30 * time.Second,
        }

        // Create consensus engine
        consensus, err := core.NewCGOConsensus(params)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create consensus: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Println("✅ Consensus engine initialized")
        fmt.Printf("Parameters: K=%d, Alpha=%d, Beta=%d\n", 
                params.K, params.AlphaPreference, params.Beta)

        // Create a sample block
        block := &amp;ExampleBlock{
                id:        ids.GenerateTestID(),
                parentID:  ids.Empty,
                height:    1,
                timestamp: time.Now().Unix(),
                data:      []byte("Genesis block"),
        }

        // Add block to consensus
        if err := consensus.Add(block); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to add block: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("📦 Added block %s to consensus\n", block.ID())

        // Simulate voting from validators
        fmt.Println("🗳️  Simulating validator votes...")
        for i := 0; i &lt; params.K; i++ </span><span class="cov0" title="0">{
                if err := consensus.RecordPoll(block.ID(), true); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to record vote %d: %v", i, err)
                        continue</span>
                }
                
                // Check if consensus achieved
                <span class="cov0" title="0">if consensus.IsAccepted(block.ID()) </span><span class="cov0" title="0">{
                        fmt.Printf("✅ Consensus achieved after %d votes!\n", i+1)
                        break</span>
                }
        }

        // Verify final state
        <span class="cov0" title="0">if consensus.IsAccepted(block.ID()) </span><span class="cov0" title="0">{
                fmt.Printf("🎉 Block %s has been accepted by consensus\n", block.ID())
                fmt.Printf("Current preference: %s\n", consensus.GetPreference())
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("❌ Block %s was not accepted\n", block.ID())
        }</span>

        // Health check
        <span class="cov0" title="0">if err := consensus.HealthCheck(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Health check failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("💚 Consensus engine health check passed")
        }</span>

        <span class="cov0" title="0">fmt.Println("\n🏁 Node integration example completed successfully!")</span>
}</pre>
		
		<pre class="file" id="file54" style="display: none">package flare

import "github.com/luxfi/consensus/core/dag"

type Decision int

const (
        DecideUndecided Decision = iota
        DecideCommit
        DecideSkip
)

// Cert: &gt;=2f+1 in r+1 support proposer(author,round). Skip: &gt;=2f+1 in r+1 not supporting.
func HasCertificate(v dag.View, proposer dag.Meta, p dag.Params) bool <span class="cov8" title="1">{
        r1 := proposer.Round() + 1
        next := v.ByRound(r1)
        support := 0
        for _, m := range next </span><span class="cov8" title="1">{
                if v.Supports(m.ID(), proposer.Author(), proposer.Round()) </span><span class="cov8" title="1">{
                        support++
                        if support &gt;= 2*p.F+1 </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

func HasSkip(v dag.View, proposer dag.Meta, p dag.Params) bool <span class="cov8" title="1">{
        r1 := proposer.Round() + 1
        next := v.ByRound(r1)
        nos := 0
        for _, m := range next </span><span class="cov8" title="1">{
                if !v.Supports(m.ID(), proposer.Author(), proposer.Round()) </span><span class="cov8" title="1">{
                        nos++
                        if nos &gt;= 2*p.F+1 </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

type Flare struct{ p dag.Params }

func NewFlare(p dag.Params) *Flare <span class="cov8" title="1">{ return &amp;Flare{p: p} }</span>

func (f *Flare) Classify(v dag.View, proposer dag.Meta) Decision <span class="cov8" title="1">{
        switch </span>{
        case HasCertificate(v, proposer, f.p):<span class="cov8" title="1">
                return DecideCommit</span>
        case HasSkip(v, proposer, f.p):<span class="cov0" title="0">
                return DecideSkip</span>
        default:<span class="cov8" title="1">
                return DecideUndecided</span>
        }
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package focus

import (
        "sync"
        "time"
)

// Tracker tracks confidence counters for items
type Tracker[ID comparable] struct {
        mu     sync.RWMutex
        counts map[ID]int
}

func NewTracker[ID comparable]() *Tracker[ID] <span class="cov8" title="1">{
        return &amp;Tracker[ID]{
                counts: make(map[ID]int),
        }
}</span>

func (t *Tracker[ID]) Incr(id ID) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.counts[id]++
}</span>

func (t *Tracker[ID]) Count(id ID) int <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.counts[id]
}</span>

func (t *Tracker[ID]) Reset(id ID) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()
        delete(t.counts, id)
}</span>

// Confidence tracks confidence building for consensus
type Confidence[ID comparable] struct {
        mu        sync.RWMutex
        threshold int
        alpha     float64
        states    map[ID]int
}

func NewConfidence[ID comparable](threshold int, alpha float64) *Confidence[ID] <span class="cov8" title="1">{
        return &amp;Confidence[ID]{
                threshold: threshold,
                alpha:     alpha,
                states:    make(map[ID]int),
        }
}</span>

func (c *Confidence[ID]) Update(id ID, ratio float64) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        current := c.states[id]
        if ratio &gt;= c.alpha </span><span class="cov8" title="1">{
                c.states[id] = current + 1
        }</span> else<span class="cov8" title="1"> if ratio &lt;= 1.0-c.alpha </span><span class="cov8" title="1">{
                c.states[id] = 0 // Reset on opposite preference
        }</span>
}

func (c *Confidence[ID]) State(id ID) (int, bool) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        state := c.states[id]
        decided := state &gt;= c.threshold
        return state, decided
}</span>

// WindowedConfidence tracks confidence with time windows
type WindowedConfidence[ID comparable] struct {
        mu         sync.RWMutex
        threshold  int
        alpha      float64
        window     time.Duration
        states     map[ID]int
        lastUpdate map[ID]time.Time
}

func NewWindowed[ID comparable](threshold int, alpha float64, window time.Duration) *WindowedConfidence[ID] <span class="cov8" title="1">{
        return &amp;WindowedConfidence[ID]{
                threshold:  threshold,
                alpha:      alpha,
                window:     window,
                states:     make(map[ID]int),
                lastUpdate: make(map[ID]time.Time),
        }
}</span>

func (w *WindowedConfidence[ID]) Update(id ID, ratio float64) <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        now := time.Now()
        if last, ok := w.lastUpdate[id]; ok </span><span class="cov8" title="1">{
                if now.Sub(last) &gt; w.window </span><span class="cov0" title="0">{
                        // Window expired, reset
                        w.states[id] = 0
                }</span>
        }

        <span class="cov8" title="1">current := w.states[id]
        if ratio &gt;= w.alpha </span><span class="cov8" title="1">{
                w.states[id] = current + 1
        }</span> else<span class="cov0" title="0"> if ratio &lt;= 1.0-w.alpha </span><span class="cov0" title="0">{
                w.states[id] = 0
        }</span>
        <span class="cov8" title="1">w.lastUpdate[id] = now</span>
}

func (w *WindowedConfidence[ID]) State(id ID) (int, bool) <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        // Check if window expired
        if last, ok := w.lastUpdate[id]; ok </span><span class="cov8" title="1">{
                if time.Since(last) &gt; w.window </span><span class="cov8" title="1">{
                        return 0, false
                }</span>
        }

        <span class="cov8" title="1">state := w.states[id]
        decided := state &gt;= w.threshold
        return state, decided</span>
}

// Calc calculates confidence based on votes
func Calc(yes, total, prev int) (float64, int) <span class="cov8" title="1">{
        if total == 0 </span><span class="cov0" title="0">{
                return 0, prev
        }</span>

        <span class="cov8" title="1">ratio := float64(yes) / float64(total)

        // Calculate new confidence
        var conf int
        if ratio &gt; 0.5 </span><span class="cov8" title="1">{
                conf = yes - (total - yes) // Difference between yes and no
                if conf &lt; 0 </span><span class="cov0" title="0">{
                        conf = 0
                }</span>
        } else<span class="cov8" title="1"> {
                conf = 0
        }</span>

        // Consider previous confidence
        <span class="cov8" title="1">if prev &gt; 0 &amp;&amp; conf &gt; 0 </span><span class="cov8" title="1">{
                conf += prev / 2 // Boost with previous confidence
        }</span>

        <span class="cov8" title="1">return ratio, conf</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package horizon

import (
        "github.com/luxfi/consensus/core/dag"
)

type VertexID [32]byte

type Meta interface {
        ID() VertexID
        Author() string
        Round() uint64
        Parents() []VertexID
}

type View interface {
        Get(VertexID) (Meta, bool)
        ByRound(round uint64) []Meta
        Supports(from VertexID, author string, round uint64) bool
}

type Params struct{ N, F int }

// TransitiveClosure computes the transitive closure of a vertex in the DAG
func TransitiveClosure[V comparable](store dag.Store[V], vertex V) []V <span class="cov8" title="1">{
        // TODO: Implement transitive closure computation
        return []V{vertex}
}</span>

// Certificate represents a proof that a vertex has achieved consensus
type Certificate[V comparable] struct {
        Vertex    V
        Proof     []V
        Threshold int
}

// ValidateCertificate checks if a certificate is valid given a validator function
func ValidateCertificate[V comparable](store dag.Store[V], cert Certificate[V], isValid func(V) bool) bool <span class="cov8" title="1">{
        // TODO: Implement certificate validation
        validCount := 0
        for _, proof := range cert.Proof </span><span class="cov8" title="1">{
                if isValid(proof) </span><span class="cov8" title="1">{
                        validCount++
                }</span>
        }
        <span class="cov8" title="1">return validCount &gt;= cert.Threshold</span>
}

// SkipList represents a skip list data structure for efficient DAG traversal
type SkipList[V comparable] struct {
        Levels map[V][]V
}

// BuildSkipList constructs a skip list from DAG vertices for efficient navigation
func BuildSkipList[V comparable](store dag.Store[V], vertices []V) *SkipList[V] <span class="cov8" title="1">{
        // TODO: Implement skip list construction
        sl := &amp;SkipList[V]{
                Levels: make(map[V][]V),
        }

        // Simple placeholder: each vertex points to its first parent
        for _, v := range vertices </span><span class="cov8" title="1">{
                if block, exists := store.Get(v); exists </span><span class="cov8" title="1">{
                        parents := block.Parents()
                        if len(parents) &gt; 0 </span><span class="cov8" title="1">{
                                sl.Levels[v] = []V{parents[0]}
                        }</span> else<span class="cov0" title="0"> {
                                sl.Levels[v] = []V{}
                        }</span>
                }
        }

        <span class="cov8" title="1">return sl</span>
}

// FindPath finds a path between two vertices in the DAG
func FindPath[V comparable](store dag.Store[V], from, to V) ([]V, bool) <span class="cov8" title="1">{
        // TODO: Implement path finding algorithm
        // Simple placeholder: return single vertex path if vertices exist
        if _, exists1 := store.Get(from); exists1 </span><span class="cov8" title="1">{
                if _, exists2 := store.Get(to); exists2 </span><span class="cov8" title="1">{
                        return []V{from, to}, true
                }</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">// Package routermock provides mock implementations for message routing
package routermock

import (
        "context"

        "github.com/luxfi/consensus/types"
)

// MockRouter provides a mock implementation for message routing
type MockRouter struct {
        routes map[types.NodeID][]Message
}

// Message represents a routed message
type Message struct {
        From    types.NodeID
        To      types.NodeID
        Content []byte
        Type    string
}

// NewMockRouter creates a new mock router
func NewMockRouter() *MockRouter <span class="cov0" title="0">{
        return &amp;MockRouter{
                routes: make(map[types.NodeID][]Message),
        }
}</span>

// RouteMessage routes a message between nodes
func (m *MockRouter) RouteMessage(ctx context.Context, from, to types.NodeID, content []byte, msgType string) error <span class="cov0" title="0">{
        if _, exists := m.routes[to]; !exists </span><span class="cov0" title="0">{
                m.routes[to] = make([]Message, 0)
        }</span>

        <span class="cov0" title="0">m.routes[to] = append(m.routes[to], Message{
                From:    from,
                To:      to,
                Content: content,
                Type:    msgType,
        })

        return nil</span>
}

// GetMessages returns all messages routed to a node
func (m *MockRouter) GetMessages(nodeID types.NodeID) []Message <span class="cov0" title="0">{
        return m.routes[nodeID]
}</span>

// ClearMessages clears all routed messages
func (m *MockRouter) ClearMessages() <span class="cov0" title="0">{
        m.routes = make(map[types.NodeID][]Message)
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">// Package router is DEPRECATED.
// This package should be in the node repository as it's part of the P2P layer, not consensus.
//
// Migration:
//
//        OLD: import "github.com/luxfi/consensus/networking/router"
//        NEW: import "github.com/luxfi/node/network/router"
package router

import (
        "context"
        "errors"

        "github.com/luxfi/node/message"
)

var ErrDeprecated = errors.New("router package should be in github.com/luxfi/node/network/router")

// Deprecated: Implement in node repository
type Router interface {
        Deprecated()
}

// InboundHandler handles inbound messages
type InboundHandler interface {
        HandleInbound(ctx context.Context, msg message.InboundMessage)
}

// InboundHandlerFunc is a function that implements InboundHandler
type InboundHandlerFunc func(ctx context.Context, msg message.InboundMessage)

// HandleInbound implements InboundHandler
func (f InboundHandlerFunc) HandleInbound(ctx context.Context, msg message.InboundMessage) <span class="cov0" title="0">{
        f(ctx, msg)
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">// Package sendertest provides test utilities for message sending
package sendertest

import (
        "context"

        "github.com/luxfi/consensus/types"
)

// TestSender provides a test implementation for message senders
type TestSender struct {
        sentMessages []Message
}

// Message represents a sent message
type Message struct {
        To      types.NodeID
        Content []byte
        Type    string
}

// NewTestSender creates a new test sender
func NewTestSender() *TestSender <span class="cov0" title="0">{
        return &amp;TestSender{
                sentMessages: make([]Message, 0),
        }
}</span>

// SendMessage sends a message to a node
func (t *TestSender) SendMessage(ctx context.Context, to types.NodeID, content []byte, msgType string) error <span class="cov0" title="0">{
        t.sentMessages = append(t.sentMessages, Message{
                To:      to,
                Content: content,
                Type:    msgType,
        })
        return nil
}</span>

// GetSentMessages returns all sent messages
func (t *TestSender) GetSentMessages() []Message <span class="cov0" title="0">{
        return t.sentMessages
}</span>

// ClearMessages clears all sent messages
func (t *TestSender) ClearMessages() <span class="cov0" title="0">{
        t.sentMessages = make([]Message, 0)
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package timeout

import (
        "context"
        "time"

        "github.com/luxfi/ids"
)

// Manager manages timeouts
type Manager interface {
        // RegisterTimeout registers a timeout
        RegisterTimeout(time.Duration) func(context.Context, ids.ID) error

        // RegisterRequest registers a request
        RegisterRequest(ids.NodeID, ids.ID, bool, uint32, func())

        // RegisterResponse registers a response
        RegisterResponse(ids.NodeID, ids.ID, uint32, Op) (bool, func())

        // TimeoutDuration returns timeout duration
        TimeoutDuration() time.Duration
}

// Op represents an operation
type Op byte

const (
        // GetAcceptedFrontier gets accepted frontier
        GetAcceptedFrontier Op = iota
        // AcceptedFrontier is accepted frontier response
        AcceptedFrontier
        // GetAccepted gets accepted
        GetAccepted
        // Accepted is accepted response
        Accepted
        // Get gets an item
        Get
        // Put puts an item
        Put
        // PushQuery pushes a query
        PushQuery
        // PullQuery pulls a query
        PullQuery
        // Chits is chits response
        Chits
)

// manager implementation
type manager struct {
        duration time.Duration
}

// NewManager creates a new timeout manager
func NewManager(duration time.Duration) Manager <span class="cov0" title="0">{
        return &amp;manager{
                duration: duration,
        }
}</span>

// RegisterTimeout registers a timeout
func (m *manager) RegisterTimeout(duration time.Duration) func(context.Context, ids.ID) error <span class="cov0" title="0">{
        return func(ctx context.Context, id ids.ID) error </span><span class="cov0" title="0">{
                return nil
        }</span>
}

// RegisterRequest registers a request
func (m *manager) RegisterRequest(nodeID ids.NodeID, requestID ids.ID, critical bool, uniqueRequestID uint32, callback func()) {<span class="cov0" title="0">
        // Implementation
}</span>

// RegisterResponse registers a response
func (m *manager) RegisterResponse(nodeID ids.NodeID, requestID ids.ID, uniqueRequestID uint32, op Op) (bool, func()) <span class="cov0" title="0">{
        return false, func() </span>{<span class="cov0" title="0">}</span>
}

// TimeoutDuration returns timeout duration
func (m *manager) TimeoutDuration() time.Duration <span class="cov0" title="0">{
        return m.duration
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package tracker

import (
        "time"

        "github.com/luxfi/ids"
)

// NewResourceTracker creates a new resource tracker
func NewResourceTracker(
        cpuHalflife time.Duration,
        diskHalflife time.Duration,
) (ResourceTracker, error) <span class="cov0" title="0">{
        return &amp;resourceTracker{
                cpuUsage:  make(map[ids.NodeID]float64),
                diskUsage: make(map[ids.NodeID]float64),
        }, nil
}</span>

type resourceTracker struct {
        cpuUsage  map[ids.NodeID]float64
        diskUsage map[ids.NodeID]float64
}

func (r *resourceTracker) StartProcessing(nodeID ids.NodeID, startTime time.Time) {<span class="cov0" title="0">
        // Track processing start
}</span>

func (r *resourceTracker) StopProcessing(nodeID ids.NodeID, stopTime time.Time) {<span class="cov0" title="0">
        // Track processing stop
}</span>

func (r *resourceTracker) CPUTracker() CPUTracker <span class="cov0" title="0">{
        return &amp;cpuTracker{usage: r.cpuUsage}
}</span>

func (r *resourceTracker) DiskTracker() DiskTracker <span class="cov0" title="0">{
        return &amp;diskTracker{usage: r.diskUsage}
}</span>

type cpuTracker struct {
        usage map[ids.NodeID]float64
}

func (t *cpuTracker) Usage(nodeID ids.NodeID, requestedTime time.Time) float64 <span class="cov0" title="0">{
        if usage, ok := t.usage[nodeID]; ok </span><span class="cov0" title="0">{
                return usage
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (t *cpuTracker) TimeUntilUsage(nodeID ids.NodeID, requestedTime time.Time, usage float64) time.Duration <span class="cov0" title="0">{
        return 0
}</span>

func (t *cpuTracker) TotalUsage() float64 <span class="cov0" title="0">{
        var total float64
        for _, usage := range t.usage </span><span class="cov0" title="0">{
                total += usage
        }</span>
        <span class="cov0" title="0">return total</span>
}

type diskTracker struct {
        usage map[ids.NodeID]float64
}

func (t *diskTracker) Usage(nodeID ids.NodeID, requestedTime time.Time) float64 <span class="cov0" title="0">{
        if usage, ok := t.usage[nodeID]; ok </span><span class="cov0" title="0">{
                return usage
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (t *diskTracker) TimeUntilUsage(nodeID ids.NodeID, requestedTime time.Time, usage float64) time.Duration <span class="cov0" title="0">{
        return 0
}</span>

func (t *diskTracker) TotalUsage() float64 <span class="cov0" title="0">{
        var total float64
        for _, usage := range t.usage </span><span class="cov0" title="0">{
                total += usage
        }</span>
        <span class="cov0" title="0">return total</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package photon

import "github.com/luxfi/consensus/types"

// Emitter emits consensus messages
type Emitter interface {
        // Emit emits a message to selected nodes
        Emit(msg interface{}) ([]types.NodeID, error)

        // EmitTo emits a message to specific nodes
        EmitTo(nodes []types.NodeID, msg interface{}) error
}

// DefaultEmitterOptions returns default emitter options
func DefaultEmitterOptions() EmitterOptions <span class="cov0" title="0">{
        return EmitterOptions{
                K:       20,
                Fanout:  4,
                Timeout: 1000,
        }
}</span>

// EmitterOptions defines emitter options
type EmitterOptions struct {
        K       int // Committee size
        Fanout  int // Number of nodes to emit to
        Timeout int // Timeout in milliseconds
}

// UniformEmitter implements uniform random emission
type UniformEmitter struct {
        nodes   []types.NodeID
        options EmitterOptions
}

// NewUniformEmitter creates a new uniform emitter
func NewUniformEmitter(nodes []types.NodeID, options EmitterOptions) *UniformEmitter <span class="cov0" title="0">{
        return &amp;UniformEmitter{
                nodes:   nodes,
                options: options,
        }
}</span>

// Emit emits a message to selected nodes
func (e *UniformEmitter) Emit(msg interface{}) ([]types.NodeID, error) <span class="cov0" title="0">{
        // Select random subset of nodes
        selected := make([]types.NodeID, 0, e.options.Fanout)
        for i := 0; i &lt; e.options.Fanout &amp;&amp; i &lt; len(e.nodes); i++ </span><span class="cov0" title="0">{
                selected = append(selected, e.nodes[i])
        }</span>
        <span class="cov0" title="0">return selected, nil</span>
}

// EmitTo emits a message to specific nodes
func (e *UniformEmitter) EmitTo(nodes []types.NodeID, msg interface{}) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package photon

import (
        "github.com/luxfi/consensus/types"
)

// Luminance tracks node brightness based on consensus participation.
// More successful votes = higher lux = brighter emission probability.
type Luminance struct {
        lux map[types.NodeID]float64 // Brightness level per node (in lux units)
}

// NewLuminance creates a new brightness tracker
func NewLuminance() *Luminance <span class="cov0" title="0">{
        return &amp;Luminance{
                lux: make(map[types.NodeID]float64),
        }
}</span>

// Illuminate increases or decreases node brightness based on performance
func (l *Luminance) Illuminate(id types.NodeID, success bool) <span class="cov0" title="0">{
        if _, exists := l.lux[id]; !exists </span><span class="cov0" title="0">{
                l.lux[id] = 100.0 // Base illumination: 100 lux (office lighting)
        }</span>

        <span class="cov0" title="0">if success </span><span class="cov0" title="0">{
                // Successful vote increases brightness (max: 1000 lux = bright daylight)
                l.lux[id] *= 1.1
                if l.lux[id] &gt; 1000.0 </span><span class="cov0" title="0">{
                        l.lux[id] = 1000.0
                }</span>
        } else<span class="cov0" title="0"> {
                // Failed vote dims the node (min: 10 lux = twilight)
                l.lux[id] *= 0.9
                if l.lux[id] &lt; 10.0 </span><span class="cov0" title="0">{
                        l.lux[id] = 10.0
                }</span>
        }
}

// Brightness returns emission weight based on lux level (0.1 to 10.0)
func (l *Luminance) Brightness(id types.NodeID) float64 <span class="cov0" title="0">{
        if lux, exists := l.lux[id]; exists </span><span class="cov0" title="0">{
                return lux / 100.0 // Normalize to base level
        }</span>
        <span class="cov0" title="0">return 1.0</span> // Default brightness
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package prism

import "github.com/luxfi/consensus/types"

// Cut provides random cutting of peers for consensus voting (like a prism cuts light)
type Cut[T comparable] interface {
        // Sample returns k random peers for voting (cuts k rays from the population)
        Sample(k int) []types.NodeID

        // Luminance returns light intensity metrics for the cut
        Luminance() Luminance
}

// Luminance measures the intensity of light across the peer network
// Following SI units: lux (lx) = lumens per square meter
type Luminance struct {
        ActivePeers int
        TotalPeers  int
        Lx          float64 // Illuminance in lux (lx) - minimum 1 lx per active peer/photon
}

// UniformCut implements uniform random cutting
type UniformCut struct {
        peers []types.NodeID
}

// NewUniformCut creates a new uniform cut
func NewUniformCut(peers []types.NodeID) *UniformCut <span class="cov0" title="0">{
        return &amp;UniformCut{peers: peers}
}</span>

// Sample implements Cut interface (cuts k rays from the peer population)
func (c *UniformCut) Sample(k int) []types.NodeID <span class="cov0" title="0">{
        if k &gt;= len(c.peers) </span><span class="cov0" title="0">{
                return c.peers
        }</span>

        // Simple random cutting (in production, use proper randomization)
        // TODO: Implement proper cryptographically secure random cutting
        <span class="cov0" title="0">result := make([]types.NodeID, 0, k)
        for i := 0; i &lt; k &amp;&amp; i &lt; len(c.peers); i++ </span><span class="cov0" title="0">{
                result = append(result, c.peers[i])
        }</span>
        <span class="cov0" title="0">return result</span>
}

// Luminance implements Cut interface
func (c *UniformCut) Luminance() Luminance <span class="cov0" title="0">{
        activePeers := len(c.peers)
        // Minimum 1 lx per active peer/photon, scaling with network health
        lx := float64(activePeers) // Base: 1 lx per peer
        if activePeers &gt;= 100 </span><span class="cov0" title="0">{
                lx = 500.0 // Office lighting level for healthy large networks
        }</span> else<span class="cov0" title="0"> if activePeers &gt;= 20 </span><span class="cov0" title="0">{
                lx = 300.0 // Classroom level for medium networks
        }</span>

        <span class="cov0" title="0">return Luminance{
                ActivePeers: activePeers,
                TotalPeers:  activePeers,
                Lx:          lx,
        }</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package prism

import (
        "context"

        "github.com/luxfi/ids"
)

// Prism consensus interface
type Prism interface {
        // Initialize prism consensus
        Initialize(context.Context, *Config) error

        // Propose proposes a value
        Propose(context.Context, []byte) error

        // Vote votes on a proposal
        Vote(context.Context, ids.ID, bool) error

        // GetProposal gets a proposal
        GetProposal(context.Context, ids.ID) (Proposal, error)
}

// NodeConfig defines prism node configuration
type NodeConfig struct {
        ProposerNodes    int
        VoterNodes       int
        TransactionNodes int
        BlockSize        int
}

// Proposal defines a proposal
type Proposal struct {
        ID       ids.ID
        Height   uint64
        Data     []byte
        Votes    int
        Accepted bool
}

// Engine defines prism consensus engine
type Engine struct {
        config *Config
}

// New creates a new prism engine
func New(config *Config) *Engine <span class="cov0" title="0">{
        return &amp;Engine{
                config: config,
        }
}</span>

// Initialize initializes the engine
func (e *Engine) Initialize(ctx context.Context, config *Config) error <span class="cov0" title="0">{
        e.config = config
        return nil
}</span>

// Propose proposes a value
func (e *Engine) Propose(ctx context.Context, data []byte) error <span class="cov0" title="0">{
        return nil
}</span>

// Vote votes on a proposal
func (e *Engine) Vote(ctx context.Context, proposalID ids.ID, accept bool) error <span class="cov0" title="0">{
        return nil
}</span>

// GetProposal gets a proposal
func (e *Engine) GetProposal(ctx context.Context, proposalID ids.ID) (Proposal, error) <span class="cov0" title="0">{
        return Proposal{}, nil
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package field

import (
        "context"
        "time"

        "github.com/luxfi/consensus/prism"
        "github.com/luxfi/consensus/types"
        "github.com/luxfi/consensus/wave"
)

type VID interface{ comparable } // vertex id

// BlockView is enough for order-theory (parents + metadata).
type BlockView[V VID] interface {
        ID() V
        Parents() []V
        Author() types.NodeID
        Round() uint64
}

// Store exposes local DAG state for cert/skip scans and causal reads.
type Store[V VID] interface {
        Head() []V
        Get(V) (BlockView[V], bool)
        Children(V) []V
}

// Proposer builds a new vertex from frontier + sidecar votes, etc.
type Proposer[V VID] interface {
        Propose(ctx context.Context, parents []V) (V, error)
}

// Committer applies an ordered prefix decided by Field.
type Committer[V VID] interface {
        Commit(ctx context.Context, ordered []V) error
}

type Config struct {
        PollSize int
        Alpha    float64
        Beta     uint32
        RoundTO  time.Duration
}

type Driver[V VID] struct {
        cfg  Config
        wv   wave.Wave[V]
        cut  prism.Cut[V]
        str  Store[V]
        prop Proposer[V]
        com  Committer[V]
}

func NewDriver[V VID](cfg Config, cut prism.Cut[V], tx wave.Transport[V], store Store[V], prop Proposer[V], com Committer[V]) *Driver[V] <span class="cov0" title="0">{
        if cfg.PollSize == 0 </span><span class="cov0" title="0">{
                cfg.PollSize = 20
        }</span>
        <span class="cov0" title="0">if cfg.Alpha == 0 </span><span class="cov0" title="0">{
                cfg.Alpha = 0.8
        }</span>
        <span class="cov0" title="0">if cfg.Beta == 0 </span><span class="cov0" title="0">{
                cfg.Beta = 15
        }</span>
        <span class="cov0" title="0">if cfg.RoundTO == 0 </span><span class="cov0" title="0">{
                cfg.RoundTO = 250 * time.Millisecond
        }</span>

        <span class="cov0" title="0">return &amp;Driver[V]{
                cfg: cfg,
                wv:  wave.New[V](wave.Config{K: cfg.PollSize, Alpha: cfg.Alpha, Beta: cfg.Beta, RoundTO: cfg.RoundTO}, cut, tx),
                cut: cut, str: store, prop: prop, com: com,
        }</span>
}

// OnObserve should be called by your networking layer as new vertices arrive.
// You can also plug DAG fast-path voting (flare) here if you embed it in vertex payloads.
func (d *Driver[V]) OnObserve(ctx context.Context, v V) <span class="cov0" title="0">{
        // optional: run local checks, update sampler health, etc.
        _ = ctx
        _ = v
}</span>

// Tick runs one poll round over DAG heads, looks for cert/skip and commits the safe prefix.
func (d *Driver[V]) Tick(ctx context.Context) error <span class="cov0" title="0">{
        frontier := d.str.Head()
        if len(frontier) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Drive thresholding on frontier candidates
        <span class="cov0" title="0">for _, v := range frontier </span><span class="cov0" title="0">{
                d.wv.Tick(ctx, v)
        }</span>

        // Use DAG order theory to derive commit/skip (cert/skip patterns)
        // TODO: Implement proper type conversion or interface alignment
        <span class="cov0" title="0">ordered := []V{} // dag.ComputeSafePrefix(d.str, frontier) // implement using horizon+flare
        if len(ordered) &gt; 0 </span><span class="cov0" title="0">{
                if err := d.com.Commit(ctx, ordered); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Optionally propose a new vertex extending the frontier
        // TODO: Implement proper type conversion or interface alignment
        // parents := dag.ChooseFrontier(frontier) // e.g., 2f+1 parents or all-recent
        // _, _ = d.prop.Propose(ctx, parents)

        <span class="cov0" title="0">return nil</span>
}

// Start begins the Field engine operation
func (d *Driver[V]) Start(ctx context.Context) error <span class="cov0" title="0">{
        // Field engine is stateless and starts immediately
        return nil
}</span>

// Stop ends the Field engine operation
func (d *Driver[V]) Stop(ctx context.Context) error <span class="cov0" title="0">{
        // Field engine is stateless and stops immediately
        return nil
}</span>

// Propose proposes a new vertex with given parents (Nebula will use this)
func (d *Driver[V]) Propose(ctx context.Context, parents []V) (V, error) <span class="cov0" title="0">{
        return d.prop.Propose(ctx, parents)
}</span>

// GetFrontier returns the current DAG frontier (tips)
func (d *Driver[V]) GetFrontier() []V <span class="cov0" title="0">{
        return d.str.Head()
}</span>

// IsFinalized checks if a vertex is finalized
func (d *Driver[V]) IsFinalized(vertex V) bool <span class="cov0" title="0">{
        if state, exists := d.wv.State(vertex); exists </span><span class="cov0" title="0">{
                return state.Decided &amp;&amp; state.Result == types.DecideAccept
        }</span>
        <span class="cov0" title="0">return false</span>
}

// GetCommittedVertices returns vertices that have been committed in order
func (d *Driver[V]) GetCommittedVertices() []V <span class="cov0" title="0">{
        // TODO: Implement committed vertex tracking
        // This would require maintaining a list of committed vertices from the Committer
        return []V{}
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">package field

// placeholder for epoch/cross-chain features (e.g., checkpoint bundling).
type Service struct{}

func New() *Service <span class="cov8" title="1">{ return &amp;Service{} }</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package flare

import "github.com/luxfi/consensus/core/dag"

type Decision int

const (
        DecideUndecided Decision = iota
        DecideCommit
        DecideSkip
)

// Cert: &gt;=2f+1 in r+1 support proposer(author,round). Skip: &gt;=2f+1 in r+1 not supporting.
func HasCertificate(v dag.View, proposer dag.Meta, p dag.Params) bool <span class="cov8" title="1">{
        r1 := proposer.Round() + 1
        next := v.ByRound(r1)
        support := 0
        for _, m := range next </span><span class="cov8" title="1">{
                if v.Supports(m.ID(), proposer.Author(), proposer.Round()) </span><span class="cov8" title="1">{
                        support++
                        if support &gt;= 2*p.F+1 </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

func HasSkip(v dag.View, proposer dag.Meta, p dag.Params) bool <span class="cov8" title="1">{
        r1 := proposer.Round() + 1
        next := v.ByRound(r1)
        nos := 0
        for _, m := range next </span><span class="cov8" title="1">{
                if !v.Supports(m.ID(), proposer.Author(), proposer.Round()) </span><span class="cov8" title="1">{
                        nos++
                        if nos &gt;= 2*p.F+1 </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

type Flare struct{ p dag.Params }

func NewFlare(p dag.Params) *Flare <span class="cov8" title="1">{ return &amp;Flare{p: p} }</span>

func (f *Flare) Classify(v dag.View, proposer dag.Meta) Decision <span class="cov8" title="1">{
        switch </span>{
        case HasCertificate(v, proposer, f.p):<span class="cov8" title="1">
                return DecideCommit</span>
        case HasSkip(v, proposer, f.p):<span class="cov0" title="0">
                return DecideSkip</span>
        default:<span class="cov8" title="1">
                return DecideUndecided</span>
        }
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package focus

import (
        "sync"
        "time"
)

// Tracker tracks confidence counters for items
type Tracker[ID comparable] struct {
        mu     sync.RWMutex
        counts map[ID]int
}

func NewTracker[ID comparable]() *Tracker[ID] <span class="cov8" title="1">{
        return &amp;Tracker[ID]{
                counts: make(map[ID]int),
        }
}</span>

func (t *Tracker[ID]) Incr(id ID) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()
        t.counts[id]++
}</span>

func (t *Tracker[ID]) Count(id ID) int <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()
        return t.counts[id]
}</span>

func (t *Tracker[ID]) Reset(id ID) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()
        delete(t.counts, id)
}</span>

// Confidence tracks confidence building for consensus
type Confidence[ID comparable] struct {
        mu        sync.RWMutex
        threshold int
        alpha     float64
        states    map[ID]int
}

func NewConfidence[ID comparable](threshold int, alpha float64) *Confidence[ID] <span class="cov8" title="1">{
        return &amp;Confidence[ID]{
                threshold: threshold,
                alpha:     alpha,
                states:    make(map[ID]int),
        }
}</span>

func (c *Confidence[ID]) Update(id ID, ratio float64) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        current := c.states[id]
        if ratio &gt;= c.alpha </span><span class="cov8" title="1">{
                c.states[id] = current + 1
        }</span> else<span class="cov8" title="1"> if ratio &lt;= 1.0-c.alpha </span><span class="cov8" title="1">{
                c.states[id] = 0 // Reset on opposite preference
        }</span>
}

func (c *Confidence[ID]) State(id ID) (int, bool) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        state := c.states[id]
        decided := state &gt;= c.threshold
        return state, decided
}</span>

// WindowedConfidence tracks confidence with time windows
type WindowedConfidence[ID comparable] struct {
        mu         sync.RWMutex
        threshold  int
        alpha      float64
        window     time.Duration
        states     map[ID]int
        lastUpdate map[ID]time.Time
}

func NewWindowed[ID comparable](threshold int, alpha float64, window time.Duration) *WindowedConfidence[ID] <span class="cov8" title="1">{
        return &amp;WindowedConfidence[ID]{
                threshold:  threshold,
                alpha:      alpha,
                window:     window,
                states:     make(map[ID]int),
                lastUpdate: make(map[ID]time.Time),
        }
}</span>

func (w *WindowedConfidence[ID]) Update(id ID, ratio float64) <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        now := time.Now()
        if last, ok := w.lastUpdate[id]; ok </span><span class="cov8" title="1">{
                if now.Sub(last) &gt; w.window </span><span class="cov0" title="0">{
                        // Window expired, reset
                        w.states[id] = 0
                }</span>
        }

        <span class="cov8" title="1">current := w.states[id]
        if ratio &gt;= w.alpha </span><span class="cov8" title="1">{
                w.states[id] = current + 1
        }</span> else<span class="cov0" title="0"> if ratio &lt;= 1.0-w.alpha </span><span class="cov0" title="0">{
                w.states[id] = 0
        }</span>
        <span class="cov8" title="1">w.lastUpdate[id] = now</span>
}

func (w *WindowedConfidence[ID]) State(id ID) (int, bool) <span class="cov8" title="1">{
        w.mu.RLock()
        defer w.mu.RUnlock()

        // Check if window expired
        if last, ok := w.lastUpdate[id]; ok </span><span class="cov8" title="1">{
                if time.Since(last) &gt; w.window </span><span class="cov8" title="1">{
                        return 0, false
                }</span>
        }

        <span class="cov8" title="1">state := w.states[id]
        decided := state &gt;= w.threshold
        return state, decided</span>
}

// Calc calculates confidence based on votes
func Calc(yes, total, prev int) (float64, int) <span class="cov8" title="1">{
        if total == 0 </span><span class="cov0" title="0">{
                return 0, prev
        }</span>

        <span class="cov8" title="1">ratio := float64(yes) / float64(total)

        // Calculate new confidence
        var conf int
        if ratio &gt; 0.5 </span><span class="cov8" title="1">{
                conf = yes - (total - yes) // Difference between yes and no
                if conf &lt; 0 </span><span class="cov0" title="0">{
                        conf = 0
                }</span>
        } else<span class="cov8" title="1"> {
                conf = 0
        }</span>

        // Consider previous confidence
        <span class="cov8" title="1">if prev &gt; 0 &amp;&amp; conf &gt; 0 </span><span class="cov8" title="1">{
                conf += prev / 2 // Boost with previous confidence
        }</span>

        <span class="cov8" title="1">return ratio, conf</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package horizon

import (
        "github.com/luxfi/consensus/core/dag"
)

type VertexID [32]byte

type Meta interface {
        ID() VertexID
        Author() string
        Round() uint64
        Parents() []VertexID
}

type View interface {
        Get(VertexID) (Meta, bool)
        ByRound(round uint64) []Meta
        Supports(from VertexID, author string, round uint64) bool
}

type Params struct{ N, F int }

// TransitiveClosure computes the transitive closure of a vertex in the DAG
func TransitiveClosure[V comparable](store dag.Store[V], vertex V) []V <span class="cov8" title="1">{
        // TODO: Implement transitive closure computation
        return []V{vertex}
}</span>

// Certificate represents a proof that a vertex has achieved consensus
type Certificate[V comparable] struct {
        Vertex    V
        Proof     []V
        Threshold int
}

// ValidateCertificate checks if a certificate is valid given a validator function
func ValidateCertificate[V comparable](store dag.Store[V], cert Certificate[V], isValid func(V) bool) bool <span class="cov8" title="1">{
        // TODO: Implement certificate validation
        validCount := 0
        for _, proof := range cert.Proof </span><span class="cov8" title="1">{
                if isValid(proof) </span><span class="cov8" title="1">{
                        validCount++
                }</span>
        }
        <span class="cov8" title="1">return validCount &gt;= cert.Threshold</span>
}

// SkipList represents a skip list data structure for efficient DAG traversal
type SkipList[V comparable] struct {
        Levels map[V][]V
}

// BuildSkipList constructs a skip list from DAG vertices for efficient navigation
func BuildSkipList[V comparable](store dag.Store[V], vertices []V) *SkipList[V] <span class="cov8" title="1">{
        // TODO: Implement skip list construction
        sl := &amp;SkipList[V]{
                Levels: make(map[V][]V),
        }

        // Simple placeholder: each vertex points to its first parent
        for _, v := range vertices </span><span class="cov8" title="1">{
                if block, exists := store.Get(v); exists </span><span class="cov8" title="1">{
                        parents := block.Parents()
                        if len(parents) &gt; 0 </span><span class="cov8" title="1">{
                                sl.Levels[v] = []V{parents[0]}
                        }</span> else<span class="cov0" title="0"> {
                                sl.Levels[v] = []V{}
                        }</span>
                }
        }

        <span class="cov8" title="1">return sl</span>
}

// FindPath finds a path between two vertices in the DAG
func FindPath[V comparable](store dag.Store[V], from, to V) ([]V, bool) <span class="cov8" title="1">{
        // TODO: Implement path finding algorithm
        // Simple placeholder: return single vertex path if vertices exist
        if _, exists1 := store.Get(from); exists1 </span><span class="cov8" title="1">{
                if _, exists2 := store.Get(to); exists2 </span><span class="cov8" title="1">{
                        return []V{from, to}, true
                }</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">package nebula

import (
        "context"
        "time"

        "github.com/luxfi/consensus/prism"
        "github.com/luxfi/consensus/protocol/field"
        "github.com/luxfi/consensus/wave"
)

// VID represents a vertex identifier in the DAG
type VID interface{ comparable }

// Nebula implements DAG consensus using the internal Field engine
type Nebula[V VID] struct {
        fieldEngine *field.Driver[V]
        config      Config
}

// Config holds configuration for Nebula consensus mode
type Config struct {
        PollSize   int           // sample size for voting
        Alpha      float64       // threshold ratio
        Beta       uint32        // confidence threshold
        RoundTO    time.Duration // round timeout
        GenesisSet []byte        // genesis vertex set
}

// NewNebula creates a new Nebula instance with Field engine
func NewNebula[V VID](cfg Config, cut prism.Cut[V], tx wave.Transport[V], store field.Store[V], prop field.Proposer[V], com field.Committer[V]) *Nebula[V] <span class="cov0" title="0">{
        fieldConfig := field.Config{
                PollSize: cfg.PollSize,
                Alpha:    cfg.Alpha,
                Beta:     cfg.Beta,
                RoundTO:  cfg.RoundTO,
        }

        return &amp;Nebula[V]{
                fieldEngine: field.NewDriver(fieldConfig, cut, tx, store, prop, com),
                config:      cfg,
        }
}</span>

// Start begins Nebula DAG consensus operation
func (n *Nebula[V]) Start(ctx context.Context) error <span class="cov0" title="0">{
        return n.fieldEngine.Start(ctx)
}</span>

// Stop ends Nebula DAG consensus operation
func (n *Nebula[V]) Stop(ctx context.Context) error <span class="cov0" title="0">{
        return n.fieldEngine.Stop(ctx)
}</span>

// ProposeVertex proposes a new vertex to the DAG
func (n *Nebula[V]) ProposeVertex(ctx context.Context, parents []V) (V, error) <span class="cov0" title="0">{
        return n.fieldEngine.Propose(ctx, parents)
}</span>

// Tick performs one consensus round for DAG progression
func (n *Nebula[V]) Tick(ctx context.Context) error <span class="cov0" title="0">{
        return n.fieldEngine.Tick(ctx)
}</span>

// OnObserve should be called when observing new vertices from the network
func (n *Nebula[V]) OnObserve(ctx context.Context, vertex V) <span class="cov0" title="0">{
        n.fieldEngine.OnObserve(ctx, vertex)
}</span>

// GetFrontier returns the current DAG frontier (tips)
func (n *Nebula[V]) GetFrontier() []V <span class="cov0" title="0">{
        return n.fieldEngine.GetFrontier()
}</span>

// IsFinalized checks if a vertex is finalized in the DAG
func (n *Nebula[V]) IsFinalized(vertex V) bool <span class="cov0" title="0">{
        return n.fieldEngine.IsFinalized(vertex)
}</span>

// GetCommittedVertices returns vertices that have been committed in order
func (n *Nebula[V]) GetCommittedVertices() []V <span class="cov0" title="0">{
        return n.fieldEngine.GetCommittedVertices()
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package nova

import (
        "context"
        "time"

        "github.com/luxfi/consensus/prism"
        "github.com/luxfi/consensus/protocol/ray"
        "github.com/luxfi/consensus/wave"
)

// Nova implements linear blockchain consensus using the internal Ray engine
type Nova[T comparable] struct {
        rayEngine *ray.Driver[T]
        config    Config
}

// Config holds configuration for Nova consensus mode
type Config struct {
        SampleSize  int           // k parameter for sampling
        Alpha       float64       // threshold ratio
        Beta        uint32        // confidence threshold
        RoundTO     time.Duration // round timeout
        GenesisHash [32]byte      // genesis block hash
}

// NewNova creates a new Nova instance with Ray engine
func NewNova[T comparable](cfg Config, cut prism.Cut[T], tx wave.Transport[T], source ray.Source[T], sink ray.Sink[T]) *Nova[T] <span class="cov0" title="0">{
        rayConfig := ray.Config{
                PollSize: cfg.SampleSize,
                Alpha:    cfg.Alpha,
                Beta:     cfg.Beta,
                RoundTO:  cfg.RoundTO,
        }

        return &amp;Nova[T]{
                rayEngine: ray.NewDriver(rayConfig, cut, tx, source, sink),
                config:    cfg,
        }
}</span>

// Start begins Nova consensus operation
func (n *Nova[T]) Start(ctx context.Context) error <span class="cov0" title="0">{
        return n.rayEngine.Start(ctx)
}</span>

// Stop ends Nova consensus operation
func (n *Nova[T]) Stop(ctx context.Context) error <span class="cov0" title="0">{
        return n.rayEngine.Stop(ctx)
}</span>

// ProposeBlock proposes a new block for the current height
func (n *Nova[T]) ProposeBlock(ctx context.Context, block T) error <span class="cov0" title="0">{
        return n.rayEngine.Propose(ctx, block)
}</span>

// Tick performs one consensus round for linear chain progression
func (n *Nova[T]) Tick(ctx context.Context) error <span class="cov0" title="0">{
        return n.rayEngine.Tick(ctx)
}</span>

// GetPreference returns the current preferred block
func (n *Nova[T]) GetPreference() (T, bool) <span class="cov0" title="0">{
        return n.rayEngine.GetPreference()
}</span>

// IsFinalized checks if a block is finalized
func (n *Nova[T]) IsFinalized(block T) bool <span class="cov0" title="0">{
        return n.rayEngine.IsFinalized(block)
}</span>

// Height returns the current blockchain height
func (n *Nova[T]) Height() uint64 <span class="cov0" title="0">{
        return n.rayEngine.Height()
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">// Copyright (C) 2025, Lux Partners Limited All rights reserved.
// Quasar Hybrid Consensus: BLS + Ringtail for Full Post-Quantum Security

package quasar

import (
        "crypto/rand"
        "errors"
        "fmt"
        "sync"

        "github.com/luxfi/crypto/bls"
        "github.com/luxfi/crypto/mldsa"
)

// QuasarHybridConsensus implements parallel BLS+Ringtail for PQ-safe consensus
type QuasarHybridConsensus struct {
        mu sync.RWMutex

        // BLS for classical threshold signatures
        blsThreshold int
        blsKeys      map[string]*bls.SecretKey
        blsPubKeys   map[string]*bls.PublicKey

        // Ringtail for post-quantum signatures
        ringtailEngine RingtailPQ
        ringtailKeys   map[string]*RingtailKeyPair

        // Hybrid signature aggregation
        pendingBLS      map[string][]*bls.Signature
        pendingRingtail map[string][]RingtailSignature

        // Consensus state
        validators map[string]*Validator
        threshold  int // Number of validators needed for consensus
}

// RingtailPQ provides real post-quantum signatures using ML-DSA
type RingtailPQ struct {
        mode mldsa.Mode
}

// RingtailKeyPair holds a post-quantum key pair
type RingtailKeyPair struct {
        PrivateKey *mldsa.PrivateKey
        PublicKey  *mldsa.PublicKey
}

// RingtailSignature represents a post-quantum signature
type RingtailSignature struct {
        Signature   []byte
        PublicKey   []byte
        ValidatorID string
}

// Validator represents a consensus validator
type Validator struct {
        ID          string
        BLSPubKey   *bls.PublicKey
        RingtailPub *mldsa.PublicKey
        Weight      uint64
        Active      bool
}

// NewQuasarHybridConsensus creates a new hybrid consensus engine
func NewQuasarHybridConsensus(threshold int) (*QuasarHybridConsensus, error) <span class="cov0" title="0">{
        if threshold &lt; 1 </span><span class="cov0" title="0">{
                return nil, errors.New("threshold must be at least 1")
        }</span>

        <span class="cov0" title="0">return &amp;QuasarHybridConsensus{
                blsThreshold:    threshold,
                blsKeys:         make(map[string]*bls.SecretKey),
                blsPubKeys:      make(map[string]*bls.PublicKey),
                ringtailEngine:  RingtailPQ{mode: mldsa.MLDSA65}, // Level 3 security
                ringtailKeys:    make(map[string]*RingtailKeyPair),
                pendingBLS:      make(map[string][]*bls.Signature),
                pendingRingtail: make(map[string][]RingtailSignature),
                validators:      make(map[string]*Validator),
                threshold:       threshold,
        }, nil</span>
}

// AddValidator adds a validator to the consensus
func (q *QuasarHybridConsensus) AddValidator(id string, weight uint64) error <span class="cov0" title="0">{
        q.mu.Lock()
        defer q.mu.Unlock()

        // Generate BLS key pair
        blsSK, err := bls.NewSecretKey()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate BLS key: %w", err)
        }</span>
        <span class="cov0" title="0">blsPK := blsSK.PublicKey()

        // Generate Ringtail (ML-DSA) key pair
        ringtailPriv, err := mldsa.GenerateKey(rand.Reader, q.ringtailEngine.mode)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to generate Ringtail key: %w", err)
        }</span>

        // Store keys
        <span class="cov0" title="0">q.blsKeys[id] = blsSK
        q.blsPubKeys[id] = blsPK
        q.ringtailKeys[id] = &amp;RingtailKeyPair{
                PrivateKey: ringtailPriv,
                PublicKey:  ringtailPriv.PublicKey,
        }

        // Add validator
        q.validators[id] = &amp;Validator{
                ID:          id,
                BLSPubKey:   blsPK,
                RingtailPub: ringtailPriv.PublicKey,
                Weight:      weight,
                Active:      true,
        }

        return nil</span>
}

// SignMessage signs a message with both BLS and Ringtail
func (q *QuasarHybridConsensus) SignMessage(validatorID string, message []byte) (*HybridSignature, error) <span class="cov0" title="0">{
        q.mu.RLock()
        defer q.mu.RUnlock()

        // Get keys
        blsSK, exists := q.blsKeys[validatorID]
        if !exists </span><span class="cov0" title="0">{
                return nil, errors.New("validator not found")
        }</span>

        <span class="cov0" title="0">ringtailKP, exists := q.ringtailKeys[validatorID]
        if !exists </span><span class="cov0" title="0">{
                return nil, errors.New("ringtail keys not found")
        }</span>

        // Create BLS signature
        <span class="cov0" title="0">blsSig := blsSK.Sign(message)

        // Create Ringtail (ML-DSA) signature
        ringtailSig, err := ringtailKP.PrivateKey.Sign(rand.Reader, message, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Ringtail sign failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;HybridSignature{
                BLS:         bls.SignatureToBytes(blsSig),
                Ringtail:    ringtailSig,
                ValidatorID: validatorID,
        }, nil</span>
}

// VerifyHybridSignature verifies both BLS and Ringtail signatures
func (q *QuasarHybridConsensus) VerifyHybridSignature(message []byte, sig *HybridSignature) bool <span class="cov0" title="0">{
        q.mu.RLock()
        defer q.mu.RUnlock()

        validator, exists := q.validators[sig.ValidatorID]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // Verify BLS signature
        <span class="cov0" title="0">blsSig, err := bls.SignatureFromBytes(sig.BLS)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // BLS verification using Verify method
        <span class="cov0" title="0">if !bls.Verify(validator.BLSPubKey, blsSig, message) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Verify Ringtail (ML-DSA) signature
        <span class="cov0" title="0">if !validator.RingtailPub.Verify(message, sig.Ringtail, nil) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// AggregateSignatures aggregates signatures for a message
func (q *QuasarHybridConsensus) AggregateSignatures(message []byte, signatures []*HybridSignature) (*AggregatedSignature, error) <span class="cov0" title="0">{
        q.mu.Lock()
        defer q.mu.Unlock()

        if len(signatures) &lt; q.threshold </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("insufficient signatures: %d &lt; %d", len(signatures), q.threshold)
        }</span>

        // Aggregate BLS signatures
        <span class="cov0" title="0">blsSigs := make([]*bls.Signature, 0, len(signatures))
        for _, sig := range signatures </span><span class="cov0" title="0">{
                blsSig, err := bls.SignatureFromBytes(sig.BLS)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid BLS signature: %w", err)
                }</span>
                <span class="cov0" title="0">blsSigs = append(blsSigs, blsSig)</span>
        }

        <span class="cov0" title="0">aggregatedBLS, err := bls.AggregateSignatures(blsSigs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("BLS aggregation failed: %w", err)
        }</span>

        // Collect Ringtail signatures (can't aggregate, but verify threshold)
        <span class="cov0" title="0">ringtailSigs := make([]RingtailSignature, 0, len(signatures))
        for _, sig := range signatures </span><span class="cov0" title="0">{
                ringtailSigs = append(ringtailSigs, RingtailSignature{
                        Signature:   sig.Ringtail,
                        ValidatorID: sig.ValidatorID,
                })
        }</span>

        <span class="cov0" title="0">return &amp;AggregatedSignature{
                BLSAggregated: bls.SignatureToBytes(aggregatedBLS),
                RingtailSigs:  ringtailSigs,
                SignerCount:   len(signatures),
        }, nil</span>
}

// VerifyAggregatedSignature verifies an aggregated signature
func (q *QuasarHybridConsensus) VerifyAggregatedSignature(message []byte, aggSig *AggregatedSignature) bool <span class="cov0" title="0">{
        q.mu.RLock()
        defer q.mu.RUnlock()

        // Check threshold
        if aggSig.SignerCount &lt; q.threshold </span><span class="cov0" title="0">{
                return false
        }</span>

        // Verify aggregated BLS signature
        <span class="cov0" title="0">blsSig, err := bls.SignatureFromBytes(aggSig.BLSAggregated)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Collect public keys for BLS verification
        <span class="cov0" title="0">pubKeys := make([]*bls.PublicKey, 0, len(aggSig.RingtailSigs))
        for _, ringtailSig := range aggSig.RingtailSigs </span><span class="cov0" title="0">{
                validator, exists := q.validators[ringtailSig.ValidatorID]
                if !exists || !validator.Active </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">pubKeys = append(pubKeys, validator.BLSPubKey)</span>
        }

        <span class="cov0" title="0">aggPubKey, err := bls.AggregatePublicKeys(pubKeys)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if !bls.Verify(aggPubKey, blsSig, message) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Verify each Ringtail signature
        <span class="cov0" title="0">for _, ringtailSig := range aggSig.RingtailSigs </span><span class="cov0" title="0">{
                validator, exists := q.validators[ringtailSig.ValidatorID]
                if !exists </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">if !validator.RingtailPub.Verify(message, ringtailSig.Signature, nil) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

// HybridSignature contains both BLS and Ringtail signatures
type HybridSignature struct {
        BLS         []byte
        Ringtail    []byte
        ValidatorID string
}

// AggregatedSignature contains aggregated BLS and individual Ringtail signatures
type AggregatedSignature struct {
        BLSAggregated []byte
        RingtailSigs  []RingtailSignature
        SignerCount   int
}

// GetActiveValidatorCount returns the number of active validators
func (q *QuasarHybridConsensus) GetActiveValidatorCount() int <span class="cov0" title="0">{
        q.mu.RLock()
        defer q.mu.RUnlock()

        count := 0
        for _, v := range q.validators </span><span class="cov0" title="0">{
                if v.Active </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

// GetThreshold returns the consensus threshold
func (q *QuasarHybridConsensus) GetThreshold() int <span class="cov0" title="0">{
        return q.threshold
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package quasar

import (
        "context"
        "time"

        "github.com/luxfi/consensus/config"
        "github.com/luxfi/consensus/core/dag"
)

// CertBundle contains both classical and quantum certificates
type CertBundle struct {
        BLSAgg []byte // BLS aggregate signature
        PQCert []byte // Post-quantum certificate
}

// Bundle represents a finalized epoch bundle
type Bundle struct {
        Epoch   uint64
        Root    []byte
        BLSAgg  []byte
        PQBatch []byte
        Binding []byte
}

// Verify checks both BLS and PQ certificates
func (c *CertBundle) Verify(_ []string) bool <span class="cov8" title="1">{
        // Placeholder verification
        // In production: verify BLS signature and PQ certificate
        return c.BLSAgg != nil &amp;&amp; c.PQCert != nil &amp;&amp; len(c.BLSAgg) &gt; 0 &amp;&amp; len(c.PQCert) &gt; 0
}</span>

// QBlock represents a quantum-finalized block
type QBlock struct {
        Height    uint64
        Hash      string
        Timestamp time.Time
        Cert      *CertBundle
}

// Client interface for Quasar operations
type Client interface {
        SubmitCheckpoint(epoch uint64, root []byte, attest []byte) error
        FetchBundle(epoch uint64) (Bundle, error)
        Verify(Bundle) bool
}

// VertexID represents a P-Chain vertex identifier
type VertexID [32]byte

// Quasar implements P-Chain post-quantum consensus with event horizon finality
type Quasar struct {
        // Configuration
        K     int
        Alpha float64
        Beta  uint32

        // Keys
        blsKey []byte
        pqKey  []byte

        // P-Chain state
        horizons []dag.EventHorizon[VertexID]
        store    dag.Store[VertexID]

        // Callback
        finalizedCb func(QBlock)
}

// New creates a new Quasar P-Chain instance
func New(cfg config.Parameters, store dag.Store[VertexID]) *Quasar <span class="cov8" title="1">{
        return &amp;Quasar{
                K:        cfg.K,
                Alpha:    cfg.Alpha,
                Beta:     cfg.Beta,
                horizons: make([]dag.EventHorizon[VertexID], 0),
                store:    store,
        }
}</span>

// Initialize sets up keys for Quasar
func (q *Quasar) Initialize(_ context.Context, blsKey, pqKey []byte) error <span class="cov8" title="1">{
        q.blsKey = blsKey
        q.pqKey = pqKey
        return nil
}</span>

// SetFinalizedCallback sets the callback for finalized blocks
func (q *Quasar) SetFinalizedCallback(cb func(QBlock)) <span class="cov8" title="1">{
        q.finalizedCb = cb
}</span>

// phaseI proposes a block from the DAG frontier
func (q *Quasar) phaseI(frontier []string) string <span class="cov8" title="1">{
        // Select highest confidence block
        // Placeholder: return first block
        if len(frontier) &gt; 0 </span><span class="cov8" title="1">{
                return frontier[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// phaseII creates certificates if threshold is met
func (q *Quasar) phaseII(votes map[string]int, proposal string) *CertBundle <span class="cov8" title="1">{
        total := 0
        support := 0

        for block, count := range votes </span><span class="cov8" title="1">{
                total += count
                if block == proposal </span><span class="cov8" title="1">{
                        support = count
                }</span>
        }

        <span class="cov8" title="1">if total == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Check if support meets alpha threshold
        <span class="cov8" title="1">if float64(support)/float64(total) &gt;= q.Alpha </span><span class="cov8" title="1">{
                // Create certificates (placeholder)
                return &amp;CertBundle{
                        BLSAgg: []byte("mock-bls-aggregate"),
                        PQCert: []byte("mock-pq-certificate"),
                }
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// EstablishHorizon creates a new event horizon for P-Chain finality
func (q *Quasar) EstablishHorizon(ctx context.Context, checkpoint VertexID, validators []string) (*dag.EventHorizon[VertexID], error) <span class="cov0" title="0">{
        // Compute new event horizon using Ringtail + BLS signatures
        horizon := dag.EventHorizon[VertexID]{
                Checkpoint: checkpoint,
                Height:     uint64(len(q.horizons)) + 1,
                Validators: validators,
                Signature:  q.createHorizonSignature(checkpoint, validators),
        }

        q.horizons = append(q.horizons, horizon)
        return &amp;horizon, nil
}</span>

// IsBeyondHorizon checks if a vertex is beyond the event horizon (finalized)
func (q *Quasar) IsBeyondHorizon(vertex VertexID) bool <span class="cov0" title="0">{
        if len(q.horizons) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">latestHorizon := q.horizons[len(q.horizons)-1]
        return dag.BeyondHorizon(q.store, vertex, latestHorizon)</span>
}

// ComputeCanonicalOrder returns the canonical order of finalized vertices
func (q *Quasar) ComputeCanonicalOrder() []VertexID <span class="cov0" title="0">{
        if len(q.horizons) == 0 </span><span class="cov0" title="0">{
                return []VertexID{}
        }</span>

        <span class="cov0" title="0">latestHorizon := q.horizons[len(q.horizons)-1]
        return dag.ComputeHorizonOrder(q.store, latestHorizon)</span>
}

// GetLatestHorizon returns the most recent event horizon
func (q *Quasar) GetLatestHorizon() *dag.EventHorizon[VertexID] <span class="cov0" title="0">{
        if len(q.horizons) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;q.horizons[len(q.horizons)-1]</span>
}

// createHorizonSignature creates a Ringtail + BLS signature for the event horizon
func (q *Quasar) createHorizonSignature(checkpoint VertexID, validators []string) []byte <span class="cov0" title="0">{
        // TODO: Implement Ringtail + BLS fusion signature
        // This should combine:
        // 1. BLS aggregate signature for efficiency
        // 2. Ringtail post-quantum threshold signature for security

        // Placeholder implementation
        signature := append(q.blsKey, q.pqKey...)
        signature = append(signature, checkpoint[:]...)
        return signature
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">// Copyright (C) 2020-2025, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

// Package ringtail provides post-quantum cryptographic primitives for the Lux consensus.
// This is a stub implementation that forwards to the actual implementation in github.com/luxfi/crypto/ringtail.
package quasar

import (
        "crypto/rand"
        "errors"
)

// Type aliases for cleaner API
type (
        Precomp   = []byte
        Share     = []byte
        Cert      = []byte
        SecretKey = []byte
        PublicKey = []byte
        Signature = []byte // Alias for Share or Cert depending on context
)

// SecurityLevel represents the post-quantum security level
type SecurityLevel int

const (
        SecurityLow    SecurityLevel = 0
        SecurityMedium SecurityLevel = 1
        SecurityHigh   SecurityLevel = 2
)

// RingtailEngine represents the post-quantum consensus engine
type RingtailEngine interface {
        // Initialize the engine with security parameters
        Initialize(level SecurityLevel) error

        // Sign a message with the secret key
        Sign(msg []byte, sk SecretKey) (Signature, error)

        // Verify a signature
        Verify(msg []byte, sig Signature, pk PublicKey) bool

        // Generate a new key pair
        GenerateKeyPair() (SecretKey, PublicKey, error)

        // KEM operations for post-quantum key exchange
        Encapsulate(pk PublicKey) ([]byte, []byte, error)
        Decapsulate(ct []byte, sk SecretKey) ([]byte, error)

        // Shared secret operations
        CombineSharedSecrets(ss1, ss2 []byte) []byte
        DeriveKey(secret []byte, length int) []byte
}

// Error variables
var (
        ErrInvalidCertificate  = errors.New("invalid certificate")
        ErrMissingCertificate  = errors.New("missing certificate")
        ErrCertificateMismatch = errors.New("certificate mismatch")
)

// stubEngine is a stub implementation of RingtailEngine for testing
type stubEngine struct {
        level SecurityLevel
}

// NewRingtail creates a new ringtail engine
func NewRingtail() RingtailEngine <span class="cov8" title="1">{
        return &amp;stubEngine{}
}</span>

// Initialize sets the security level
func (e *stubEngine) Initialize(level SecurityLevel) error <span class="cov0" title="0">{
        e.level = level
        return nil
}</span>

// Sign signs a message (stub implementation)
func (e *stubEngine) Sign(_ []byte, sk SecretKey) (Signature, error) <span class="cov8" title="1">{
        // Stub implementation - return non-zero signature
        sig := make([]byte, 32)
        // Put some non-zero bytes to make it a "valid" signature
        for i := range sig </span><span class="cov8" title="1">{
                sig[i] = byte(i + 1)
        }</span>
        <span class="cov8" title="1">return sig, nil</span>
}

// Verify verifies a signature (stub implementation)
func (e *stubEngine) Verify(msg []byte, sig Signature, pk PublicKey) bool <span class="cov8" title="1">{
        // Stub implementation - check if signature is non-zero
        // A real implementation would verify the cryptographic signature
        for _, b := range sig </span><span class="cov8" title="1">{
                if b != 0 </span><span class="cov8" title="1">{
                        return true // Non-zero signature considered valid for stub
                }</span>
        }
        <span class="cov8" title="1">return false</span> // All-zero signature is invalid
}

// GenerateKeyPair generates a new key pair (stub implementation)
func (e *stubEngine) GenerateKeyPair() (SecretKey, PublicKey, error) <span class="cov8" title="1">{
        // Stub implementation
        sk := make([]byte, 32)
        pk := make([]byte, 32)
        return sk, pk, nil
}</span>

// Encapsulate generates a ciphertext and shared secret (stub implementation)
func (e *stubEngine) Encapsulate(pk PublicKey) ([]byte, []byte, error) <span class="cov8" title="1">{
        ct := make([]byte, 64)
        ss := make([]byte, 32)
        if _, err := rand.Read(ct); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">if _, err := rand.Read(ss); err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">return ct, ss, nil</span>
}

// Decapsulate recovers shared secret from ciphertext (stub implementation)
func (e *stubEngine) Decapsulate(ct []byte, sk SecretKey) ([]byte, error) <span class="cov8" title="1">{
        ss := make([]byte, 32)
        if _, err := rand.Read(ss); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return ss, nil</span>
}

// CombineSharedSecrets combines two shared secrets (stub implementation)
func (e *stubEngine) CombineSharedSecrets(ss1, ss2 []byte) []byte <span class="cov8" title="1">{
        combined := make([]byte, 32)
        for i := 0; i &lt; 32 &amp;&amp; i &lt; len(ss1) &amp;&amp; i &lt; len(ss2); i++ </span><span class="cov8" title="1">{
                combined[i] = ss1[i] ^ ss2[i]
        }</span>
        <span class="cov8" title="1">return combined</span>
}

// DeriveKey derives a key from shared secret (stub implementation)
func (e *stubEngine) DeriveKey(secret []byte, length int) []byte <span class="cov8" title="1">{
        key := make([]byte, length)
        copy(key, secret)
        return key
}</span>

// KeyGen generates a key pair from seed
func KeyGen(seed []byte) ([]byte, []byte, error) <span class="cov0" title="0">{
        // Stub implementation
        sk := make([]byte, 32)
        pk := make([]byte, 32)
        copy(sk, seed)
        copy(pk, seed)
        return sk, pk, nil
}</span>

// Precompute generates a precomputed share
func Precompute(sk []byte) (Precomp, error) <span class="cov0" title="0">{
        // Stub implementation
        precomp := make([]byte, 32)
        if _, err := rand.Read(precomp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return precomp, nil</span>
}

// QuickSign signs using a precomputed share
func QuickSign(precomp Precomp, msg []byte) (Share, error) <span class="cov0" title="0">{
        // Stub implementation
        share := make([]byte, 32)
        copy(share, precomp)
        // XOR with message hash for demo
        for i := 0; i &lt; len(share) &amp;&amp; i &lt; len(msg); i++ </span><span class="cov0" title="0">{
                share[i] ^= msg[i]
        }</span>
        <span class="cov0" title="0">return share, nil</span>
}

// VerifyShare verifies a share signature
func VerifyShare(pk []byte, msg []byte, share []byte) bool <span class="cov0" title="0">{
        // Stub implementation - always return true
        return true
}</span>

// Aggregate aggregates shares into a certificate
func Aggregate(shares []Share) (Cert, error) <span class="cov0" title="0">{
        // Stub implementation
        if len(shares) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("no shares to aggregate")
        }</span>
        <span class="cov0" title="0">cert := make([]byte, 32)
        // XOR all shares together for demo
        for _, share := range shares </span><span class="cov0" title="0">{
                for i := 0; i &lt; len(cert) &amp;&amp; i &lt; len(share); i++ </span><span class="cov0" title="0">{
                        cert[i] ^= share[i]
                }</span>
        }
        <span class="cov0" title="0">return cert, nil</span>
}

// Verify verifies a certificate
func Verify(pk []byte, msg []byte, cert []byte) bool <span class="cov0" title="0">{
        // Stub implementation - always return true
        return true
}</span>

// NewCertificate creates a new empty certificate
// func NewCertificate(round, height uint64, blockHash [32]byte) *Certificate {
//         return rt.NewCertificate(round, height, blockHash)
// }

// NewCertificateManager creates a new certificate manager
// func NewCertificateManager(nodeID ids.NodeID, blsKey, rtKey interface{}, validators ValidatorSet) *CertificateManager {
//         return rt.NewCertificateManager(nodeID, blsKey, rtKey, validators)
// }

// VerifyAggregate verifies an aggregate signature
// func VerifyAggregate(pubKeys [][]byte, msg []byte, aggregateData []byte, threshold int) error {
//         return rt.VerifyAggregate(pubKeys, msg, aggregateData, threshold)
// }
</pre>
		
		<pre class="file" id="file76" style="display: none">// Copyright (C) 2025, Lux Partners Limited All rights reserved.
// Verkle Witness for Hyper-Efficient Verification with PQ Finality

package quasar

import (
        "bytes"
        "crypto/sha256"
        "errors"
        "sync"

        "github.com/luxfi/crypto/bls"
        "github.com/luxfi/crypto/ipa/banderwagon"
)

// VerkleWitness provides hyper-efficient state verification
// Assumes every block is PQ-final via BLS+Ringtail threshold
type VerkleWitness struct {
        mu sync.RWMutex

        // Verkle tree commitment
        root *banderwagon.Element

        // Cached witnesses for fast verification
        witnessCache map[string]*WitnessProof
        cacheSize    int

        // PQ finality assumption
        assumePQFinal bool
        minThreshold  int
}

// WitnessProof contains the minimal proof for state verification
type WitnessProof struct {
        // Verkle proof components
        Commitment   []byte // 32 bytes banderwagon point
        Path         []byte // Compressed path in tree
        OpeningProof []byte // IPA opening proof

        // PQ finality certificate (lightweight)
        BLSAggregate []byte // Aggregated BLS signature
        RingtailBits []byte // Bitfield of Ringtail signers
        ValidatorSet []byte // Compressed validator set hash

        // Block metadata
        BlockHeight uint64
        StateRoot   []byte
        Timestamp   uint64
}

// NewVerkleWitness creates a lightweight Verkle witness verifier
func NewVerkleWitness(threshold int) *VerkleWitness <span class="cov0" title="0">{
        return &amp;VerkleWitness{
                witnessCache:  make(map[string]*WitnessProof),
                cacheSize:     1000, // Cache last 1000 witnesses
                assumePQFinal: true, // Always assume PQ finality
                minThreshold:  threshold,
        }
}</span>

// VerifyStateTransition verifies state transition with minimal overhead
// Assumes PQ finality via BLS+Ringtail threshold already met
func (v *VerkleWitness) VerifyStateTransition(witness *WitnessProof) error <span class="cov0" title="0">{
        v.mu.RLock()
        defer v.mu.RUnlock()

        // Fast path: If PQ final, skip heavy verification
        if v.assumePQFinal &amp;&amp; v.checkPQFinality(witness) </span><span class="cov0" title="0">{
                // Just verify the Verkle commitment
                return v.verifyVerkleCommitment(witness)
        }</span>

        // Slow path: Full verification (shouldn't happen with PQ finality)
        <span class="cov0" title="0">return v.fullVerification(witness)</span>
}

// checkPQFinality does lightweight check that BLS+Ringtail threshold is met
func (v *VerkleWitness) checkPQFinality(witness *WitnessProof) bool <span class="cov0" title="0">{
        // Count set bits in Ringtail bitfield (each bit = 1 validator signed)
        ringtailCount := countSetBits(witness.RingtailBits)

        // BLS aggregate implies same threshold was met
        // Just check we have enough signers
        return ringtailCount &gt;= v.minThreshold
}</span>

// verifyVerkleCommitment does ultra-fast Verkle proof verification
func (v *VerkleWitness) verifyVerkleCommitment(witness *WitnessProof) error <span class="cov0" title="0">{
        // Reconstruct the commitment point
        var commitment banderwagon.Element
        if err := commitment.SetBytes(witness.Commitment); err != nil </span><span class="cov0" title="0">{
                return errors.New("invalid commitment")
        }</span>

        // Verify opening proof (IPA)
        // This is O(log n) and very fast
        <span class="cov0" title="0">if !verifyIPAOpening(&amp;commitment, witness.Path, witness.OpeningProof) </span><span class="cov0" title="0">{
                return errors.New("invalid Verkle opening proof")
        }</span>

        // Cache the witness for future use
        <span class="cov0" title="0">v.cacheWitness(witness)

        return nil</span>
}

// fullVerification does complete verification (fallback, rarely used)
func (v *VerkleWitness) fullVerification(witness *WitnessProof) error <span class="cov0" title="0">{
        // Verify BLS aggregate signature
        if err := v.verifyBLSAggregate(witness.BLSAggregate, witness.ValidatorSet); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Verify Ringtail threshold
        <span class="cov0" title="0">if !v.verifyRingtailThreshold(witness.RingtailBits) </span><span class="cov0" title="0">{
                return errors.New("Ringtail threshold not met")
        }</span>

        // Verify Verkle commitment
        <span class="cov0" title="0">return v.verifyVerkleCommitment(witness)</span>
}

// CreateWitness creates a minimal witness for a state transition
func (v *VerkleWitness) CreateWitness(
        stateRoot []byte,
        blsAgg *bls.Signature,
        ringtailSigners []bool,
        height uint64,
) (*WitnessProof, error) <span class="cov0" title="0">{
        v.mu.Lock()
        defer v.mu.Unlock()

        // Create Verkle commitment
        commitment := createVerkleCommitment(stateRoot)

        // Create opening proof (IPA)
        openingProof := createIPAProof(commitment, stateRoot)

        // Compress Ringtail signers to bitfield
        ringtailBits := compressToBitfield(ringtailSigners)

        // Create witness
        commitmentBytes := commitment.Bytes()
        witness := &amp;WitnessProof{
                Commitment:   commitmentBytes[:],
                Path:         compressPath(stateRoot),
                OpeningProof: openingProof,
                BLSAggregate: bls.SignatureToBytes(blsAgg),
                RingtailBits: ringtailBits,
                ValidatorSet: hashValidatorSet(),
                BlockHeight:  height,
                StateRoot:    stateRoot,
                Timestamp:    uint64(timeNow()),
        }

        // Cache it
        v.cacheWitness(witness)

        return witness, nil
}</span>

// BatchVerify verifies multiple witnesses in parallel (hyper-efficient)
func (v *VerkleWitness) BatchVerify(witnesses []*WitnessProof) error <span class="cov0" title="0">{
        // Since we assume PQ finality, we can verify in parallel
        errors := make(chan error, len(witnesses))
        var wg sync.WaitGroup

        for _, witness := range witnesses </span><span class="cov0" title="0">{
                wg.Add(1)
                go func(w *WitnessProof) </span><span class="cov0" title="0">{
                        defer wg.Done()
                        if err := v.VerifyStateTransition(w); err != nil </span><span class="cov0" title="0">{
                                errors &lt;- err
                        }</span>
                }(witness)
        }

        <span class="cov0" title="0">wg.Wait()
        close(errors)

        // Check for any errors
        for err := range errors </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Lightweight helper functions

func countSetBits(bits []byte) int <span class="cov0" title="0">{
        count := 0
        for _, b := range bits </span><span class="cov0" title="0">{
                for b != 0 </span><span class="cov0" title="0">{
                        count += int(b &amp; 1)
                        b &gt;&gt;= 1
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

func compressToBitfield(signers []bool) []byte <span class="cov0" title="0">{
        bitfield := make([]byte, (len(signers)+7)/8)
        for i, signed := range signers </span><span class="cov0" title="0">{
                if signed </span><span class="cov0" title="0">{
                        bitfield[i/8] |= 1 &lt;&lt; (i % 8)
                }</span>
        }
        <span class="cov0" title="0">return bitfield</span>
}

func createVerkleCommitment(stateRoot []byte) *banderwagon.Element <span class="cov0" title="0">{
        // Create commitment from state root
        var point banderwagon.Element
        _ = point.SetBytes(stateRoot[:32]) // Safe to ignore: input is valid
        return &amp;point
}</span>

func createIPAProof(commitment *banderwagon.Element, data []byte) []byte <span class="cov0" title="0">{
        // Simplified IPA proof creation
        hasher := sha256.New()
        commitmentBytes := commitment.Bytes()
        hasher.Write(commitmentBytes[:])
        hasher.Write(data)
        return hasher.Sum(nil)
}</span>

func verifyIPAOpening(commitment *banderwagon.Element, path []byte, proof []byte) bool <span class="cov0" title="0">{
        // Simplified IPA verification (real implementation would use full IPA)
        hasher := sha256.New()
        commitmentBytes := commitment.Bytes()
        hasher.Write(commitmentBytes[:])
        hasher.Write(path)
        expected := hasher.Sum(nil)
        return bytes.Equal(expected, proof)
}</span>

func compressPath(stateRoot []byte) []byte <span class="cov0" title="0">{
        // Compress the tree path
        compressed := make([]byte, 16)
        copy(compressed, stateRoot[:16])
        return compressed
}</span>

func hashValidatorSet() []byte <span class="cov0" title="0">{
        // Hash of current validator set
        hasher := sha256.New()
        hasher.Write([]byte("validator_set_v1"))
        return hasher.Sum(nil)
}</span>

func timeNow() int64 <span class="cov0" title="0">{
        return int64(0) // Placeholder
}</span>

func (v *VerkleWitness) cacheWitness(witness *WitnessProof) <span class="cov0" title="0">{
        key := string(witness.StateRoot)
        v.witnessCache[key] = witness

        // Evict old entries if cache is full
        if len(v.witnessCache) &gt; v.cacheSize </span><span class="cov0" title="0">{
                // Simple eviction: remove first entry (could be improved with LRU)
                for k := range v.witnessCache </span><span class="cov0" title="0">{
                        delete(v.witnessCache, k)
                        break</span>
                }
        }
}

func (v *VerkleWitness) verifyBLSAggregate(aggSig []byte, validatorSet []byte) error <span class="cov0" title="0">{
        // Placeholder for BLS aggregate verification
        // In production, this would verify against the validator set
        return nil
}</span>

func (v *VerkleWitness) verifyRingtailThreshold(bits []byte) bool <span class="cov0" title="0">{
        count := countSetBits(bits)
        return count &gt;= v.minThreshold
}</span>

// GetCachedWitness retrieves a cached witness if available
func (v *VerkleWitness) GetCachedWitness(stateRoot []byte) (*WitnessProof, bool) <span class="cov0" title="0">{
        v.mu.RLock()
        defer v.mu.RUnlock()

        witness, exists := v.witnessCache[string(stateRoot)]
        return witness, exists
}</span>

// WitnessSize returns the size of a witness in bytes
func (w *WitnessProof) Size() int <span class="cov0" title="0">{
        return len(w.Commitment) + len(w.Path) + len(w.OpeningProof) +
                len(w.BLSAggregate) + len(w.RingtailBits) + len(w.ValidatorSet) +
                8 + len(w.StateRoot) + 8 // BlockHeight + StateRoot + Timestamp
}</span>

// IsLightweight checks if witness is under 1KB (hyper-efficient)
func (w *WitnessProof) IsLightweight() bool <span class="cov0" title="0">{
        return w.Size() &lt; 1024
}</span>

// CompressedWitness creates an even smaller witness for network transmission
type CompressedWitness struct {
        CommitmentAndProof []byte // Combined commitment + proof
        Metadata           uint64 // Packed height + timestamp
        Validators         uint32 // Validator bitfield (up to 32 validators)
}

// Compress creates a compressed witness (&lt; 200 bytes)
func (w *WitnessProof) Compress() *CompressedWitness <span class="cov0" title="0">{
        // Combine commitment and opening proof
        combined := append(w.Commitment[:16], w.OpeningProof[:16]...)

        // Pack metadata
        metadata := (w.BlockHeight &lt;&lt; 32) | (w.Timestamp &amp; 0xFFFFFFFF)

        // Compress validator bits to uint32 (supports up to 32 validators)
        var validatorBits uint32
        for i := 0; i &lt; len(w.RingtailBits) &amp;&amp; i &lt; 4; i++ </span><span class="cov0" title="0">{
                validatorBits |= uint32(w.RingtailBits[i]) &lt;&lt; (i * 8)
        }</span>

        <span class="cov0" title="0">return &amp;CompressedWitness{
                CommitmentAndProof: combined,
                Metadata:           metadata,
                Validators:         validatorBits,
        }</span>
}

// Size returns size of compressed witness
func (c *CompressedWitness) Size() int <span class="cov0" title="0">{
        return len(c.CommitmentAndProof) + 8 + 4 // ~44 bytes
}</span>

// VerifyCompressed verifies a compressed witness (ultra-fast)
func (v *VerkleWitness) VerifyCompressed(cw *CompressedWitness) error <span class="cov0" title="0">{
        // Extract validator count from bitfield
        validatorCount := 0
        for i := uint32(0); i &lt; 32; i++ </span><span class="cov0" title="0">{
                if cw.Validators&amp;(1&lt;&lt;i) != 0 </span><span class="cov0" title="0">{
                        validatorCount++
                }</span>
        }

        // Check threshold (assuming PQ finality)
        <span class="cov0" title="0">if validatorCount &lt; v.minThreshold </span><span class="cov0" title="0">{
                return errors.New("insufficient validators")
        }</span>

        // With PQ finality assumption, we're done!
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package ray

import (
        "context"

        "github.com/luxfi/consensus/types"
)

// Nova implements the Nova consensus protocol
type Nova struct {
        nodeID types.NodeID
        round  uint64
}

// New creates a new Nova instance
func New(nodeID types.NodeID) *Nova <span class="cov0" title="0">{
        return &amp;Nova{
                nodeID: nodeID,
                round:  0,
        }
}</span>

// Start starts the Nova protocol
func (n *Nova) Start(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// Stop stops the Nova protocol
func (n *Nova) Stop(ctx context.Context) error <span class="cov0" title="0">{
        return nil
}</span>

// Round returns the current round
func (n *Nova) Round() uint64 <span class="cov0" title="0">{
        return n.round
}</span>

// Propose proposes a value
func (n *Nova) Propose(ctx context.Context, value []byte) error <span class="cov0" title="0">{
        n.round++
        return nil
}</span>
</pre>
		
		<pre class="file" id="file78" style="display: none">package ray

import (
        "context"
        "time"

        "github.com/luxfi/consensus/prism"
        "github.com/luxfi/consensus/types"
        "github.com/luxfi/consensus/wave"
)

// ID is your item identifier (block hash, tx id, etc.).
type ID interface{ comparable }

// Source lets Ray pull next candidates to decide in linear order.
type Source[T ID] interface {
        NextPending(ctx context.Context, n int) []T
}

// Sink receives final decisions in order.
type Sink[T ID] interface {
        Decide(ctx context.Context, items []T, d types.Decision) error
}

// Transport bridges network vote requests &lt;-&gt; Photons the Wave consumes.
type Transport[T ID] interface {
        RequestVotes(ctx context.Context, peers []types.NodeID, item T) &lt;-chan wave.Photon[T]
        MakeLocalPhoton(item T, prefer bool) wave.Photon[T]
}

type Config struct {
        PollSize int
        Alpha    float64
        Beta     uint32
        RoundTO  time.Duration
        MaxBatch int
}

type Driver[T ID] struct {
        wv            wave.Wave[T]
        cut           prism.Cut[T]
        tx            Transport[T]
        src           Source[T]
        out           Sink[T]
        cfg           Config
        height        uint64
        preference    T
        hasPreference bool
}

func NewDriver[T ID](cfg Config, cut prism.Cut[T], tx Transport[T], src Source[T], out Sink[T]) *Driver[T] <span class="cov0" title="0">{
        if cfg.PollSize == 0 </span><span class="cov0" title="0">{
                cfg.PollSize = 20
        }</span>
        <span class="cov0" title="0">if cfg.Alpha == 0 </span><span class="cov0" title="0">{
                cfg.Alpha = 0.8
        }</span>
        <span class="cov0" title="0">if cfg.Beta == 0 </span><span class="cov0" title="0">{
                cfg.Beta = 15
        }</span>
        <span class="cov0" title="0">if cfg.RoundTO == 0 </span><span class="cov0" title="0">{
                cfg.RoundTO = 250 * time.Millisecond
        }</span>
        <span class="cov0" title="0">if cfg.MaxBatch == 0 </span><span class="cov0" title="0">{
                cfg.MaxBatch = 64
        }</span>

        <span class="cov0" title="0">return &amp;Driver[T]{
                wv:  wave.New[T](wave.Config{K: cfg.PollSize, Alpha: cfg.Alpha, Beta: cfg.Beta, RoundTO: cfg.RoundTO}, cut, tx),
                cut: cut, tx: tx, src: src, out: out, cfg: cfg,
                height:        0,
                hasPreference: false,
        }</span>
}

// Tick drives one sampling round across up to MaxBatch pending items.
// Any that reach β are emitted to Sink in input order with their decision.
func (d *Driver[T]) Tick(ctx context.Context) error <span class="cov0" title="0">{
        items := d.src.NextPending(ctx, d.cfg.MaxBatch)
        if len(items) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var decided []T
        for _, it := range items </span><span class="cov0" title="0">{
                d.wv.Tick(ctx, it)
                if st, ok := d.wv.State(it); ok &amp;&amp; st.Decided </span><span class="cov0" title="0">{
                        if st.Result == types.DecideAccept </span><span class="cov0" title="0">{
                                decided = append(decided, it)
                        }</span>
                }
        }
        <span class="cov0" title="0">if len(decided) &gt; 0 </span><span class="cov0" title="0">{
                if len(decided) &gt; 0 </span><span class="cov0" title="0">{
                        d.preference = decided[0] // Update preference to latest decided
                        d.hasPreference = true
                        d.height++
                }</span>
                <span class="cov0" title="0">return d.out.Decide(ctx, decided, types.DecideAccept)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Start begins the Ray engine operation
func (d *Driver[T]) Start(ctx context.Context) error <span class="cov0" title="0">{
        // Ray engine is stateless and starts immediately
        return nil
}</span>

// Stop ends the Ray engine operation
func (d *Driver[T]) Stop(ctx context.Context) error <span class="cov0" title="0">{
        // Ray engine is stateless and stops immediately
        return nil
}</span>

// Propose proposes an item for consensus (Nova will use this for blocks)
func (d *Driver[T]) Propose(ctx context.Context, item T) error <span class="cov0" title="0">{
        // In Ray, proposals are handled through the Source interface
        // This is a convenience method for direct proposals
        d.wv.Tick(ctx, item)
        return nil
}</span>

// GetPreference returns the current preferred item
func (d *Driver[T]) GetPreference() (T, bool) <span class="cov0" title="0">{
        return d.preference, d.hasPreference
}</span>

// IsFinalized checks if an item is finalized
func (d *Driver[T]) IsFinalized(item T) bool <span class="cov0" title="0">{
        if state, exists := d.wv.State(item); exists </span><span class="cov0" title="0">{
                return state.Decided &amp;&amp; state.Result == types.DecideAccept
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Height returns the current consensus height (for linear chains)
func (d *Driver[T]) Height() uint64 <span class="cov0" title="0">{
        return d.height
}</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package qzmq

import (
        "encoding/binary"
        "fmt"
        "io"
)

// Message types
const (
        TypeClientHello uint8 = 0x01
        TypeServerHello uint8 = 0x02
        TypeClientKey   uint8 = 0x03
        TypeFinished    uint8 = 0x04
        TypeData        uint8 = 0x05
        TypeKeyUpdate   uint8 = 0x06
)

// ClientHello initiates the handshake
type ClientHello struct {
        Version      byte
        CipherSuites []byte
        X25519Public []byte
        Random       []byte
}

// Write serializes ClientHello
func (m *ClientHello) Write(w io.Writer) error <span class="cov8" title="1">{
        // Type
        if err := binary.Write(w, binary.BigEndian, TypeClientHello); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Version
        <span class="cov8" title="1">if err := binary.Write(w, binary.BigEndian, m.Version); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // CipherSuites length and data
        <span class="cov8" title="1">csLen := len(m.CipherSuites)
        if csLen &gt; 0xFFFF </span><span class="cov0" title="0">{
                return fmt.Errorf("cipher suites too long: %d", csLen)
        }</span>
        <span class="cov8" title="1">if err := binary.Write(w, binary.BigEndian, uint16(csLen)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := w.Write(m.CipherSuites); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // X25519 public key
        <span class="cov8" title="1">if _, err := w.Write(m.X25519Public); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Random
        <span class="cov8" title="1">if _, err := w.Write(m.Random); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Read deserializes ClientHello
func (m *ClientHello) Read(r io.Reader) error <span class="cov8" title="1">{
        var msgType uint8
        if err := binary.Read(r, binary.BigEndian, &amp;msgType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if msgType != TypeClientHello </span><span class="cov0" title="0">{
                return fmt.Errorf("expected ClientHello, got type %d", msgType)
        }</span>

        <span class="cov8" title="1">if err := binary.Read(r, binary.BigEndian, &amp;m.Version); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var suitesLen uint16
        if err := binary.Read(r, binary.BigEndian, &amp;suitesLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">m.CipherSuites = make([]byte, suitesLen)
        if _, err := io.ReadFull(r, m.CipherSuites); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">m.X25519Public = make([]byte, X25519KeySize)
        if _, err := io.ReadFull(r, m.X25519Public); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">m.Random = make([]byte, 32)
        if _, err := io.ReadFull(r, m.Random); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ServerHello responds to ClientHello
type ServerHello struct {
        CipherSuite  byte
        X25519Public []byte
        MLKEMPublic  []byte
        MLDSAPublic  []byte
        Random       []byte
        Signature    []byte
}

// Write serializes ServerHello
func (m *ServerHello) Write(w io.Writer) error <span class="cov8" title="1">{
        if err := binary.Write(w, binary.BigEndian, TypeServerHello); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := binary.Write(w, binary.BigEndian, m.CipherSuite); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := w.Write(m.X25519Public); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := w.Write(m.MLKEMPublic); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := w.Write(m.MLDSAPublic); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := w.Write(m.Random); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Signature length and data
        <span class="cov8" title="1">sigLen := len(m.Signature)
        if sigLen &gt; 0xFFFF </span><span class="cov0" title="0">{
                return fmt.Errorf("signature too long: %d", sigLen)
        }</span>
        <span class="cov8" title="1">if err := binary.Write(w, binary.BigEndian, uint16(sigLen)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := w.Write(m.Signature); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Read deserializes ServerHello
func (m *ServerHello) Read(r io.Reader) error <span class="cov8" title="1">{
        var msgType uint8
        if err := binary.Read(r, binary.BigEndian, &amp;msgType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if msgType != TypeServerHello </span><span class="cov0" title="0">{
                return fmt.Errorf("expected ServerHello, got type %d", msgType)
        }</span>

        <span class="cov8" title="1">if err := binary.Read(r, binary.BigEndian, &amp;m.CipherSuite); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">m.X25519Public = make([]byte, X25519KeySize)
        if _, err := io.ReadFull(r, m.X25519Public); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">m.MLKEMPublic = make([]byte, MLKEMKeySize)
        if _, err := io.ReadFull(r, m.MLKEMPublic); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">m.MLDSAPublic = make([]byte, MLDSAKeySize)
        if _, err := io.ReadFull(r, m.MLDSAPublic); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">m.Random = make([]byte, 32)
        if _, err := io.ReadFull(r, m.Random); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var sigLen uint16
        if err := binary.Read(r, binary.BigEndian, &amp;sigLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">m.Signature = make([]byte, sigLen)
        if _, err := io.ReadFull(r, m.Signature); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ClientKey contains KEM ciphertext
type ClientKey struct {
        KEMCiphertext []byte
        PSKBinder     []byte // Optional for resumption
        AuthSignature []byte // Optional for client auth
}

// Write serializes ClientKey
func (m *ClientKey) Write(w io.Writer) error <span class="cov0" title="0">{
        if err := binary.Write(w, binary.BigEndian, TypeClientKey); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // KEM ciphertext length and data
        <span class="cov0" title="0">kemLen := len(m.KEMCiphertext)
        if kemLen &gt; 0xFFFF </span><span class="cov0" title="0">{
                return fmt.Errorf("KEM ciphertext too long: %d", kemLen)
        }</span>
        <span class="cov0" title="0">if err := binary.Write(w, binary.BigEndian, uint16(kemLen)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := w.Write(m.KEMCiphertext); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // PSK binder (optional)
        <span class="cov0" title="0">pskLen := len(m.PSKBinder)
        if pskLen &gt; 0xFFFF </span><span class="cov0" title="0">{
                return fmt.Errorf("PSK binder too long: %d", pskLen)
        }</span>
        <span class="cov0" title="0">if err := binary.Write(w, binary.BigEndian, uint16(pskLen)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if pskLen &gt; 0 </span><span class="cov0" title="0">{
                if _, err := w.Write(m.PSKBinder); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Auth signature (optional)
        <span class="cov0" title="0">authLen := len(m.AuthSignature)
        if authLen &gt; 0xFFFF </span><span class="cov0" title="0">{
                return fmt.Errorf("auth signature too long: %d", authLen)
        }</span>
        <span class="cov0" title="0">if err := binary.Write(w, binary.BigEndian, uint16(authLen)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if authLen &gt; 0 </span><span class="cov0" title="0">{
                if _, err := w.Write(m.AuthSignature); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Read deserializes ClientKey
func (m *ClientKey) Read(r io.Reader) error <span class="cov0" title="0">{
        var msgType uint8
        if err := binary.Read(r, binary.BigEndian, &amp;msgType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if msgType != TypeClientKey </span><span class="cov0" title="0">{
                return fmt.Errorf("expected ClientKey, got type %d", msgType)
        }</span>

        <span class="cov0" title="0">var kemLen uint16
        if err := binary.Read(r, binary.BigEndian, &amp;kemLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">m.KEMCiphertext = make([]byte, kemLen)
        if _, err := io.ReadFull(r, m.KEMCiphertext); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var pskLen uint16
        if err := binary.Read(r, binary.BigEndian, &amp;pskLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if pskLen &gt; 0 </span><span class="cov0" title="0">{
                m.PSKBinder = make([]byte, pskLen)
                if _, err := io.ReadFull(r, m.PSKBinder); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">var authLen uint16
        if err := binary.Read(r, binary.BigEndian, &amp;authLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if authLen &gt; 0 </span><span class="cov0" title="0">{
                m.AuthSignature = make([]byte, authLen)
                if _, err := io.ReadFull(r, m.AuthSignature); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// DataMessage carries encrypted application data
type DataMessage struct {
        StreamID uint32
        SeqNo    uint64
        Data     []byte // Encrypted data with AEAD tag
}

// Write serializes DataMessage
func (m *DataMessage) Write(w io.Writer) error <span class="cov8" title="1">{
        if err := binary.Write(w, binary.BigEndian, TypeData); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := binary.Write(w, binary.BigEndian, m.StreamID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := binary.Write(w, binary.BigEndian, m.SeqNo); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">dataLen := len(m.Data)
        if dataLen &gt; 0x7FFFFFFF </span><span class="cov0" title="0">{ // Max int32 to be safe
                return fmt.Errorf("data too long: %d", dataLen)
        }</span>
        <span class="cov8" title="1">if err := binary.Write(w, binary.BigEndian, uint32(dataLen)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if _, err := w.Write(m.Data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Read deserializes DataMessage
func (m *DataMessage) Read(r io.Reader) error <span class="cov8" title="1">{
        var msgType uint8
        if err := binary.Read(r, binary.BigEndian, &amp;msgType); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if msgType != TypeData </span><span class="cov0" title="0">{
                return fmt.Errorf("expected DataMessage, got type %d", msgType)
        }</span>

        <span class="cov8" title="1">if err := binary.Read(r, binary.BigEndian, &amp;m.StreamID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := binary.Read(r, binary.BigEndian, &amp;m.SeqNo); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var dataLen uint32
        if err := binary.Read(r, binary.BigEndian, &amp;dataLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">m.Data = make([]byte, dataLen)
        if _, err := io.ReadFull(r, m.Data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">// Package qzmq provides post-quantum secure transport over ZeroMQ.
// It implements a hybrid classical-quantum key exchange and encryption protocol
// suitable for both consensus messages and general secure communication.
package qzmq

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/sha256"
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "sync"
        "time"
        // These imports are temporarily commented out due to depguard restrictions
        // "golang.org/x/crypto/chacha20poly1305"
        // "golang.org/x/crypto/hkdf"
)

const (
        // Protocol version
        Version byte = 1

        // Cipher suites
        SuiteAES256GCM        = 0x01
        SuiteChaCha20Poly1305 = 0x02

        // Key sizes
        X25519KeySize = 32
        MLKEMKeySize  = 1184 // ML-KEM-768 public key size
        MLDSAKeySize  = 1312 // ML-DSA-44 public key size

        // Nonce and tag sizes
        NonceSize = 12
        TagSize   = 16

        // Key rotation thresholds
        MaxMessagesPerKey = 1 &lt;&lt; 32 // 2^32 messages
        MaxBytesPerKey    = 1 &lt;&lt; 50 // 2^50 bytes
        MaxKeyAge         = 10 * time.Minute
)

var (
        ErrInvalidVersion     = errors.New("invalid protocol version")
        ErrInvalidCipherSuite = errors.New("invalid cipher suite")
        ErrKeyRotationNeeded  = errors.New("key rotation needed")
        ErrInvalidNonce       = errors.New("invalid nonce")
        ErrAuthFailed         = errors.New("authentication failed")
        ErrHandshakeTimeout   = errors.New("handshake timeout")
)

// KeyPair represents a hybrid classical-quantum key pair
type KeyPair struct {
        X25519Private []byte // Classical ECDH private key
        X25519Public  []byte // Classical ECDH public key
        MLKEMPrivate  []byte // ML-KEM private key
        MLKEMPublic   []byte // ML-KEM public key
        MLDSAPrivate  []byte // ML-DSA private key for signatures
        MLDSAPublic   []byte // ML-DSA public key for signatures
}

// GenerateKeyPair generates a new hybrid key pair
func GenerateKeyPair() (*KeyPair, error) <span class="cov8" title="1">{
        kp := &amp;KeyPair{
                X25519Private: make([]byte, X25519KeySize),
                X25519Public:  make([]byte, X25519KeySize),
                MLKEMPrivate:  make([]byte, MLKEMKeySize*2), // Private key is larger
                MLKEMPublic:   make([]byte, MLKEMKeySize),
                MLDSAPrivate:  make([]byte, MLDSAKeySize*2), // Private key is larger
                MLDSAPublic:   make([]byte, MLDSAKeySize),
        }

        // Generate X25519 keys (placeholder - would use actual X25519)
        if _, err := rand.Read(kp.X25519Private); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generate X25519 private: %w", err)
        }</span>
        <span class="cov8" title="1">if _, err := rand.Read(kp.X25519Public); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generate X25519 public: %w", err)
        }</span>

        // Generate ML-KEM keys (placeholder - would use liboqs)
        <span class="cov8" title="1">if _, err := rand.Read(kp.MLKEMPrivate); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generate ML-KEM private: %w", err)
        }</span>
        <span class="cov8" title="1">if _, err := rand.Read(kp.MLKEMPublic); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generate ML-KEM public: %w", err)
        }</span>

        // Generate ML-DSA keys (placeholder - would use liboqs)
        <span class="cov8" title="1">if _, err := rand.Read(kp.MLDSAPrivate); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generate ML-DSA private: %w", err)
        }</span>
        <span class="cov8" title="1">if _, err := rand.Read(kp.MLDSAPublic); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("generate ML-DSA public: %w", err)
        }</span>

        <span class="cov8" title="1">return kp, nil</span>
}

// Session represents a QZMQ secure session
type Session struct {
        mu sync.RWMutex

        // Configuration
        suite    byte
        isServer bool

        // Keys
        localKeys  *KeyPair
        remoteKeys *KeyPair

        // Derived keys
        sendKey   []byte
        recvKey   []byte
        sendNonce uint64
        recvNonce uint64

        // Key rotation tracking
        msgCount  uint64
        byteCount uint64
        keyTime   time.Time

        // Cipher
        sendCipher cipher.AEAD
        recvCipher cipher.AEAD
}

// NewSession creates a new QZMQ session
func NewSession(localKeys *KeyPair, isServer bool) (*Session, error) <span class="cov8" title="1">{
        return &amp;Session{
                suite:     SuiteAES256GCM,
                isServer:  isServer,
                localKeys: localKeys,
                keyTime:   time.Now(),
        }, nil
}</span>

// Handshake performs the 1-RTT handshake
func (s *Session) Handshake(transport io.ReadWriter) error <span class="cov0" title="0">{
        if s.isServer </span><span class="cov0" title="0">{
                return s.serverHandshake(transport)
        }</span>
        <span class="cov0" title="0">return s.clientHandshake(transport)</span>
}

// clientHandshake performs client side of handshake
func (s *Session) clientHandshake(transport io.ReadWriter) error <span class="cov0" title="0">{
        // Send ClientHello
        hello := &amp;ClientHello{
                Version:      Version,
                CipherSuites: []byte{SuiteAES256GCM, SuiteChaCha20Poly1305},
                X25519Public: s.localKeys.X25519Public,
                Random:       make([]byte, 32),
        }
        if _, err := rand.Read(hello.Random); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generate random: %w", err)
        }</span>

        <span class="cov0" title="0">if err := hello.Write(transport); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write ClientHello: %w", err)
        }</span>

        // Receive ServerHello
        <span class="cov0" title="0">serverHello := &amp;ServerHello{}
        if err := serverHello.Read(transport); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read ServerHello: %w", err)
        }</span>

        // Verify signature (placeholder - would use ML-DSA)
        <span class="cov0" title="0">s.suite = serverHello.CipherSuite
        s.remoteKeys = &amp;KeyPair{
                X25519Public: serverHello.X25519Public,
                MLKEMPublic:  serverHello.MLKEMPublic,
                MLDSAPublic:  serverHello.MLDSAPublic,
        }

        // Compute shared secrets and derive keys
        if err := s.deriveKeys(hello.Random, serverHello.Random); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("derive keys: %w", err)
        }</span>

        // Send ClientKey with KEM ciphertext
        <span class="cov0" title="0">clientKey := &amp;ClientKey{
                KEMCiphertext: make([]byte, 1088), // ML-KEM-768 ciphertext size
        }
        if _, err := rand.Read(clientKey.KEMCiphertext); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generate KEM ciphertext: %w", err)
        }</span>

        <span class="cov0" title="0">return clientKey.Write(transport)</span>
}

// serverHandshake performs server side of handshake
func (s *Session) serverHandshake(transport io.ReadWriter) error <span class="cov0" title="0">{
        // Receive ClientHello
        hello := &amp;ClientHello{}
        if err := hello.Read(transport); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read ClientHello: %w", err)
        }</span>

        <span class="cov0" title="0">if hello.Version != Version </span><span class="cov0" title="0">{
                return ErrInvalidVersion
        }</span>

        // Select cipher suite
        <span class="cov0" title="0">s.suite = selectCipherSuite(hello.CipherSuites)
        if s.suite == 0 </span><span class="cov0" title="0">{
                return ErrInvalidCipherSuite
        }</span>

        // Send ServerHello
        <span class="cov0" title="0">serverHello := &amp;ServerHello{
                CipherSuite:  s.suite,
                X25519Public: s.localKeys.X25519Public,
                MLKEMPublic:  s.localKeys.MLKEMPublic,
                MLDSAPublic:  s.localKeys.MLDSAPublic,
                Random:       make([]byte, 32),
                Signature:    make([]byte, 2420), // ML-DSA-44 signature size
        }
        if _, err := rand.Read(serverHello.Random); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generate random: %w", err)
        }</span>
        <span class="cov0" title="0">if _, err := rand.Read(serverHello.Signature); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generate signature: %w", err)
        }</span>

        <span class="cov0" title="0">if err := serverHello.Write(transport); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("write ServerHello: %w", err)
        }</span>

        // Receive ClientKey
        <span class="cov0" title="0">clientKey := &amp;ClientKey{}
        if err := clientKey.Read(transport); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("read ClientKey: %w", err)
        }</span>

        // Derive keys
        <span class="cov0" title="0">s.remoteKeys = &amp;KeyPair{
                X25519Public: hello.X25519Public,
        }

        return s.deriveKeys(hello.Random, serverHello.Random)</span>
}

// deriveKeys derives session keys from shared secrets
func (s *Session) deriveKeys(clientRandom, serverRandom []byte) error <span class="cov0" title="0">{
        // Placeholder for key derivation
        // In real implementation would:
        // 1. Perform X25519 ECDH
        // 2. Perform ML-KEM decapsulation
        // 3. Combine secrets with HKDF

        secret := make([]byte, 64)
        if _, err := rand.Read(secret); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("generate secret: %w", err)
        }</span>

        // Simple key derivation using SHA256 (placeholder for HKDF)
        <span class="cov0" title="0">salt := append(clientRandom, serverRandom...)
        h := sha256.New()
        h.Write(secret)
        h.Write(salt)
        h.Write([]byte("QZMQ-v1"))
        derived := h.Sum(nil)

        s.sendKey = make([]byte, 32)
        s.recvKey = make([]byte, 32)

        if s.isServer </span><span class="cov0" title="0">{
                copy(s.recvKey, derived[:32])
                h.Reset()
                h.Write(derived)
                copy(s.sendKey, h.Sum(nil)[:32])
        }</span> else<span class="cov0" title="0"> {
                copy(s.sendKey, derived[:32])
                h.Reset()
                h.Write(derived)
                copy(s.recvKey, h.Sum(nil)[:32])
        }</span>

        <span class="cov0" title="0">return s.initCiphers()</span>
}

// initCiphers initializes the ciphers from existing keys
func (s *Session) initCiphers() error <span class="cov8" title="1">{
        var err error
        switch s.suite </span>{
        case SuiteAES256GCM, SuiteChaCha20Poly1305:<span class="cov8" title="1">
                // For now, use AES-GCM for both suites due to import restrictions
                block, _ := aes.NewCipher(s.sendKey)
                s.sendCipher, err = cipher.NewGCM(block)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("create send cipher: %w", err)
                }</span>
                <span class="cov8" title="1">block, _ = aes.NewCipher(s.recvKey)
                s.recvCipher, err = cipher.NewGCM(block)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("create recv cipher: %w", err)
                }</span>
        default:<span class="cov0" title="0">
                return ErrInvalidCipherSuite</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Encrypt encrypts a message
func (s *Session) Encrypt(plaintext []byte) ([]byte, error) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Check if key rotation is needed
        if s.needsRotation() </span><span class="cov0" title="0">{
                return nil, ErrKeyRotationNeeded
        }</span>

        // Generate nonce
        <span class="cov8" title="1">nonce := make([]byte, NonceSize)
        binary.BigEndian.PutUint64(nonce[4:], s.sendNonce)
        s.sendNonce++

        // Encrypt
        ciphertext := s.sendCipher.Seal(nil, nonce, plaintext, nil)

        // Update counters
        s.msgCount++
        s.byteCount += uint64(len(plaintext))

        // Prepend nonce
        return append(nonce, ciphertext...), nil</span>
}

// Decrypt decrypts a message
func (s *Session) Decrypt(ciphertext []byte) ([]byte, error) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if len(ciphertext) &lt; NonceSize </span><span class="cov0" title="0">{
                return nil, ErrInvalidNonce
        }</span>

        <span class="cov8" title="1">nonce := ciphertext[:NonceSize]
        ct := ciphertext[NonceSize:]

        // Verify nonce sequence
        expectedNonce := make([]byte, NonceSize)
        binary.BigEndian.PutUint64(expectedNonce[4:], s.recvNonce)
        s.recvNonce++

        // Decrypt
        plaintext, err := s.recvCipher.Open(nil, nonce, ct, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, ErrAuthFailed
        }</span>

        <span class="cov8" title="1">return plaintext, nil</span>
}

// needsRotation checks if key rotation is needed
func (s *Session) needsRotation() bool <span class="cov8" title="1">{
        return s.msgCount &gt;= MaxMessagesPerKey ||
                s.byteCount &gt;= MaxBytesPerKey ||
                time.Since(s.keyTime) &gt;= MaxKeyAge
}</span>

// RotateKeys performs key ratcheting
func (s *Session) RotateKeys() error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Ratchet keys using SHA256 (placeholder for HKDF)
        h := sha256.New()
        h.Write(s.sendKey)
        h.Write([]byte("ratchet"))
        newSendKey := h.Sum(nil)[:32]

        h.Reset()
        h.Write(s.recvKey)
        h.Write([]byte("ratchet"))
        newRecvKey := h.Sum(nil)[:32]

        s.sendKey = make([]byte, 32)
        s.recvKey = make([]byte, 32)
        copy(s.sendKey, newSendKey)
        copy(s.recvKey, newRecvKey)

        // Reinitialize ciphers using the helper method
        if err := s.initCiphers(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Reset counters
        <span class="cov8" title="1">s.msgCount = 0
        s.byteCount = 0
        s.keyTime = time.Now()
        s.sendNonce = 0
        s.recvNonce = 0

        return nil</span>
}

// selectCipherSuite selects the best supported cipher suite
func selectCipherSuite(suites []byte) byte <span class="cov8" title="1">{
        for _, suite := range suites </span><span class="cov8" title="1">{
                if suite == SuiteAES256GCM || suite == SuiteChaCha20Poly1305 </span><span class="cov8" title="1">{
                        return suite
                }</span>
        }
        <span class="cov8" title="1">return 0</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">package snowman

import (
        "context"

        "github.com/luxfi/consensus/utils/bag"
        "github.com/luxfi/ids"
)

// Bag is an alias for bag.Bag
type Bag = bag.Bag

// Consensus implements Snowman consensus
type Consensus interface {
        // Initialize initializes consensus
        Initialize(context.Context, *Config) error

        // Add adds a block to consensus
        Add(context.Context, Block) error

        // RecordPoll records poll results
        RecordPoll(context.Context, *Bag) error

        // Finalized checks if finalized
        Finalized() bool

        // Parameters returns consensus parameters
        Parameters() Parameters

        // Preference returns the preferred block
        Preference() ids.ID

        // HealthCheck performs health check
        HealthCheck(context.Context) (interface{}, error)
}

// Block represents a Snowman block
type Block interface {
        ID() ids.ID
        ParentID() ids.ID
        Height() uint64
        Verify(context.Context) error
        Accept(context.Context) error
        Reject(context.Context) error
        Bytes() []byte
}

// Config defines Snowman configuration
type Config struct {
        Beta              int
        ConcurrentRepolls int
        OptimalProcessing int
}

// Parameters defines consensus parameters
type Parameters struct {
        K                 int
        Alpha             int
        BetaVirtuous      int
        BetaRogue         int
        ConcurrentRepolls int
        OptimalProcessing int
}

// Topological provides topological Snowman consensus
type Topological struct {
        config     *Config
        preference ids.ID
        finalized  bool
}

// NewTopological creates a new topological Snowman instance
func NewTopological(config *Config) *Topological <span class="cov0" title="0">{
        return &amp;Topological{
                config:    config,
                finalized: false,
        }
}</span>

// Initialize initializes consensus
func (t *Topological) Initialize(ctx context.Context, config *Config) error <span class="cov0" title="0">{
        t.config = config
        return nil
}</span>

// Add adds a block to consensus
func (t *Topological) Add(ctx context.Context, block Block) error <span class="cov0" title="0">{
        if t.preference == (ids.ID{}) </span><span class="cov0" title="0">{
                t.preference = block.ID()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// RecordPoll records poll results
func (t *Topological) RecordPoll(ctx context.Context, votes *Bag) error <span class="cov0" title="0">{
        return nil
}</span>

// Finalized checks if finalized
func (t *Topological) Finalized() bool <span class="cov0" title="0">{
        return t.finalized
}</span>

// Parameters returns consensus parameters
func (t *Topological) Parameters() Parameters <span class="cov0" title="0">{
        return Parameters{
                K:                 1,
                Alpha:             1,
                BetaVirtuous:      t.config.Beta,
                BetaRogue:         t.config.Beta,
                ConcurrentRepolls: t.config.ConcurrentRepolls,
                OptimalProcessing: t.config.OptimalProcessing,
        }
}</span>

// Preference returns the preferred block
func (t *Topological) Preference() ids.ID <span class="cov0" title="0">{
        return t.preference
}</span>

// HealthCheck performs health check
func (t *Topological) HealthCheck(ctx context.Context) (interface{}, error) <span class="cov0" title="0">{
        return map[string]interface{}{
                "finalized":  t.finalized,
                "preference": t.preference.String(),
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">// Copyright (C) 2019-2024, Lux Partners Limited All rights reserved.
// See the file LICENSE for licensing terms.

package uptime

// LockedCalculator is a wrapper for a Calculator that ensures thread-safety
type LockedCalculator interface {
        Calculator
}

// NewLockedCalculator returns a new LockedCalculator
func NewLockedCalculator() LockedCalculator <span class="cov0" title="0">{
        return &amp;lockedCalculator{}
}</span>

type lockedCalculator struct {
        NoOpCalculator
}
</pre>
		
		<pre class="file" id="file83" style="display: none">// Package uptime provides uptime calculation functionality
package uptime

import (
        "time"

        "github.com/luxfi/ids"
)

// Calculator calculates uptime
type Calculator interface {
        CalculateUptime(nodeID ids.NodeID, subnetID ids.ID) (time.Duration, time.Duration, error)
        CalculateUptimePercent(nodeID ids.NodeID, subnetID ids.ID) (float64, error)
        CalculateUptimePercentFrom(nodeID ids.NodeID, subnetID ids.ID, from time.Time) (float64, error)
        SetCalculator(subnetID ids.ID, calc Calculator) error
}

// NoOpCalculator is a no-op implementation of Calculator
type NoOpCalculator struct{}

// CalculateUptime always returns 100% uptime
func (NoOpCalculator) CalculateUptime(ids.NodeID, ids.ID) (time.Duration, time.Duration, error) <span class="cov0" title="0">{
        return 0, 0, nil
}</span>

// CalculateUptimePercent always returns 100% uptime
func (NoOpCalculator) CalculateUptimePercent(ids.NodeID, ids.ID) (float64, error) <span class="cov0" title="0">{
        return 1.0, nil
}</span>

// CalculateUptimePercentFrom always returns 100% uptime
func (NoOpCalculator) CalculateUptimePercentFrom(ids.NodeID, ids.ID, time.Time) (float64, error) <span class="cov0" title="0">{
        return 1.0, nil
}</span>

// SetCalculator is a no-op
func (NoOpCalculator) SetCalculator(ids.ID, Calculator) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">// Package uptimemock provides mock implementations for uptime tracking
package uptimemock

import (
        "time"

        "github.com/luxfi/consensus/types"
)

// MockUptimeTracker provides a mock implementation for uptime tracking
type MockUptimeTracker struct {
        uptimes map[types.NodeID]time.Duration
        starts  map[types.NodeID]time.Time
}

// NewMockUptimeTracker creates a new mock uptime tracker
func NewMockUptimeTracker() *MockUptimeTracker <span class="cov0" title="0">{
        return &amp;MockUptimeTracker{
                uptimes: make(map[types.NodeID]time.Duration),
                starts:  make(map[types.NodeID]time.Time),
        }
}</span>

// StartTracking starts tracking uptime for a node
func (m *MockUptimeTracker) StartTracking(nodeID types.NodeID) <span class="cov0" title="0">{
        m.starts[nodeID] = time.Now()
}</span>

// StopTracking stops tracking uptime for a node
func (m *MockUptimeTracker) StopTracking(nodeID types.NodeID) <span class="cov0" title="0">{
        if start, exists := m.starts[nodeID]; exists </span><span class="cov0" title="0">{
                duration := time.Since(start)
                m.uptimes[nodeID] += duration
                delete(m.starts, nodeID)
        }</span>
}

// GetUptime returns the total uptime for a node
func (m *MockUptimeTracker) GetUptime(nodeID types.NodeID) time.Duration <span class="cov0" title="0">{
        uptime := m.uptimes[nodeID]
        if start, exists := m.starts[nodeID]; exists </span><span class="cov0" title="0">{
                uptime += time.Since(start)
        }</span>
        <span class="cov0" title="0">return uptime</span>
}

// IsTracking returns whether a node is currently being tracked
func (m *MockUptimeTracker) IsTracking(nodeID types.NodeID) bool <span class="cov0" title="0">{
        _, exists := m.starts[nodeID]
        return exists
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">package bag

import "github.com/luxfi/ids"

// Bag is a collection of IDs with counts
type Bag struct {
        counts map[ids.ID]int
}

// New creates a new bag
func New() *Bag <span class="cov0" title="0">{
        return &amp;Bag{
                counts: make(map[ids.ID]int),
        }
}</span>

// Add adds an ID to the bag
func (b *Bag) Add(id ids.ID) <span class="cov0" title="0">{
        b.counts[id]++
}</span>

// Count returns the count for an ID
func (b *Bag) Count(id ids.ID) int <span class="cov0" title="0">{
        return b.counts[id]
}</span>

// Len returns the number of unique IDs
func (b *Bag) Len() int <span class="cov0" title="0">{
        return len(b.counts)
}</span>

// List returns all IDs in the bag
func (b *Bag) List() []ids.ID <span class="cov0" title="0">{
        list := make([]ids.ID, 0, len(b.counts))
        for id := range b.counts </span><span class="cov0" title="0">{
                list = append(list, id)
        }</span>
        <span class="cov0" title="0">return list</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package set

import "github.com/luxfi/math/set"

// Re-export set types from math package
type Set[T comparable] = set.Set[T]

// Of creates a new set
func Of[T comparable](elements ...T) Set[T] <span class="cov0" title="0">{
        return set.Of(elements...)
}</span>

// NewSet creates a new empty set
func NewSet[T comparable](size int) Set[T] <span class="cov0" title="0">{
        return make(Set[T], size)
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">package mockable

import "time"

// Clock is a mockable clock
type Clock struct {
        time   time.Time
        mocked bool
}

// NewClock creates a new clock
func NewClock() *Clock <span class="cov0" title="0">{
        return &amp;Clock{
                time: time.Now(),
        }
}</span>

// Now returns current time
func (c *Clock) Now() time.Time <span class="cov0" title="0">{
        if c.mocked </span><span class="cov0" title="0">{
                return c.time
        }</span>
        <span class="cov0" title="0">return time.Now()</span>
}

// Set sets the clock time
func (c *Clock) Set(t time.Time) <span class="cov0" title="0">{
        c.time = t
        c.mocked = true
}</span>

// Advance advances the clock
func (c *Clock) Advance(d time.Duration) <span class="cov0" title="0">{
        c.time = c.time.Add(d)
}</span>

// Real returns to real time
func (c *Clock) Real() <span class="cov0" title="0">{
        c.mocked = false
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">package utils

import (
        "sort"
)

// Sort sorts a slice
func Sort[T any](slice []T, less func(i, j int) bool) <span class="cov0" title="0">{
        sort.Slice(slice, less)
}</span>

// SortByID sorts by ID
func SortByID[T interface{ ID() string }](slice []T) <span class="cov0" title="0">{
        sort.Slice(slice, func(i, j int) bool </span><span class="cov0" title="0">{
                return slice[i].ID() &lt; slice[j].ID()
        }</span>)
}

// Contains checks if slice contains element
func Contains[T comparable](slice []T, elem T) bool <span class="cov0" title="0">{
        for _, v := range slice </span><span class="cov0" title="0">{
                if v == elem </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Filter filters a slice
func Filter[T any](slice []T, predicate func(T) bool) []T <span class="cov0" title="0">{
        result := make([]T, 0, len(slice))
        for _, v := range slice </span><span class="cov0" title="0">{
                if predicate(v) </span><span class="cov0" title="0">{
                        result = append(result, v)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file89" style="display: none">package validators

import (
        "github.com/luxfi/ids"
)

// NewManager creates a new validator manager
func NewManager() *manager <span class="cov0" title="0">{
        return &amp;manager{
                validators: make(map[ids.ID]map[ids.NodeID]*GetValidatorOutput),
        }
}</span>

type manager struct {
        validators map[ids.ID]map[ids.NodeID]*GetValidatorOutput
}

// AddStaker adds a validator to the set
func (m *manager) AddStaker(netID ids.ID, nodeID ids.NodeID, publicKey []byte, txID ids.ID, light uint64) error <span class="cov0" title="0">{
        if m.validators[netID] == nil </span><span class="cov0" title="0">{
                m.validators[netID] = make(map[ids.NodeID]*GetValidatorOutput)
        }</span>

        <span class="cov0" title="0">m.validators[netID][nodeID] = &amp;GetValidatorOutput{
                NodeID:    nodeID,
                PublicKey: publicKey,
                Light:     light,
                Weight:    light,
                TxID:      txID,
        }
        return nil</span>
}

func (m *manager) GetValidators(netID ids.ID) (Set, error) <span class="cov0" title="0">{
        if validators, ok := m.validators[netID]; ok </span><span class="cov0" title="0">{
                return &amp;validatorSet{validators: validators}, nil
        }</span>
        <span class="cov0" title="0">return &amp;emptySet{}, nil</span>
}

func (m *manager) GetValidator(netID ids.ID, nodeID ids.NodeID) (*GetValidatorOutput, bool) <span class="cov0" title="0">{
        if validators, ok := m.validators[netID]; ok </span><span class="cov0" title="0">{
                if val, exists := validators[nodeID]; exists </span><span class="cov0" title="0">{
                        return val, true
                }</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

func (m *manager) GetLight(netID ids.ID, nodeID ids.NodeID) uint64 <span class="cov0" title="0">{
        if val, ok := m.GetValidator(netID, nodeID); ok </span><span class="cov0" title="0">{
                return val.Light
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *manager) GetWeight(netID ids.ID, nodeID ids.NodeID) uint64 <span class="cov0" title="0">{
        return m.GetLight(netID, nodeID)
}</span>

func (m *manager) TotalLight(netID ids.ID) (uint64, error) <span class="cov0" title="0">{
        set, err := m.GetValidators(netID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return set.Light(), nil</span>
}

func (m *manager) TotalWeight(netID ids.ID) (uint64, error) <span class="cov0" title="0">{
        return m.TotalLight(netID)
}</span>

// validatorSet represents a validator set
type validatorSet struct {
        validators map[ids.NodeID]*GetValidatorOutput
}

func (s *validatorSet) Has(nodeID ids.NodeID) bool <span class="cov0" title="0">{
        _, ok := s.validators[nodeID]
        return ok
}</span>

func (s *validatorSet) Len() int <span class="cov0" title="0">{
        return len(s.validators)
}</span>

func (s *validatorSet) List() []Validator <span class="cov0" title="0">{
        vals := make([]Validator, 0, len(s.validators))
        for _, v := range s.validators </span><span class="cov0" title="0">{
                vals = append(vals, &amp;ValidatorImpl{
                        NodeID:   v.NodeID,
                        LightVal: v.Light,
                })
        }</span>
        <span class="cov0" title="0">return vals</span>
}

func (s *validatorSet) Light() uint64 <span class="cov0" title="0">{
        var total uint64
        for _, v := range s.validators </span><span class="cov0" title="0">{
                total += v.Light
        }</span>
        <span class="cov0" title="0">return total</span>
}

func (s *validatorSet) Sample(size int) ([]ids.NodeID, error) <span class="cov0" title="0">{
        nodeIDs := make([]ids.NodeID, 0, size)
        for nodeID := range s.validators </span><span class="cov0" title="0">{
                if len(nodeIDs) &gt;= size </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">nodeIDs = append(nodeIDs, nodeID)</span>
        }
        <span class="cov0" title="0">return nodeIDs, nil</span>
}

// emptySet represents an empty validator set
type emptySet struct{}

func (s *emptySet) Has(ids.NodeID) bool <span class="cov0" title="0">{ return false }</span>
func (s *emptySet) Len() int            <span class="cov0" title="0">{ return 0 }</span>
func (s *emptySet) List() []Validator   <span class="cov0" title="0">{ return nil }</span>
func (s *emptySet) Light() uint64       <span class="cov0" title="0">{ return 0 }</span>
func (s *emptySet) Sample(size int) ([]ids.NodeID, error) <span class="cov0" title="0">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">package validators

import (
        "context"

        "github.com/luxfi/consensus/version"
        "github.com/luxfi/ids"
)

// State provides validator state management
type State interface {
        GetValidatorSet(ctx context.Context, height uint64, netID ids.ID) (map[ids.NodeID]*GetValidatorOutput, error)
        GetCurrentValidators(ctx context.Context, height uint64, netID ids.ID) (map[ids.NodeID]*GetValidatorOutput, error)
        GetCurrentHeight(ctx context.Context) (uint64, error)
}

// GetValidatorOutput provides validator information
type GetValidatorOutput struct {
        NodeID    ids.NodeID
        PublicKey []byte
        Light     uint64
        Weight    uint64 // Alias for Light for backward compatibility
        TxID      ids.ID // Transaction ID that added this validator
}

// Set represents a set of validators
type Set interface {
        Has(ids.NodeID) bool
        Len() int
        List() []Validator
        Light() uint64
        Sample(size int) ([]ids.NodeID, error)
}

// Validator represents a validator
type Validator interface {
        ID() ids.NodeID
        Light() uint64
}

// ValidatorImpl is a concrete implementation of Validator
type ValidatorImpl struct {
        NodeID   ids.NodeID
        LightVal uint64
}

// ID returns the node ID
func (v *ValidatorImpl) ID() ids.NodeID <span class="cov0" title="0">{
        return v.NodeID
}</span>

// Light returns the validator light
func (v *ValidatorImpl) Light() uint64 <span class="cov0" title="0">{
        return v.LightVal
}</span>

// Manager manages validator sets
type Manager interface {
        GetValidators(netID ids.ID) (Set, error)
        GetValidator(netID ids.ID, nodeID ids.NodeID) (*GetValidatorOutput, bool)
        GetLight(netID ids.ID, nodeID ids.NodeID) uint64
        GetWeight(netID ids.ID, nodeID ids.NodeID) uint64 // Deprecated: use GetLight
        TotalLight(netID ids.ID) (uint64, error)
        TotalWeight(netID ids.ID) (uint64, error) // Deprecated: use TotalLight
}

// SetCallbackListener listens to validator set changes
type SetCallbackListener interface {
        OnValidatorAdded(nodeID ids.NodeID, light uint64)
        OnValidatorRemoved(nodeID ids.NodeID, light uint64)
        OnValidatorLightChanged(nodeID ids.NodeID, oldLight, newLight uint64)
}

// ManagerCallbackListener listens to manager changes
type ManagerCallbackListener interface {
        OnValidatorAdded(netID ids.ID, nodeID ids.NodeID, light uint64)
        OnValidatorRemoved(netID ids.ID, nodeID ids.NodeID, light uint64)
        OnValidatorLightChanged(netID ids.ID, nodeID ids.NodeID, oldLight, newLight uint64)
}

// Connector handles validator connections
type Connector interface {
        Connected(ctx context.Context, nodeID ids.NodeID, nodeVersion *version.Application) error
        Disconnected(ctx context.Context, nodeID ids.NodeID) error
}
</pre>
		
		<pre class="file" id="file91" style="display: none">// Package validatorsmock provides mock implementations for validator management
package validatorsmock

import (
        "context"
        "testing"

        "github.com/luxfi/ids"
)

// MockValidatorSet provides a mock implementation for validator sets
type MockValidatorSet struct {
        validators []Validator
        weights    map[ids.NodeID]uint64
}

// Validator represents a validator
type Validator struct {
        ID     ids.NodeID
        Weight uint64
}

// NewMockValidatorSet creates a new mock validator set
func NewMockValidatorSet() *MockValidatorSet <span class="cov0" title="0">{
        return &amp;MockValidatorSet{
                validators: make([]Validator, 0),
                weights:    make(map[ids.NodeID]uint64),
        }
}</span>

// AddValidator adds a validator to the set
func (m *MockValidatorSet) AddValidator(nodeID ids.NodeID, weight uint64) <span class="cov0" title="0">{
        m.validators = append(m.validators, Validator{
                ID:     nodeID,
                Weight: weight,
        })
        m.weights[nodeID] = weight
}</span>

// GetValidators returns all validators
func (m *MockValidatorSet) GetValidators(ctx context.Context) []Validator <span class="cov0" title="0">{
        return m.validators
}</span>

// GetWeight returns the weight of a validator
func (m *MockValidatorSet) GetWeight(nodeID ids.NodeID) uint64 <span class="cov0" title="0">{
        return m.weights[nodeID]
}</span>

// Contains checks if a node is a validator
func (m *MockValidatorSet) Contains(nodeID ids.NodeID) bool <span class="cov0" title="0">{
        _, exists := m.weights[nodeID]
        return exists
}</span>

// Size returns the number of validators
func (m *MockValidatorSet) Size() int <span class="cov0" title="0">{
        return len(m.validators)
}</span>

// State provides a mock implementation for validator state
type State struct {
        T             *testing.T
        currentHeight uint64
        minimumHeight uint64
        validators    map[uint64][]Validator
        chainID       ids.ID

        // Function fields that can be overridden
        GetNetIDF         func(context.Context, ids.ID) (ids.ID, error)
        GetCurrentHeightF func(context.Context) (uint64, error)
        GetMinimumHeightF func(context.Context) (uint64, error)
        GetValidatorSetF  func(context.Context, uint64, ids.ID) ([]Validator, error)
        GetChainIDF       func(ids.ID) (ids.ID, error)
}

// NewState creates a new mock validator state
func NewState(t *testing.T) *State <span class="cov0" title="0">{
        return &amp;State{
                T:             t,
                currentHeight: 0,
                minimumHeight: 0,
                validators:    make(map[uint64][]Validator),
                chainID:       ids.Empty,
        }
}</span>

// GetCurrentHeight returns the current height
func (s *State) GetCurrentHeight(ctx context.Context) (uint64, error) <span class="cov0" title="0">{
        if s.GetCurrentHeightF != nil </span><span class="cov0" title="0">{
                return s.GetCurrentHeightF(ctx)
        }</span>
        <span class="cov0" title="0">return s.currentHeight, nil</span>
}

// GetMinimumHeight returns the minimum height
func (s *State) GetMinimumHeight(ctx context.Context) (uint64, error) <span class="cov0" title="0">{
        if s.GetMinimumHeightF != nil </span><span class="cov0" title="0">{
                return s.GetMinimumHeightF(ctx)
        }</span>
        <span class="cov0" title="0">return s.minimumHeight, nil</span>
}

// GetValidatorSet returns the validator set at a given height and subnet
func (s *State) GetValidatorSet(ctx context.Context, height uint64, subnetID ids.ID) ([]Validator, error) <span class="cov0" title="0">{
        if s.GetValidatorSetF != nil </span><span class="cov0" title="0">{
                return s.GetValidatorSetF(ctx, height, subnetID)
        }</span>
        <span class="cov0" title="0">if validators, ok := s.validators[height]; ok </span><span class="cov0" title="0">{
                return validators, nil
        }</span>
        <span class="cov0" title="0">return []Validator{}, nil</span>
}

// GetChainID returns the chain ID for a given chain
func (s *State) GetChainID(chainID ids.ID) (ids.ID, error) <span class="cov0" title="0">{
        if s.GetChainIDF != nil </span><span class="cov0" title="0">{
                return s.GetChainIDF(chainID)
        }</span>
        <span class="cov0" title="0">return s.chainID, nil</span>
}

// SetHeight sets the current height
func (s *State) SetHeight(height uint64) <span class="cov0" title="0">{
        s.currentHeight = height
}</span>

// SetMinimumHeight sets the minimum height
func (s *State) SetMinimumHeight(height uint64) <span class="cov0" title="0">{
        s.minimumHeight = height
}</span>

// SetValidatorSet sets the validator set at a given height
func (s *State) SetValidatorSet(height uint64, validators []Validator) <span class="cov0" title="0">{
        s.validators[height] = validators
}</span>

// SetChainID sets the chain ID
func (s *State) SetChainID(chainID ids.ID) <span class="cov0" title="0">{
        s.chainID = chainID
}</span>

// GetNetID returns the network ID for a given chain
func (s *State) GetNetID(ctx context.Context, chainID ids.ID) (ids.ID, error) <span class="cov0" title="0">{
        if s.GetNetIDF != nil </span><span class="cov0" title="0">{
                return s.GetNetIDF(ctx, chainID)
        }</span>
        // Simple mock: return a fixed network ID
        <span class="cov0" title="0">return ids.GenerateTestID(), nil</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">package validatorstest

import (
        "context"

        "github.com/luxfi/consensus/validators"
        "github.com/luxfi/ids"
)

// State is an alias for TestState for backward compatibility
type State = TestState

// TestState is a test implementation of validators.State
type TestState struct {
        validators map[ids.ID]validators.Set

        // Function fields for test customization
        GetCurrentHeightF func(context.Context) (uint64, error)
        GetValidatorSetF  func(context.Context, uint64, ids.ID) (map[ids.NodeID]*validators.GetValidatorOutput, error)
}

// NewTestState creates a new test state
func NewTestState() *TestState <span class="cov0" title="0">{
        return &amp;TestState{
                validators: make(map[ids.ID]validators.Set),
        }
}</span>

// GetCurrentValidators returns current validators
func (s *TestState) GetCurrentValidators(ctx context.Context, height uint64, netID ids.ID) (map[ids.NodeID]*validators.GetValidatorOutput, error) <span class="cov0" title="0">{
        return s.GetValidatorSet(ctx, height, netID)
}</span>

// GetValidatorSet returns a validator set
func (s *TestState) GetValidatorSet(ctx context.Context, height uint64, netID ids.ID) (map[ids.NodeID]*validators.GetValidatorOutput, error) <span class="cov0" title="0">{
        if s.GetValidatorSetF != nil </span><span class="cov0" title="0">{
                return s.GetValidatorSetF(ctx, height, netID)
        }</span>
        <span class="cov0" title="0">return make(map[ids.NodeID]*validators.GetValidatorOutput), nil</span>
}

// GetCurrentHeight returns the current height
func (s *TestState) GetCurrentHeight(ctx context.Context) (uint64, error) <span class="cov0" title="0">{
        if s.GetCurrentHeightF != nil </span><span class="cov0" title="0">{
                return s.GetCurrentHeightF(ctx)
        }</span>
        <span class="cov0" title="0">return 0, nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">// Package version provides version information
package version

import "fmt"

// Application represents an application version
type Application struct {
        Major int
        Minor int
        Patch int

        // Additional metadata
        Name string
}

// String returns the version string
func (v *Application) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s-%d.%d.%d", v.Name, v.Major, v.Minor, v.Patch)
}</span>

// Compatible returns whether versions are compatible
func (v *Application) Compatible(other *Application) bool <span class="cov0" title="0">{
        // Major version must match
        return v.Major == other.Major
}</span>

// Compare compares two versions
// Returns -1 if v &lt; other, 0 if v == other, 1 if v &gt; other
func (v *Application) Compare(other *Application) int <span class="cov0" title="0">{
        if v.Major &lt; other.Major </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">if v.Major &gt; other.Major </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">if v.Minor &lt; other.Minor </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">if v.Minor &gt; other.Minor </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">if v.Patch &lt; other.Patch </span><span class="cov0" title="0">{
                return -1
        }</span>
        <span class="cov0" title="0">if v.Patch &gt; other.Patch </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return 0</span>
}

// Current returns the current version
func Current() *Application <span class="cov0" title="0">{
        return &amp;Application{
                Major: 1,
                Minor: 0,
                Patch: 0,
                Name:  "lux",
        }
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package wave

// State represents the consensus state for an item
type State[ID comparable] struct {
        // The item ID
        ID ID

        // Confidence score
        Confidence int

        // Whether the item is finalized
        Finalized bool

        // Parent IDs
        Parents []ID

        // Height in the consensus graph
        Height uint64
}

// NewState creates a new consensus state
func NewState[ID comparable](id ID) State[ID] <span class="cov0" title="0">{
        return State[ID]{
                ID:         id,
                Confidence: 0,
                Finalized:  false,
                Parents:    []ID{},
                Height:     0,
        }
}</span>

// IsPreferred returns whether this state is preferred
func (s State[ID]) IsPreferred() bool <span class="cov0" title="0">{
        return s.Confidence &gt; 0
}</span>

// IncrementConfidence increments the confidence score
func (s *State[ID]) IncrementConfidence() <span class="cov0" title="0">{
        s.Confidence++
}</span>

// Finalize marks the state as finalized
func (s *State[ID]) Finalize() <span class="cov0" title="0">{
        s.Finalized = true
}</span>
</pre>
		
		<pre class="file" id="file95" style="display: none">package wave

import (
        "context"
        "time"

        "github.com/luxfi/consensus/prism"
        "github.com/luxfi/consensus/types"
)

// Photon represents a vote message in the consensus protocol
type Photon[T comparable] struct {
        Item      T
        Prefer    bool
        Sender    types.NodeID
        Timestamp time.Time
}

// Transport handles network communication for voting
type Transport[T comparable] interface {
        RequestVotes(ctx context.Context, peers []types.NodeID, item T) &lt;-chan Photon[T]
        MakeLocalPhoton(item T, prefer bool) Photon[T]
}

// Config holds configuration for wave consensus
type Config struct {
        K       int           // Sample size
        Alpha   float64       // Threshold ratio
        Beta    uint32        // Confidence threshold
        RoundTO time.Duration // Round timeout
}

// WaveState represents the state of an item in wave consensus
type WaveState struct {
        Decided bool
        Result  types.Decision
        Count   uint32
}

// Wave manages threshold voting and confidence building
type Wave[T comparable] struct {
        cfg Config
        cut prism.Cut[T]
        tx  Transport[T]

        // State tracking
        states map[T]*WaveState
        prefs  map[T]bool // current preferences
}

// New creates a new Wave instance
func New[T comparable](cfg Config, cut prism.Cut[T], tx Transport[T]) Wave[T] <span class="cov0" title="0">{
        return Wave[T]{
                cfg:    cfg,
                cut:    cut,
                tx:     tx,
                states: make(map[T]*WaveState),
                prefs:  make(map[T]bool),
        }
}</span>

// Tick performs one round of sampling and threshold checking for an item
func (w *Wave[T]) Tick(ctx context.Context, item T) <span class="cov0" title="0">{
        // Get current state or create new one
        state, exists := w.states[item]
        if !exists </span><span class="cov0" title="0">{
                state = &amp;WaveState{Decided: false, Result: types.DecideUndecided, Count: 0}
                w.states[item] = state
        }</span>

        // Skip if already decided
        <span class="cov0" title="0">if state.Decided </span><span class="cov0" title="0">{
                return
        }</span>

        // Cut light rays (sample peers) and request votes
        <span class="cov0" title="0">peers := w.cut.Sample(w.cfg.K)
        votes := w.tx.RequestVotes(ctx, peers, item)

        // Count votes
        yesVotes := 0
        totalVotes := 0

        // Collect votes with timeout
        timeout := time.After(w.cfg.RoundTO)
        for </span><span class="cov0" title="0">{
                select </span>{
                case vote := &lt;-votes:<span class="cov0" title="0">
                        totalVotes++
                        if vote.Prefer </span><span class="cov0" title="0">{
                                yesVotes++
                        }</span>
                        // Break if we have enough votes
                        <span class="cov0" title="0">if totalVotes &gt;= w.cfg.K </span><span class="cov0" title="0">{
                                goto countVotes</span>
                        }
                case &lt;-timeout:<span class="cov0" title="0">
                        goto countVotes</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }

countVotes:
        <span class="cov0" title="0">if totalVotes == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Check threshold
        <span class="cov0" title="0">threshold := int(float64(w.cfg.K) * w.cfg.Alpha)
        currentPref := w.prefs[item]

        if yesVotes &gt;= threshold </span><span class="cov0" title="0">{
                // Strong preference for yes
                w.prefs[item] = true
                if currentPref </span><span class="cov0" title="0">{
                        // Consecutive confirmation
                        state.Count++
                }</span> else<span class="cov0" title="0"> {
                        // Preference switch
                        state.Count = 1
                }</span>
        } else<span class="cov0" title="0"> if (totalVotes - yesVotes) &gt;= threshold </span><span class="cov0" title="0">{
                // Strong preference for no
                w.prefs[item] = false
                if !currentPref </span><span class="cov0" title="0">{
                        // Consecutive confirmation
                        state.Count++
                }</span> else<span class="cov0" title="0"> {
                        // Preference switch
                        state.Count = 1
                }</span>
        } else<span class="cov0" title="0"> {
                // No strong preference, reset count
                state.Count = 0
        }</span>

        // Check for decision
        <span class="cov0" title="0">if state.Count &gt;= w.cfg.Beta </span><span class="cov0" title="0">{
                state.Decided = true
                if w.prefs[item] </span><span class="cov0" title="0">{
                        state.Result = types.DecideAccept
                }</span> else<span class="cov0" title="0"> {
                        state.Result = types.DecideReject
                }</span>
        }
}

// State returns the current state of an item
func (w *Wave[T]) State(item T) (*WaveState, bool) <span class="cov0" title="0">{
        state, exists := w.states[item]
        return state, exists
}</span>

// Preference returns the current preference for an item
func (w *Wave[T]) Preference(item T) bool <span class="cov0" title="0">{
        return w.prefs[item]
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
