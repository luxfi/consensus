---
title: Agent Communication Patterns
description: How AI agents coordinate and delegate tasks using Byzantine consensus
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Step, Steps } from 'fumadocs-ui/components/steps';

# Agent-to-Agent Communication

Learn how AI agents coordinate, delegate tasks, and reach consensus in the Lux network.

## Overview

Lux AI agents use **Byzantine Fault Tolerant consensus** to coordinate and make decisions. One agent can tell another what to do through a 5-phase consensus protocol.

<Callout type="info">
**Key Insight**: Agents don't trust each other individually. Instead, they reach Byzantine-tolerant consensus where ≥2f+1 agents must agree.
</Callout>

## The 5-Phase Protocol

From `ai/agent.go`, agents use the Photon → Quasar flow:

### Phase 1: Photon (Emit Proposal)

Agent A creates and broadcasts a proposal:

```go
// Agent A wants Agent B to process a block
proposal := &Proposal{
    ID:       "task-process-block-123",
    NodeID:   "agent-a",  
    Decision: &Decision{
        Action: "process-block",
        Data:   blockData,
        Target: "agent-b", // Optional: specific target agent
    },
    Evidence: []Evidence{
        {Data: validationResult, Weight: 0.9},
    },
    Weight:     agentAReputation, // Weighted by reputation
    Confidence: 0.85,              // How confident Agent A is
}

// Emit via Photon (broadcasts to network)
agent_a.photon.Emit(proposal)
```

**What happens**: Proposal enters the network and spreads to all agents.

### Phase 2: Wave (Network Amplification)

Proposal propagates through the network:

```go
// Internally called by agent.ProposeDecision()
agent_a.broadcastProposal(proposal)
```

**What happens**: Each agent receives the proposal and evaluates it based on their local model and evidence.

### Phase 3: Focus (Voting & Convergence)

Agents vote on the proposal with weighted ballots:

```go
// Each agent evaluates and votes
func (agent *Agent) evaluateProposal(proposal *Proposal) float64 {
    // Check evidence quality
    evidenceScore := agent.scoreEvidence(proposal.Evidence)
    
    // Check proposer reputation
    proposerWeight := agent.weights[proposal.NodeID]
    
    // Agent's own model evaluation
    modelScore := agent.model.Evaluate(proposal.Decision.Data)
    
    // Weighted combination
    vote := (evidenceScore * 0.4) + 
            (proposerWeight * 0.3) + 
            (modelScore * 0.3)
    
    return vote // 0.0 to 1.0
}

// Vote collection via Focus consensus
votes := agent_a.focusConsensus(ctx, proposal)

// Check if quorum reached (≥2f+1 weighted votes)
if votes.TotalWeight >= agent_a.quorumThreshold {
    // Proposal passes to next phase
}
```

**What happens**: Byzantine-tolerant quorum forms if enough agents (by weight) support the proposal.

### Phase 4: Prism + Horizon (DAG Validation)

Validate proposal through DAG finality detection:

```go
// Prism validation (DAG structure)
isValid := agent_a.prismValidation(decision)

// Horizon finality check
finalized := agent_a.horizonFinalization(decision)
```

**What happens**: 
- Prism checks if decision conflicts with DAG structure
- Horizon ensures decision is beyond event horizon (immutable)

### Phase 5: Quantum Finality

Final signature and execution:

```go
// Add post-quantum signature
decision.QuantumSignature = ringtail.Sign(decision)

// Agent B receives finalized decision
agent_b.ExecuteDecision(finalizedDecision)
```

**What happens**: Decision is finalized with quantum-resistant signature and executed by target agent(s).

## Complete Example

Here's a full example of Agent A telling Agent B to validate a block:

```go
package main

import (
    "context"
    "github.com/luxfi/consensus/ai"
)

func main() {
    // Create two agents
    agentA := ai.NewAgent("agent-a", modelA, sharedMemory)
    agentB := ai.NewAgent("agent-b", modelB, sharedMemory)
    
    // Agent A proposes that Agent B validate block
    proposal := agentA.ProposeDecision(context.Background(), ai.Decision{
        Action: "validate-block",
        Target: "agent-b",
        Data: ai.BlockData{
            BlockID: blockID,
            Transactions: txs,
        },
    })
    
    // Protocol runs automatically:
    // 1. Photon: Broadcast proposal
    // 2. Wave: Spread through network
    // 3. Focus: Agents vote (weighted)
    // 4. Prism/Horizon: DAG validation
    // 5. Finalize: Quantum signature
    
    // Agent B receives and checks if it's the target
    decision := <-agentB.DecisionChannel()
    
    if decision.Target == "agent-b" && decision.Finalized {
        // Execute the validated decision
        result := agentB.ExecuteTask(decision)
        
        // Report back to network
        agentB.ReportResult(result)
    }
}
```

## Reputation & Weighting

Agents have dynamic reputation scores that affect their voting weight:

```go
// Update agent reputation based on performance
agent.UpdateNodeWeight(nodeID, performance)

// Weight calculation (exponential moving average)
alpha := 0.1
newWeight := alpha*performance + (1-alpha)*currentWeight

// Clamp to [0.01, 10.0]
if newWeight < 0.01 {
    newWeight = 0.01
}
if newWeight > 10.0 {
    newWeight = 10.0
}
```

**Higher reputation = more influence in consensus**

## Shared Hallucinations

Agents synchronize model states via "hallucinations":

```go
// Agent A updates shared model state
hallucination := &Hallucination{
    ID:         "model-state-v123",
    ModelID:    "gpt-consensus-1",
    State:      map[string]interface{}{
        "preferred_block": blockID,
        "confidence":      0.92,
    },
    Confidence: 0.92,
    NodeVotes:  map[string]float64{
        "agent-a": 1.5,  // Weighted votes
        "agent-b": 1.2,
        "agent-c": 0.8,
    },
}

// Sync across network
agent.SyncSharedMemory()
```

**What happens**: All agents converge on shared model state weighted by reputation.

## Training & Learning

Agents learn from each other:

```go
// Agent A shares what it learned
example := TrainingExample{
    Input:    blockData,
    Output:   Decision{Action: "accept", Confidence: 0.95},
    Feedback: 1.0,  // Positive feedback (block was correct)
    NodeID:   "agent-a",
    Weight:   agentAReputation,
}

agent.AddTrainingData(example)

// All agents incorporate weighted by reputation
// Higher reputation agents have more teaching influence
```

## Byzantine Tolerance

The system tolerates malicious agents:

- **Total agents**: n
- **Byzantine (malicious)**: f
- **Requirement**: n > 3f
- **Quorum**: ≥2f+1 agents must agree

**Example**: With 20 agents, tolerates 6 malicious agents, needs 13+ for consensus.

## Message Types

### Proposal

```go
type Proposal struct {
    ID         string        // Unique proposal ID
    NodeID     string        // Proposing agent
    Decision   *Decision     // What to do
    Evidence   []Evidence    // Supporting evidence
    Weight     float64       // Proposer's weight
    Confidence float64       // Confidence level
}
```

### Decision

```go
type Decision struct {
    Action     string      // "validate", "execute", "reject", etc.
    Target     string      // Target agent ID (optional)
    Data       interface{} // Task-specific data
    Confidence float64     // Confidence in decision
}
```

### Evidence

```go
type Evidence struct {
    Data      interface{} // Supporting data
    NodeID    string      // Evidence source
    Weight    float64     // Evidence weight
    Timestamp time.Time   // When collected
}
```

## Real-World Use Cases

### 1. Block Validation Coordination

```go
// Agent A (block proposer) asks validators to check block
proposal := agent_a.ProposeDecision(ctx, Decision{
    Action: "validate-block",
    Data:   blockData,
})

// Validators vote
// ≥13/20 validators agree → block validated
```

### 2. Upgrade Decisions

```go
// Propose network upgrade
proposal := ProposeDecision(ctx, Decision{
    Action: "upgrade-protocol",
    Data: UpgradeData{
        Version: "v2.0.0",
        ActivationHeight: 1000000,
    },
})

// Byzantine-tolerant consensus on upgrade
```

### 3. Security Response

```go
// Detect attack, coordinate response
proposal := security_agent.ProposeDecision(ctx, Decision{
    Action: "block-malicious-node",
    Data: SecurityData{
        MaliciousNode: "node-xyz",
        Evidence:      attackLogs,
    },
})

// Network agrees → coordinated response
```

## Code Reference

**Implementation**: `/consensus/ai/agent.go`

Key methods:
- `ProposeDecision()` - Lines 189-233
- `broadcastProposal()` - Lines 204-208
- `focusConsensus()` - Lines 337-342
- `prismValidation()` - Lines 344-353
- `horizonFinalization()` - Lines 355-361
- `UpdateNodeWeight()` - Lines 293-313
- `SyncSharedMemory()` - Lines 259-290

## Summary

**How one agent tells another what to do:**

1. Create `Proposal` with task details
2. Broadcast via `Photon.Emit()`
3. Agents vote (weighted by reputation)
4. Reach Byzantine quorum (≥2f+1)
5. Validate via Prism/Horizon
6. Execute with quantum signature

**Key Features:**
- ✅ Byzantine fault tolerant
- ✅ Reputation-weighted voting
- ✅ Shared model state
- ✅ Distributed learning
- ✅ Quantum-resistant finality

<Callout type="success">
This pattern enables trustless AI agent coordination with the same security guarantees as blockchain consensus!
</Callout>
