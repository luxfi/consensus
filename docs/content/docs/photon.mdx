---
title: Photon Selection
description: Light-based committee selection algorithm
---

# Photon Selection

Photon is the committee selection mechanism in Lux consensus. It uses a light-emission metaphor where validators emit "photons" and selection probability is weighted by their "luminance" (performance history).

## Overview

The Photon system replaces traditional random sampling with performance-weighted selection:

- **Emitter**: The source of randomness for committee selection
- **Luminance**: Node brightness tracked in lux units (10-1000 range)
- **Photon**: A selection event emitted by the emitter

## Core Components

### Emitter

The emitter generates committee selections based on stake weight and luminance:

```go
type Emitter struct {
    validators map[ids.NodeID]*Validator
    rng        *rand.Rand
    config     EmitterConfig
}

func (e *Emitter) Emit(k int) []ids.NodeID {
    // Calculate weighted probabilities
    weights := make([]float64, 0, len(e.validators))
    nodes := make([]ids.NodeID, 0, len(e.validators))

    for id, v := range e.validators {
        weight := float64(v.Stake) * v.Luminance.Value()
        weights = append(weights, weight)
        nodes = append(nodes, id)
    }

    // Select k validators weighted by luminance
    selected := make([]ids.NodeID, 0, k)
    for i := 0; i < k; i++ {
        idx := e.weightedSelect(weights)
        selected = append(selected, nodes[idx])
        // Remove selected to avoid duplicates
        weights[idx] = 0
    }

    return selected
}
```

### Luminance

Luminance tracks node performance in lux units:

```go
type Luminance struct {
    value   float64  // Current brightness (10-1000 lux)
    min     float64  // Minimum brightness
    max     float64  // Maximum brightness
    decay   float64  // Decay rate per update
    boost   float64  // Boost rate on success
}

func NewLuminance() *Luminance {
    return &Luminance{
        value: 500,   // Start at medium brightness
        min:   10,
        max:   1000,
        decay: 0.99,
        boost: 1.05,
    }
}

func (l *Luminance) Update(success bool) {
    if success {
        l.value = min(l.max, l.value*l.boost)
    } else {
        l.value = max(l.min, l.value*l.decay)
    }
}

func (l *Luminance) Value() float64 {
    return l.value
}
```

## Selection Algorithm

### K-of-N Committee Selection

```go
func (e *Emitter) SelectCommittee(k int) Committee {
    selected := e.Emit(k)

    return Committee{
        Members:   selected,
        Threshold: (2 * k / 3) + 1,
        Round:     e.currentRound,
    }
}
```

### Weighted Selection

Selection probability is proportional to stake times luminance:

```
P(select node i) = (stake_i * luminance_i) / sum(stake_j * luminance_j)
```

This ensures:
- Higher stake = higher selection probability
- Better performers get selected more often
- Poor performers naturally phase out

## Performance Tracking

### Success Metrics

```go
type PerformanceTracker struct {
    responseTime  time.Duration
    successRate   float64
    availability  float64
}

func (p *PerformanceTracker) RecordResponse(latency time.Duration, success bool) {
    p.responseTime = (p.responseTime + latency) / 2

    if success {
        p.successRate = min(1.0, p.successRate*1.01)
    } else {
        p.successRate = max(0.0, p.successRate*0.95)
    }
}
```

### Luminance Updates

```go
func (e *Emitter) UpdateLuminance(nodeID ids.NodeID, result PollResult) {
    validator := e.validators[nodeID]

    success := result.Responded && result.Latency < e.config.MaxLatency
    validator.Luminance.Update(success)

    // Update performance tracker
    validator.Performance.RecordResponse(result.Latency, result.Responded)
}
```

## Configuration

```go
type EmitterConfig struct {
    // MinLuminance: Floor for node brightness
    MinLuminance float64

    // MaxLuminance: Ceiling for node brightness
    MaxLuminance float64

    // InitialLuminance: Starting brightness for new nodes
    InitialLuminance float64

    // DecayRate: Luminance decay on failure
    DecayRate float64

    // BoostRate: Luminance boost on success
    BoostRate float64

    // MaxLatency: Maximum acceptable response time
    MaxLatency time.Duration
}

func DefaultEmitterConfig() EmitterConfig {
    return EmitterConfig{
        MinLuminance:     10,
        MaxLuminance:     1000,
        InitialLuminance: 500,
        DecayRate:        0.99,
        BoostRate:        1.05,
        MaxLatency:       100 * time.Millisecond,
    }
}
```

## Integration with Wave

Photon provides validator sampling for Wave consensus:

```go
func (w *Wave) Poll(ctx context.Context) error {
    // Select committee using photon emitter
    committee := w.emitter.Emit(w.config.K)

    // Query selected validators
    responses := make(chan PollResponse, len(committee))
    for _, nodeID := range committee {
        go func(id ids.NodeID) {
            resp, latency := w.queryValidator(ctx, id)
            responses <- PollResponse{
                NodeID:  id,
                Vote:    resp,
                Latency: latency,
            }
        }(nodeID)
    }

    // Collect responses and update luminance
    for i := 0; i < len(committee); i++ {
        resp := <-responses
        w.emitter.UpdateLuminance(resp.NodeID, resp.ToPollResult())
    }

    return nil
}
```

## Performance

### Benchmark Results

| Operation | Time/Op | Memory | Allocations |
|-----------|---------|--------|-------------|
| Emit (k=21) | 3.03us | 3.0KB | 2 allocs |
| Luminance Update | 72ns | 0B | 0 allocs |
| Weight Calculation | 150ns | 0B | 0 allocs |

### Selection Quality

- Stake-weighted fairness maintained
- Performance-based adaptation within 100 rounds
- No single validator dominates selection

## Example: Photon Emitter

```go
package main

import (
    "fmt"

    "github.com/luxfi/consensus/photon"
)

func main() {
    config := photon.DefaultEmitterConfig()
    emitter := photon.NewEmitter(config)

    // Register validators
    validators := []Validator{
        {ID: "node1", Stake: 1000},
        {ID: "node2", Stake: 2000},
        {ID: "node3", Stake: 1500},
    }

    for _, v := range validators {
        emitter.AddValidator(v.ID, v.Stake)
    }

    // Emit committee of size 2
    committee := emitter.Emit(2)
    fmt.Printf("Selected committee: %v\n", committee)

    // Simulate performance and update luminance
    emitter.UpdateLuminance("node1", photon.PollResult{
        Responded: true,
        Latency:   50 * time.Millisecond,
    })

    emitter.UpdateLuminance("node2", photon.PollResult{
        Responded: false,
    })

    // Luminance affects future selections
    committee = emitter.Emit(2)
    fmt.Printf("Next committee: %v\n", committee)
}
```

## Testing

```bash
# Run photon tests
go test ./photon/...

# Benchmark selection
go test -bench=Emit ./photon/

# Test luminance decay
go test -run=Luminance ./photon/
```
