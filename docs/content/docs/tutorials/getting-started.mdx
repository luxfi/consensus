---
title: Getting Started
description: Build your first Lux consensus node in 15 minutes
---

import { Step, Steps } from 'fumadocs-ui/components/steps';
import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';

# Getting Started with Lux Consensus

Welcome! This tutorial will guide you from zero to a working consensus node in 15 minutes.

<Callout type="info">
**No blockchain experience required!** We'll explain everything as we go.
</Callout>

## What You'll Build

By the end of this tutorial, you'll have:
- A working consensus node
- Understanding of Byzantine fault tolerance
- Ability to add blocks and achieve finality
- Foundation for building blockchain applications

## Prerequisites

<Tabs items={['Go', 'Python', 'Rust']}>
<Tab value="Go">
- Go 1.21 or later
- Basic Go knowledge (variables, functions, structs)
- Terminal/command line familiarity
</Tab>
<Tab value="Python">
- Python 3.8 or later
- Basic Python knowledge
- pip package manager
</Tab>
<Tab value="Rust">
- Rust 1.70 or later
- Basic Rust knowledge
- Cargo package manager
</Tab>
</Tabs>

## Step-by-Step Guide

<Steps>

<Step>
### Install Lux Consensus

<Tabs items={['Go', 'Python', 'Rust']}>
<Tab value="Go">
```bash
go get github.com/luxfi/consensus@v1.22.0
```
</Tab>
<Tab value="Python">
```bash
pip install lux-consensus
```
</Tab>
<Tab value="Rust">
```toml
# Add to Cargo.toml
[dependencies]
lux-consensus = "1.22.0"
```
</Tab>
</Tabs>

**What's happening**: You're downloading the Lux consensus library which handles all the complex Byzantine agreement logic for you.

</Step>

<Step>
### Create Your First Consensus Node

<Tabs items={['Go', 'Python', 'Rust']}>
<Tab value="Go">
```go
package main

import (
    "context"
    "fmt"
    "github.com/luxfi/consensus"
)

func main() {
    // Create consensus engine
    chain := consensus.NewChain(consensus.DefaultConfig())
    
    // Start the engine
    ctx := context.Background()
    if err := chain.Start(ctx); err != nil {
        panic(err)
    }
    defer chain.Stop()
    
    fmt.Println("✅ Consensus node running!")
}
```
</Tab>
<Tab value="Python">
```python
from lux_consensus import Chain, default_config

# Create consensus engine
chain = Chain(default_config())

# Start the engine
chain.start()

print("✅ Consensus node running!")

chain.stop()
```
</Tab>
<Tab value="Rust">
```rust
use lux_consensus::{Chain, Config};

fn main() {
    // Create consensus engine
    let mut chain = Chain::new(Config::default());
    
    // Start the engine
    chain.start().unwrap();
    
    println!("✅ Consensus node running!");
    
    chain.stop();
}
```
</Tab>
</Tabs>

**What's happening**: 
- `DefaultConfig()` sets up a single-validator network (for learning)
- `Start()` initializes the consensus engine
- The engine is now ready to process blocks

</Step>

<Step>
### Add Your First Block

<Tabs items={['Go', 'Python', 'Rust']}>
<Tab value="Go">
```go
import "time"

// Create a block
block := &consensus.Block{
    ID:       consensus.ID{1, 2, 3}, // Unique block ID
    ParentID: consensus.GenesisID,    // Parent is genesis
    Height:   1,                      // Block height
    Time:     time.Now(),
    Payload:  []byte("Hello, Consensus!"),
}

// Add to chain
if err := chain.Add(ctx, block); err != nil {
    panic(err)
}

fmt.Printf("✅ Block added at height %d\n", block.Height)
```
</Tab>
<Tab value="Python">
```python
from lux_consensus import Block, ID
import time

# Create a block
block = Block(
    id=ID.from_bytes([1, 2, 3]),
    parent_id=ID.genesis(),
    height=1,
    timestamp=int(time.time()),
    payload=b"Hello, Consensus!"
)

# Add to chain
chain.add(block)

print(f"✅ Block added at height {block.height}")
```
</Tab>
<Tab value="Rust">
```rust
use std::time::SystemTime;

// Create a block
let block = Block::new(
    ID::from([1, 2, 3]),
    ID::genesis(),
    1,
    b"Hello, Consensus!".to_vec()
);

// Add to chain
chain.add(block.clone()).unwrap();

println!("✅ Block added at height {}", block.height);
```
</Tab>
</Tabs>

**What's happening**:
- Each block has a unique ID and references its parent
- Genesis block is the first block (parent of all chains)
- Height tracks position in the chain
- Payload is your application data

</Step>

<Step>
### Achieve Consensus

With a single validator, blocks are immediately finalized. Let's see multi-validator consensus:

<Tabs items={['Go']}>
<Tab value="Go">
```go
// Create 5-validator network
cfg := consensus.GetConfig(5) // Auto-configures for 5 nodes
chain := consensus.NewChain(cfg)

chain.Start(ctx)
defer chain.Stop()

// Add block
block := &consensus.Block{
    ID:       consensus.ID{4, 5, 6},
    ParentID: consensus.GenesisID,
    Height:   1,
    Payload:  []byte("Multi-validator block"),
}

chain.Add(ctx, block)

// Simulate votes from validators
validators := []consensus.NodeID{
    {1}, {2}, {3}, {4}, {5},
}

for _, validator := range validators {
    vote := consensus.NewVote(
        block.ID,
        consensus.VotePreference,
        validator,
    )
    chain.RecordVote(ctx, vote)
}

// Check if finalized
status := chain.GetStatus(block.ID)
if status == consensus.StatusAccepted {
    fmt.Println("✅ Block achieved finality!")
}
```
</Tab>
</Tabs>

**What's happening**:
1. **Network setup**: 5 validators (Byzantine tolerates f=1 fault)
2. **Block creation**: Same as before
3. **Voting**: Each validator votes on the block
4. **Consensus**: Once enough votes (quorum), block finalizes
5. **Finality**: Block is now immutable

</Step>

</Steps>

## Understanding the Code

### Configuration

```go
consensus.GetConfig(nodeCount)
```

Auto-calculates optimal parameters:
- **k** (sample size): How many validators to query
- **α** (quorum): How many must agree
- **β** (confidence): How many consecutive successes needed

For 5 nodes: k=3, α=3, β=4 (Byzantine tolerates 1 fault)

### Block Structure

```go
type Block struct {
    ID       ID        // Unique identifier
    ParentID ID        // Links to parent (forms chain)
    Height   uint64    // Position in chain
    Time     time.Time // Timestamp
    Payload  []byte    // Your application data
}
```

### Voting

```go
vote := NewVote(blockID, VotePreference, voterID)
```

Each validator votes:
- **VotePreference**: "I prefer this block"
- **VoteAccept**: "I accept this block"
- **VoteReject**: "I reject this block"

### Status

```go
status := chain.GetStatus(blockID)
```

Possible statuses:
- **Processing**: Gathering votes
- **Accepted**: Finalized ✓
- **Rejected**: Rejected by consensus
- **Unknown**: Block not found

## Next Steps

### Build Something Real

Try these progressively complex examples:

1. **Multi-Block Chain**: Add 10 blocks in sequence
2. **Event Callbacks**: Get notified when blocks finalize
3. **Parallel Blocks**: Use DAG consensus for parallel processing
4. **Network Simulation**: Simulate Byzantine faults

### Explore Advanced Features

- [Quasar Protocol](/docs/protocols/quasar) - 2-round quantum finality
- [FPC](/docs/protocols/fpc) - Dynamic threshold selection
- [DAG Consensus](/docs/protocols/dag) - Parallel block processing
- [Post-Quantum Signatures](/docs/security/post-quantum) - Ringtail + BLS

### Choose Your SDK

<div className="grid grid-cols-2 md:grid-cols-3 gap-4">
  <a href="/docs/sdk/go" className="card">Go SDK</a>
  <a href="/docs/sdk/python" className="card">Python SDK</a>
  <a href="/docs/sdk/rust" className="card">Rust SDK</a>
  <a href="/docs/sdk/c" className="card">C SDK</a>
  <a href="/docs/sdk/cpp" className="card">C++ SDK</a>
</div>

## Troubleshooting

### "Block not finalizing"

Check validator votes:
- Need ≥α votes (quorum)
- Must be from different validators
- Must match block ID exactly

### "Import errors"

Ensure you're using v1.22.0:
```bash
go get github.com/luxfi/consensus@v1.22.0
```

### "Consensus stuck"

This is where FPC helps! The protocol automatically varies thresholds to prevent stuck states.

## Summary

You've learned:
- ✅ What Byzantine Fault Tolerance is
- ✅ How to create a consensus node
- ✅ How to add blocks and achieve finality
- ✅ The basics of voting and quorums

**Next**: Try the [Quasar Full Example](/docs/examples/quasar-full) to see FPC + Wave + Horizon all working together!

<Callout type="success">
**Congratulations!** You now understand Byzantine consensus and can build blockchain applications with Lux.
</Callout>
