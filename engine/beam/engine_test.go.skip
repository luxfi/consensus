// Copyright (C) 2019-2025, Lux Industries Inc. All rights reserved.
// See the file LICENSE for licensing terms.

package beam

import (
	"context"
	"crypto/rand"
	"testing"
	"time"
	
	"github.com/luxfi/ids"
	"github.com/luxfi/crypto/bls"
	"github.com/stretchr/testify/require"
)

func TestEngineDualCert(t *testing.T) {
	require := require.New(t)
	
	// Generate keys
	nodeID := ids.GenerateTestNodeID()
	
	blsSK, blsPK, err := bls.KeyGen()
	require.NoError(err)
	
	rtSeed := make([]byte, 32)
	rand.Read(rtSeed)
	
	mock := &MockRingtail{}
	rtSK, rtPK, err := mock.KeyGen(rtSeed)
	require.NoError(err)
	
	// Create engine config
	cfg := Config{
		ChainID:       ids.GenerateTestID(),
		QPubKey:       rtPK,
		QThreshold:    1, // Single node for test
		QuasarTimeout: 100 * time.Millisecond,
	}
	
	// Create engine
	engine, err := NewEngine(nodeID, blsSK, rtSK, cfg)
	require.NoError(err)
	require.NotNil(engine)
	
	// Test proposing a block
	ctx := context.Background()
	height := uint64(1)
	parentID := ids.GenerateTestID()
	txs := [][]byte{
		[]byte("tx1"),
		[]byte("tx2"),
		[]byte("tx3"),
	}
	
	// Start a goroutine to self-deliver RT share
	go func() {
		time.Sleep(10 * time.Millisecond)
		
		// Get our own share
		blockHash := make([]byte, 32)
		share, _ := engine.quasar.sign(height, blockHash)
		
		// Self-deliver
		engine.OnRTShare(height, share)
	}()
	
	// Propose should succeed with dual cert
	err = engine.Propose(ctx, height, parentID, txs)
	require.NoError(err)
	
	// Check that block was created
	select {
	case block := <-engine.blockCh:
		require.NotNil(block)
		require.Equal(height, block.Height)
		require.Len(block.Certs.BLSAgg, 96)
		require.NotNil(block.Certs.RTCert)
		require.Len(block.Certs.RTCert, 3072)
	case <-time.After(200 * time.Millisecond):
		t.Fatal("No block received")
	}
}

func TestEngineSlashing(t *testing.T) {
	require := require.New(t)
	
	// Setup
	nodeID := ids.GenerateTestNodeID()
	blsSK, _, _ := bls.KeyGen()
	rtSeed := make([]byte, 32)
	rand.Read(rtSeed)
	
	mock := &MockRingtail{}
	rtSK, rtPK, _ := mock.KeyGen(rtSeed)
	
	cfg := Config{
		ChainID:       ids.GenerateTestID(),
		QPubKey:       rtPK,
		QThreshold:    3, // Need 3 shares but we won't provide them
		QuasarTimeout: 50 * time.Millisecond, // Short timeout
	}
	
	engine, err := NewEngine(nodeID, blsSK, rtSK, cfg)
	require.NoError(err)
	
	// Propose without enough RT shares
	ctx := context.Background()
	height := uint64(1)
	parentID := ids.GenerateTestID()
	txs := [][]byte{[]byte("tx1")}
	
	// This should timeout and trigger slashing
	err = engine.Propose(ctx, height, parentID, txs)
	require.Error(err)
	require.Equal(ErrQuasarTimeout, err)
	
	// Check slash event
	select {
	case slash := <-engine.slashCh:
		require.Equal(height, slash.Height)
		require.Equal(nodeID, slash.ProposerID)
		require.Contains(slash.Reason, "Quasar timeout")
	case <-time.After(100 * time.Millisecond):
		t.Fatal("No slash event received")
	}
}

func TestEngineVerifyBlock(t *testing.T) {
	require := require.New(t)
	
	// Setup
	nodeID := ids.GenerateTestNodeID()
	blsSK, _, _ := bls.KeyGen()
	rtSeed := make([]byte, 32)
	rand.Read(rtSeed)
	
	mock := &MockRingtail{}
	rtSK, rtPK, _ := mock.KeyGen(rtSeed)
	
	cfg := Config{
		ChainID:       ids.GenerateTestID(),
		QPubKey:       rtPK,
		QThreshold:    1,
		QuasarTimeout: 100 * time.Millisecond,
	}
	
	engine, err := NewEngine(nodeID, blsSK, rtSK, cfg)
	require.NoError(err)
	
	// Create a valid block
	block := &Block{
		Header: Header{
			ChainID:    cfg.ChainID,
			Height:     1,
			ParentID:   ids.GenerateTestID(),
			Timestamp:  time.Now(),
			ProposerID: nodeID,
		},
		Transactions: [][]byte{[]byte("tx1")},
	}
	
	// Add valid certificates
	blockHash := block.Header.Hash()
	blsSig, _ := bls.Sign(blsSK, blockHash[:])
	copy(block.Certs.BLSAgg[:], blsSig)
	
	// Add valid RT cert
	share, _ := engine.quasar.sign(1, blockHash[:])
	_, cert := engine.quasar.onShare(1, share)
	block.Certs.RTCert = cert
	
	// Verify should pass
	err = engine.VerifyAndAccept(block)
	require.NoError(err)
	require.Equal(uint64(1), engine.Height())
}

func TestEngineQuantumAttack(t *testing.T) {
	require := require.New(t)
	
	// Setup
	nodeID := ids.GenerateTestNodeID()
	blsSK, _, _ := bls.KeyGen()
	rtSeed := make([]byte, 32)
	rand.Read(rtSeed)
	
	mock := &MockRingtail{}
	rtSK, rtPK, _ := mock.KeyGen(rtSeed)
	
	cfg := Config{
		ChainID:       ids.GenerateTestID(),
		QPubKey:       rtPK,
		QThreshold:    1,
		QuasarTimeout: 100 * time.Millisecond,
	}
	
	engine, err := NewEngine(nodeID, blsSK, rtSK, cfg)
	require.NoError(err)
	
	// Create block with forged BLS but invalid RT cert
	block := &Block{
		Header: Header{
			ChainID:    cfg.ChainID,
			Height:     1,
			ParentID:   ids.GenerateTestID(),
			Timestamp:  time.Now(),
			ProposerID: nodeID,
		},
		Transactions: [][]byte{[]byte("malicious tx")},
	}
	
	// Add "forged" BLS signature (would be valid if attacker has quantum computer)
	rand.Read(block.Certs.BLSAgg[:])
	
	// Add invalid RT cert (attacker cannot forge this)
	block.Certs.RTCert = make([]byte, 3072)
	rand.Read(block.Certs.RTCert)
	
	// Mock BLS verification to simulate quantum attack
	// In real implementation, attacker would have valid BLS
	
	// Verify should fail on RT cert and trigger slashing
	err = engine.VerifyAndAccept(block)
	require.Error(err)
	
	// Should have slash event for quantum attack
	select {
	case slash := <-engine.slashCh:
		require.Equal(block.Height, slash.Height)
		require.Equal(block.ProposerID, slash.ProposerID)
		require.Contains(slash.Reason, "quantum attack")
	case <-time.After(100 * time.Millisecond):
		// No slash if BLS also failed (not a quantum attack)
	}
}

func BenchmarkEngineProposeWithDualCert(b *testing.B) {
	// Setup
	nodeID := ids.GenerateTestNodeID()
	blsSK, _, _ := bls.KeyGen()
	rtSeed := make([]byte, 32)
	rand.Read(rtSeed)
	
	mock := &MockRingtail{}
	rtSK, rtPK, _ := mock.KeyGen(rtSeed)
	
	cfg := Config{
		ChainID:       ids.GenerateTestID(),
		QPubKey:       rtPK,
		QThreshold:    1,
		QuasarTimeout: 100 * time.Millisecond,
	}
	
	engine, _ := NewEngine(nodeID, blsSK, rtSK, cfg)
	
	ctx := context.Background()
	parentID := ids.GenerateTestID()
	txs := [][]byte{
		[]byte("tx1"),
		[]byte("tx2"),
		[]byte("tx3"),
	}
	
	b.ResetTimer()
	
	for i := 0; i < b.N; i++ {
		// Self-deliver RT share
		go func(h uint64) {
			blockHash := make([]byte, 32)
			share, _ := engine.quasar.sign(h, blockHash)
			engine.OnRTShare(h, share)
		}(uint64(i))
		
		_ = engine.Propose(ctx, uint64(i), parentID, txs)
		
		// Drain block channel
		<-engine.blockCh
	}
}