// Copyright (C) 2019-2025, Lux Industries Inc. All rights reserved.
// See the file LICENSE for licensing terms.

//go:build go1.18
// +build go1.18

package beam

import (
	"bytes"
	"context"
	"testing"
	"time"
	
	"github.com/luxfi/ids"
	"github.com/luxfi/crypto/bls"
	"github.com/luxfi/crypto/ringtail"
)

// FuzzQuasarShares tests the Quasar share handling with random inputs
func FuzzQuasarShares(f *testing.F) {
	// Add seed corpus
	f.Add(uint64(1), []byte("test share data"))
	f.Add(uint64(100), []byte("another share"))
	f.Add(uint64(^uint64(0)), []byte{0xFF, 0xFF, 0xFF})
	
	// Setup
	seed := make([]byte, 32)
	seed[0] = 1
	mock := &MockRingtail{}
	sk, pk, _ := mock.KeyGen(seed)
	
	cfg := Config{
		QPubKey:       pk,
		QThreshold:    3,
		QuasarTimeout: 100 * time.Millisecond,
	}
	
	q, _ := newQuasar(sk, cfg)
	
	f.Fuzz(func(t *testing.T, height uint64, shareData []byte) {
		// Test various share sizes
		if len(shareData) == 0 {
			return
		}
		
		// Resize to valid share size if needed
		share := make([]byte, 430)
		copy(share, shareData)
		
		// Should not panic
		ready, cert := q.onShare(height, share)
		
		// Verify invariants
		if ready {
			if cert == nil {
				t.Error("ready but no certificate")
			}
			if len(cert) != 3072 {
				t.Errorf("invalid cert size: %d", len(cert))
			}
		}
	})
}

// FuzzBlockVerification tests block verification with random inputs
func FuzzBlockVerification(f *testing.F) {
	// Add seed corpus
	f.Add([]byte{1, 2, 3}, []byte{4, 5, 6})
	f.Add(make([]byte, 96), make([]byte, 3072))
	
	// Setup
	seed := make([]byte, 32)
	seed[0] = 1
	mock := &MockRingtail{}
	sk, pk, _ := mock.KeyGen(seed)
	
	cfg := Config{
		QPubKey:       pk,
		QThreshold:    3,
		QuasarTimeout: 100 * time.Millisecond,
	}
	
	q, _ := newQuasar(sk, cfg)
	
	f.Fuzz(func(t *testing.T, blsData []byte, rtData []byte) {
		// Create block with fuzzed certificates
		block := &Block{
			Header: Header{
				ChainID:  ids.GenerateTestID(),
				Height:   1,
				ParentID: ids.GenerateTestID(),
			},
		}
		
		// Ensure correct sizes
		if len(blsData) >= 96 {
			copy(block.Certs.BLSAgg[:], blsData[:96])
		}
		
		if len(rtData) > 0 {
			block.Certs.RTCert = rtData
		}
		
		// Should not panic
		err := VerifyBlock(block, q)
		
		// Verification should fail for random data
		if err == nil && len(rtData) != 3072 {
			t.Error("verification passed with invalid cert size")
		}
	})
}

// FuzzEngineProposeEdgeCases tests edge cases in propose logic
func FuzzEngineProposeEdgeCases(f *testing.F) {
	// Add interesting heights
	f.Add(uint64(0))
	f.Add(uint64(1))
	f.Add(uint64(^uint64(0)))
	f.Add(uint64(1<<32 - 1))
	
	f.Fuzz(func(t *testing.T, height uint64) {
		// Setup
		nodeID := ids.GenerateTestNodeID()
		blsSK, _, _ := bls.KeyGen()
		
		seed := make([]byte, 32)
		seed[0] = byte(height)
		mock := &MockRingtail{}
		rtSK, rtPK, _ := mock.KeyGen(seed)
		
		cfg := Config{
			ChainID:       ids.GenerateTestID(),
			QPubKey:       rtPK,
			QThreshold:    1,
			QuasarTimeout: 10 * time.Millisecond, // Very short for testing
		}
		
		engine, err := NewEngine(nodeID, blsSK, rtSK, cfg)
		if err != nil {
			t.Skip("engine creation failed")
		}
		
		// Test propose with edge case height
		ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)
		defer cancel()
		
		parentID := ids.GenerateTestID()
		txs := [][]byte{{1, 2, 3}}
		
		// Should not panic
		_ = engine.Propose(ctx, height, parentID, txs)
	})
}

// FuzzCertificateAggregation tests aggregation with various inputs
func FuzzCertificateAggregation(f *testing.F) {
	// Add corpus with different share counts
	f.Add(1)
	f.Add(3)
	f.Add(15)
	f.Add(21)
	f.Add(100)
	
	f.Fuzz(func(t *testing.T, numShares int) {
		if numShares < 0 || numShares > 1000 {
			return
		}
		
		// Generate shares
		shares := make([]ringtail.Share, numShares)
		for i := 0; i < numShares; i++ {
			share := make([]byte, 430)
			share[0] = byte(i)
			shares[i] = share
		}
		
		// Test aggregation
		mock := &MockRingtail{}
		cert, err := mock.Aggregate(shares)
		
		if numShares == 0 {
			if err == nil {
				t.Error("expected error for zero shares")
			}
		} else {
			if err != nil {
				t.Errorf("unexpected error: %v", err)
			}
			if len(cert) != 3072 {
				t.Errorf("invalid cert size: %d", len(cert))
			}
		}
	})
}

// FuzzMessageSigning tests signing with various message sizes
func FuzzMessageSigning(f *testing.F) {
	// Add various message sizes
	f.Add([]byte{})
	f.Add([]byte{1})
	f.Add(make([]byte, 32))
	f.Add(make([]byte, 1024))
	
	// Setup
	seed := make([]byte, 32)
	seed[0] = 1
	mock := &MockRingtail{}
	sk, _, _ := mock.KeyGen(seed)
	pre, _ := mock.Precompute(sk)
	
	f.Fuzz(func(t *testing.T, msg []byte) {
		// Ringtail expects 32-byte messages
		if len(msg) != 32 {
			// Should handle gracefully
			_, err := mock.QuickSign(pre, msg)
			if err == nil && len(msg) != 32 {
				t.Error("expected error for non-32-byte message")
			}
			return
		}
		
		// Valid message
		share, err := mock.QuickSign(pre, msg)
		if err != nil {
			t.Errorf("unexpected error: %v", err)
		}
		if len(share) != 430 {
			t.Errorf("invalid share size: %d", len(share))
		}
	})
}

// FuzzConcurrentShareDelivery tests concurrent share delivery
func FuzzConcurrentShareDelivery(f *testing.F) {
	f.Add(5, 3)
	f.Add(21, 15)
	f.Add(100, 67)
	
	f.Fuzz(func(t *testing.T, numShares int, threshold int) {
		if numShares < 1 || numShares > 100 || threshold < 1 || threshold > numShares {
			return
		}
		
		// Setup
		seed := make([]byte, 32)
		mock := &MockRingtail{}
		sk, pk, _ := mock.KeyGen(seed)
		
		cfg := Config{
			QPubKey:       pk,
			QThreshold:    threshold,
			QuasarTimeout: 100 * time.Millisecond,
		}
		
		q, _ := newQuasar(sk, cfg)
		height := uint64(42)
		
		// Deliver shares concurrently
		done := make(chan bool, numShares)
		
		for i := 0; i < numShares; i++ {
			go func(idx int) {
				share := make([]byte, 430)
				share[0] = byte(idx)
				
				ready, cert := q.onShare(height, share)
				if ready && cert != nil {
					done <- true
				} else {
					done <- false
				}
			}(i)
		}
		
		// Collect results
		readyCount := 0
		for i := 0; i < numShares; i++ {
			if <-done {
				readyCount++
			}
		}
		
		// Should have exactly one ready signal when threshold is reached
		if numShares >= threshold && readyCount != 1 {
			t.Errorf("expected 1 ready signal, got %d (shares=%d, threshold=%d)", 
				readyCount, numShares, threshold)
		}
	})
}